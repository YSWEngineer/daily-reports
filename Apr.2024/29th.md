# 2023/04/29(月)
## 🕺 日頃からの意識
<details><summary>日頃からの意識</summary>

- 成長スピードを早めよう。
- 自分の考えや気持ちを簡潔に言語化したり、相手にわかりやすく伝える話し方ができるようになろう。
- 心と身体の状態を把握しながら行動しよう。
- 腕立て・スクワット・腹筋・ストレッチを継続しよう。
- 説明文をよく読もう。ここでの「読む」は内容を認識・把握すること。
- 体調の回復に努めて、行動の範囲を元に戻そう。
- Git & GitHub とお友達になろう。
- 5月の RubyKaigi までにプラクティスを Ruby まで進めよう。
- 「何を、どうするのか」という意識を常に持ちながらプラクティスに臨むこと。
</details>

---


## 📝 プラクティス『Pull Request を行う』の段取り
<details><summary>段取り</summary>

- [x] 各参考ページを確認
  - [x] ~~[GitHub初心者はForkしない方のPull Requestから入門しよう - QNYP Blog](https://blog.qnyp.com/2013/05/28/pull-request-for-github-beginners/)~~
  - [x] [Pull Requestの送り方](https://bootcamp.fjord.jp/pages/91)
  - [x] [サル先生のGit入門 プルリクエスト](https://backlog.com/ja/git-tutorial/pull-request/01/)
  - [x] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [x] [俺の考えるコミットメッセージの書き方 - komagataのブログ](https://docs.komagata.org/5744)
  - [x] [2 要素認証を設定する - GitHub Docs](https://docs.github.com/ja/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication)
  - [x] [2 要素認証を利用した GitHub へのアクセス - GitHub Docs](https://docs.github.com/ja/authentication/securing-your-account-with-two-factor-authentication-2fa/accessing-github-using-two-factor-authentication)
  - [x] [個人用アクセス トークンの作成 - GitHub Docs](https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)
- [x] 個人アクセストークンを作成する
</details>

---


## 🗓️ 今週の ToDo
<details><summary>今週の ToDo</summary>

- [x] 各参考ページを確認
  - [x] ~~[GitHub初心者はForkしない方のPull Requestから入門しよう - QNYP Blog](https://blog.qnyp.com/2013/05/28/pull-request-for-github-beginners/)~~
  - [x] [Pull Requestの送り方](https://bootcamp.fjord.jp/pages/91)
  - [x] [サル先生のGit入門 プルリクエスト](https://backlog.com/ja/git-tutorial/pull-request/01/)
  - [x] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [x] [俺の考えるコミットメッセージの書き方 - komagataのブログ](https://docs.komagata.org/5744)
  - [x] [2 要素認証を設定する - GitHub Docs](https://docs.github.com/ja/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication)
  - [x] [2 要素認証を利用した GitHub へのアクセス - GitHub Docs](https://docs.github.com/ja/authentication/securing-your-account-with-two-factor-authentication-2fa/accessing-github-using-two-factor-authentication)
  - [x] [個人用アクセス トークンの作成 - GitHub Docs](https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)
- [x] 個人アクセストークンを作成する
</details>

---


## ✍🏻 本日の取り組み
- プラクティス『Pull Request を行う』
   - [Docs Pull Requestの送り方](https://bootcamp.fjord.jp/pages/91)
   - [サル先生のGit入門 プルリクエスト](https://backlog.com/ja/git-tutorial/pull-request/01/)
   -  [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
   - [俺の考えるコミットメッセージの書き方 - komagataのブログ](https://docs.komagata.org/5744)

---


## 💡 本日の学び・気付き
<details><summary>Pull Requestの送り方（途中から）</summary>

## Docs チーム開発の作業手順
### 作業する
コードを書いてコミットする。手元でテストが通るようになったら次に進む。

### 作業ブランチをリモートに push する
リモートリポジトリに`push`する前に、リモートのmainブランチが更新されていないか確認のために`rebase`を行う。`rebase`には2つの方法がある。

#### 方法1
```shell
# GitHub上のmainブランチの最新の状態を作業ブランチにrebaseする
$ git checkout {作業ブランチ}
# rebaseを行う
$ git pull --rebase origin main
# コンフリクトが発生したら解消する
$ git push origin {ブランチ名}
```
ここで注意するのは、2度目以降の`push`で、main を`rebase`した際に最新の main が更新されていた場合、リモートのブランチとローカルのブランチでは、元としている main の状態が異なるため、`push`してもエラーになってしまう。エラーになった場合は、
```shell
$ git push origin {ブランチ名} --force-with-lease --force-if includes
```
と、`--force-with-lease --force-if -includes`を付けた`push`を行う。強制上書きをする`force push`とほぼ同じコマンドだが、一つ違うのはpush先のリモートリポジトリにローカルリポジトリにはない最新の`commit`が含まれていた場合にエラーを出してくれる。そのため他の人が、自分が作ったリモートリポジトリに`commit`を追加していてもそれを消してしまう、という事故を防げる。

#### 方法2
```shell
# 先ずローカルのブランチをmainに移動する
$ git checkout main
# ローカルのブランチのmainを最新にする
$ git pull origin main
# 作業ブランチに移動する
$ git checkout {作業ブランチ}
# ローカルのブランチを最新のmainからrebaseする
$ git rebase main
# コンフリクトを解消したらpushする
$ git push origin {作業ブランチ}
```
ここで注意するのは、2度目以降の`push`で、main を`rebase`した際に最新の main が更新されていた場合、リモートのブランチとローカルのブランチでは、元としている main の状態が異なるため、`push`してもエラーになってしまう。エラーになった場合は、
```shell
$ git push origin {作業ブランチ} --force-with-lease --force-if-includes
```
と、`--force-with-lease --force-if -includes`を付けた`push`を行う。強制上書きをする`force push`とほぼ同じコマンドだが、一つ違うのはpush先のリモートリポジトリにローカルリポジトリにはない最新の`commit`が含まれていた場合にエラーを出してくれる。そのため他の人が、自分が作ったリモートリポジトリに`commit`を追加していてもそれを消してしまう、という事故を防げる。

### Pull Request を作る
GitHub 上で Pull Request を作成する。まだ作業の途中であれば Draft Pull Request の状態にする。

#### Pull Request のアサインを自分にする
フィヨルドブートキャンプ独自のルールでは、PR（Pull Request）は誰が作業をしているものなのかを直ぐに把握できるようにするため、アサインを自分にすること。
- assign：...を割り当てる。アサインする。

### CI を通す
フィヨルドブートキャンプでは CI（継続的インテグレーション）のテストに GitHub Actions を使用している。

### 他のメンバーにレビュー依頼をする
- commit を繰り返し、一通りの作業が完了したら、Draft Pull Request を Pull Request にする。
- komagataさん以外の自分以外のメンバーにレビュー依頼をする。自分以外のメンバーとは、現在チーム開発のプラクティスを行なっている受講生を指す。

### メンター（komagataさん）にレビュー依頼する
メンバーのレビューを通過したら、次にkomagataさんにレビュー依頼をする。レビューが通ったら`merge`する（GitHub の Pull requestページの「Merge pull request」ボタンでマージ）。

### ステージング環境での動作チェック
メンターレビューが通り、PR（Pull Request）が`merge`されたらステージング環境に自動でデプロイされる。

#### リリースブランチ
開発した機能を本番環境にリリースする。その内容はリリースブランチとその PR という形で準備されている。自分の作った機能（PR）をステージング環境で動作確認が終わったらチェックボックスにチェックを入れる。

### リリースノートを書く
ステージングで動作確認ができたらリリースノートに自分の実装部分を書く。書くときはサービスを使っているお客さんに向けた文章を心掛けること。

### リリースを待つ
とにかく待つ。

### リリースされたら本番環境で動作チェックする
本番で確認できたら Issue をクローズする。

## レビュー依頼する前に気をつけること
### Conflict が発生していないかどうか
他の人の作業で main が変更されたことにより Conflict が発生している場合は main を rebase すること。

### レビュー依頼をする時は Draft 状態で送らないこと
`Ready for Review`のボタンを押して Draft ではない状態にすること。Draft状態の逆が`Ready for Review`だから。

### GitHub で Pull Request を送った後のコメントのやり取りで気をつけること
GitHub で Pull Request を送ったあとコメント欄でやり取りをしながらレビューを進める。この際にコメントが`Pending`となっている場合、自分以外の他者にはその内容が見えていないので気をつけること(Start a reviewをクリックしてコメントを投稿すると Pending になる)。

Pendingコメントを自分以外に見えるようにするには`Submit review`をクリックすること。
</details>

<details><summary>サル先生のGit入門 プルリクエスト</summary>

## プルリクエストとは？
- プルリクエスト（Pull Request）：開発者のローカルリポジトリでの変更を他の開発者に通知する機能のこと。プルリクエストは Git 自身の機能ではなく GitHub が最初に提供した機能。この機能により、多くの開発者がオープンソース開発に参加しやすくなり、結果として品質の高いコードを作ることが可能になった。プルリクエストは以下のような機能を提供する。
   - 機能追加や改修など、作業内容をレビュー・マージ担当者やその他関係者に通知する。
   - ソースコードの変更箇所をわかりやすく表示する。
   - ソースコードに関するコミュニケーションの場を提供する。

## プルリクエストのメリット
### レビュー・マージ作業をタスク化して管理し、やり取りを記録できる
作成されたプルリクエストは一覧で見ることができるため、未完了のプルリクエストを簡単に確認できる。

プルリクエスト作成者とレビュー担当者は、プルリクエスト上でコメントをやり取りして議論できる。必要があれば、対象のブランチに何度でも変更をコミット・プッシュできる。プッシュされたコミットは、自動的にプルリクエスト上に反映される。

### レビューを促進できる
プルリクエストは、ソースコードの変更部分を明確に表示できる。またプルリクエストの作成者はソースコードの意図や捕捉事項をコメントとして伝えることができる。これらによってレビュー担当者の負担を減らせる。

## プルリクエストを使った開発プロセス
1. [ 開発者 ] 作業対象のソースを clone または pull する。
2. [ 開発者 ] 作業用のブランチを作成する。
3. [ 開発者 ] 機能追加、改修といった開発作業を行う。
4. [ 開発者 ] 作業が完了したら push する。
5. [ 開発者 ] プルリクエストを作成する。
6. [ レビュー・マージ担当者 ] 通知されたプルリクエストから変更を確認しレビューする。
7. [ レビュー・マージ担当者 ] レビュー結果を判断し、必要ならば開発者にフィードバックする。
8. [ レビュー・マージ担当者 ] レビューの結果、問題がない場合はマージする。
9. [ レビュー・マージ担当者 ] レビューの結果、対応自体が不要となるなど、プルリクエスト自体が必要ない場合はクローズする。
上記の3〜7の工程を、必要な分だけ繰り返す。その結果、最終的にマージされるソースコードの品質を向上できる。
</details>

<details><summary>初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ</summary>

### Files changed を確認したか
PRを作ったら必ず Files changed を確認する癖を付けること。

### lint を通しているか
Ruby だったら rubocop、JavaScript だったら eslint。
- lint：ソースコードを読み込んで内容を分析し、問題点を指摘してくれるツール。

### ファイルの末尾に改行があるか
どのエディターでも設定で自動的に入るようにできるので設定すること。

最終行に改行が必要な理由......以下は引用
> POSIX上、テキストファイルは「行」の集合体で、そして「行」は「0文字以上の文字+改行」からなっている、とのことです（Qiita）。
Rubyのコードでも、（よほど変なことをしない限り）それに従わない必要性のある理由もないことでしょう。C言語においても、改行で終わらないコードは正しく動くことが保証されません。

### 同じコミットログが続いていないか
適切な文章などの高度な話題以前に明らかに適当になっている場合がある。コミットログというのはちゃんと見られるものだということを理解すること。

### コミットログが英語/日本語になっていないか
プロジェクトのルールに合わせること。

### コミットログが雑になっていないか
`modify`だけ、`追加`だけは後から見た人が困るのでダメ。

### コミットしたユーザーアイコンが Octcat になっている
gitクライアントに設定したemailアドレスが GitHub のユーザーのメールアドレスと違う場合にこうなる。「普段コードを書いていない（GitHubを使っていない）人なんだな」と思われる。

### 不要なファイルをコミットしていないか
`.DS_Store`（Macのみ）とか`xxx~`（viのみ）とかその人にしか必要ないファイルを含めてしまっていないか。開発に参加する皆んなに必要なものだけを含めるようにすること。

### 無意味なファイルがないか
generator が作成した無意味なファイルは削除すること。例えば実装のない module や、中身のない test, fixtures など。

### gem の group が適切か
test でしか使わない gem が group 無しで全gropuで読み込まれている。必要なところだけにすること。

### 不要な respond to がないか
`json`でアクセスする必要がないのに`scaffold`のコードをそのままで残っている。html だけが必要なら`respond_to`や`format`は削除すること。削除する時に`respond_to`と`format`が何をやっているのか調べた上で消すことも忘れずに。

### 何でもリファクタリングと言ってないか
リファクタリングはプログラムの振る舞いを変えずに内部構造を変えることなので、ちょっとした修正という意味で使ってはいけない。

### 秘密の情報がコミットされていないか
oauth の secret とか、コード中では環境変数にしておくこと。秘密の情報がコミットされると git で過去を修正したとしても GitHub のキャッシュに残ってしまい、完全に消すには GitHub のサポートに連絡するなど面倒なことになる。

### .gitignore は適切か
`.DS_Store`は mac だけのファイル。`.idea`は JetBrains のエディター独自のファイル。そう言った特定の環境の人向けのファイルは`.gitignore`に含めるべきではない。プロジェクトごとの設定ではなく自分のマシン固有の設定に書くべき。

### 大量の依存 gem がコミットされていないか
gem のインストール場所を`vendro/bundle`にあり、その中にある大量の gem のファイルがコミットされていないか確認すること。

### マジックナンバーがないか
- マジックナンバー：その値が何を意味するのか一見してわからない数値や文字列のことを指す。

### メソッドが長すぎないか
「1メソッドは五行以内に収めるべし」というSandi Metzルールというものがある。

### CI をパスする前にレビュー依頼をしない
自分は何にも変えていないから通るはずだと過信しないこと。

### 理解せずコピペしていないか
ググった内容を自分のコードに取り入れることは問題ない。しかし、その内容を自分で理解せずそのまま使うのはよくない。理解していないコードでは何が起きるか分からない。

日本語の作文をするのに似た内容だからといって他の本からそのまま取ってきたら違和感のある文章になってしまうのと同じように、プログラムも変数名や構造を自分のプログラムに合わせずにそのまま使えることはほぼない。理解しているプログラマーにとっては明らかに違和感のあり無駄のあるコードに見える。

なので、

「自分の書いたこの部分が何をやってるか理解してる？」

と先輩に聞かれると言うことがよくある。

意味を理解した上で自分のコードの文脈に合わせた内容に変えて使うこと。
</details>

<details><summary>俺の考えるコミットメッセージの書き方 - komagataのブログ</summary>

## Git を使ったソフトウェア開発で、なぜコミットメッセージが重要なのか？
- 良いコードとは他人が読みやすく、理解しやすいコード。
- コードの5W1H/コミットメッセージの役割
   - Git の機能は、情報伝達のポイントと言われる5W1H「いつ（When）、どこで（Where）、だれが（Who）、なにを（What）、なぜ（Why）、どのように（How）」をきちんと表現できるように作られている。
      - いつ（When）：コードに対していつ変更を加えたのかはタイムスタンプを見れば分かる。
      - どこで（Where）：コードの対して何に変更を加えたのかはリソース（file/dir）名で分かる。
      - だれが（Who）：コードの対して誰が変更を加えたのかは author を見れば分かる。
      - なにを（What）：コードに対してどうやって変更を加えたのかは diff を読めば分かる。
      - なぜ（Why）：コードに対してなぜ変更を加えたのかはコミットメッセージを読めば分かる。
     - どのように（How）：コードの対してどうやって変更を加えたのかは実装を読めば分かる。
- 他人が理解しやすいようにコミットメッセージを書き、コミットすることは、自分自身の成長にも役立つ。
</details>

<details><summary>「Pull Requestのメリット / Pull Requestを使った開発プロセスを理解」についてのまとめ</summary>

今回のプラクティスの終了条件にある「参考の資料を読みPull Requestのメリット、Pull Requestを使った開発プロセスを理解する」について自分の言葉でできるだけ簡潔にまとめてみました。

## Pull Request とは？
Pull Request（PR）はソースコードの変更をレビューしてもらい、問題がなければその変更をメインのコードに統合・併合（マージ）するための機能である。この機能は GitHub などのバージョン管理システムで提供されている。

## Pull Requestのメリット
1. **コードの品質向上**：PRを通じて他の開発者がコードをレビューすることで、バグの早期発見やコードの品質向上が期待できる。
2. **情報・状況の共有**：PRは、チーム内での情報・状況の共有の場にもなる。新しい機能や修正の詳細を共有することでチームの連携やチーム全体の理解が深まる。
3. **履歴の管理**：PRにより、何が変更され、なぜ変更されたのかが記録される。これにより後から変更を追跡することが容易になる。

## Pull Requestを使った開発プロセス
一般的なPRを使った開発プロセスは以下のような流れをとる
1. **ブランチの作成**：まず、作業用のブランチ（分岐）を作成する。
2. **コードの変更**：作業用のブランチでコードの変更を行う。例えば、新機能の追加やバグの修正などプロジェクトにとって必要な作業を行う。
3. **Pull Requestの作成**：コードの変更が完了したら、その変更をメインのコードに統合するためのPRを作成する。
4. **コードレビュー**：PRが作成されたら、他の開発者がそのコードをレビューする。
5. **コードの修正**：必要に応じてコードの修正を行う。修正が完了したら再度レビューを依頼。
6. **マージ**：レビューで問題がないと判断されたらマージする。これにより変更がメインのコードに統合される。
</details>

---


## 📍 次回
- Ruby のプラクティスに着手
   - プラクティス『rbenv』の内容の確認・把握・理解。
   - プラクティス『rbenv』の段取り・タスクばらしなどの作成。

---


## ❤️‍🔥 感想
### 🐙🐈‍⬛ まだお友達にはなれていないけど......
Git & GitHub とは顔見知りぐらいにはなれたのかな？もっと親しくなるには実践の積み重ねが必須だと感じています。

### 🥹🙌🏻 次回から Ruby に着手
やっとの思いでここまで来ました......非常に感慨深いです。RubyKaigi 2024 当日を迎えるまで Ruby の知識をできるだけ多く吸収していきます。

---


## ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 7 hours 48 min
- Total: 293 hours 49 min
