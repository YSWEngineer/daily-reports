# 2025/04/11(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [x] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [x] 9.6 例外処理についてもっと詳しく
   - [x] 9.7 この章のまとめ
- [x] 第10章  yield と Proc を理解する
   - [x] 10.1 イントロダクション
   - [x] 10.2 ブロックを利用するメソッドの定義と yield
   - [x] 10.3 Procオブジェクト
   - [x] 10.4 例題：ワードシンセサイザーの作成
   - [x] 10.5 Procオブジェクトについてもっと詳しく
   - [x] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [x] 11.1 イントロダクション
   - [x] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.1 イントロダクション
      - この章の例題：ログフォーマッタープログラム
      - この章で学ぶこと
    - 11.2 パターンマッチの基本
      - ハッシュをパターンマッチさせる


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.3 パターンマッチの利用パターン
      - valueパターン 〜
    

---


## 💡 本日の学び・気付き
### 11.1 イントロダクション
パターンマッチは Ruby に導入された比較的新しい機能で、一種の条件分岐である。構文は case文に似ているし、同じような使い方もできる。だが、パターンマッチは配列やハッシュの「構造」に着目して条件分岐させたいときにその真価を発揮する。また、代入演算子`=`を使わずに条件分岐内でローカル変数の宣言と代入ができる点も特徴の1つ。

### 11.2 パターンマッチの基本
たとえば、次の方な入れ子になった配列があったとする。
```ruby
records = [
  [2021],
  [2019, 5],
  [2017, 11, 25],
]
```
records配列の中には年月日を表す配列が格納されているが、要素の数は1個、2個、3個の3つのパターンに分かれている。records配列の各要素に対して、`[2021]`のように配列の要素が1つだけの場合はその年の1月1日を、`[2019, 5]`のように2つの場合はその年月の1日を、`[2017, 11, 25]`のように3つの場合はその年月日を Dateオブジェクトに変換して新しい配列を返す処理を考えてみる。

愚直に考えると次のような実装になる。
```ruby
irb(main):001> require 'date'
=> true

# records配列の中身
irb(main):002* records = [
irb(main):003*   [2021],
irb(main):004*   [2019, 5],
irb(main):005*   [2017, 11, 25],
irb(main):006> ]
=> [[2021], [2019, 5], [2017, 11, 25]]

irb(main):007* records.map do |record|
irb(main):008*   case record.size
irb(main):009*   when 1
# 年を指定、月と日は1固定
irb(main):010*     Date.new(record[0], 1, 1)
irb(main):011*   when 2
# 年月を指定、日は1固定
irb(main):012*     Date.new(record[0], record[1], 1)
irb(main):013*   when 3
# 年月日を指定
irb(main):014*     Date.new(record[0], record[1], record[2])
irb(main):015*   end
irb(main):016> end
=> 
[#<Date: 2021-01-01 ((2459216j,0s,0n),+0s,2299161j)>,
 #<Date: 2019-05-01 ((2458605j,0s,0n),+0s,2299161j)>,
 #<Date: 2017-11-25 ((2458083j,0s,0n),+0s,2299161j)>]
```
パターンマッチを使うと次のように書ける。
```ruby
irb(main):017* records.map do |record|
irb(main):018*   case record
irb(main):019*   in [y]
irb(main):020*     Date.new(y, 1, 1)
irb(main):021*   in [y, m]
irb(main):022*     Date.new(y, m, 1)
irb(main):023*   in [y, m, d]
irb(main):024*     Date.new(y, m, d)
irb(main):025*   end
irb(main):026> end
=> 
[#<Date: 2021-01-01 ((2459216j,0s,0n),+0s,2299161j)>,
 #<Date: 2019-05-01 ((2458605j,0s,0n),+0s,2299161j)>,
 #<Date: 2017-11-25 ((2458083j,0s,0n),+0s,2299161j)>]
```
##### パターンマッチの構文
パターンマッチの構文では、`case/in`の組み合わせになっている点に注意。
```ruby
case 式
in パターン1
  パターン1にマッチしたときの処理
in パターン2
  パターン1にマッチせず、パターン2にマッチしたときの処理
else
  パターン1にも2にもマッチしなかったときの処理
end
```
case節の`record`に入っているのが`[2021]`や`[2019, 5]`といった**配列**。in節に書かれた`[y]`が**パターン**。このパターンが意味するのは「**1つの要素しかない配列**」。その次の in節に書かれたパターンは`[y, m]`で、これは「**2つの要素の配列**」。`[y, m, d]`は「**3つの要素の配列**」となる。

最初のループで`record`に入る値は`[2021]`で1要素しかない配列なので、`in [y]`にマッチする。次の`[2019, 5]`は2要素の配列なので、`in [y, m]`にマッチする。最後の`[2017, 11, 25]`は3要素の配列なので、`in [y, m, d]`にマッチする。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBNkhnQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--a884644e0ce4a15468d7fa317b076972e8ef53bf/IMG_1412.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBNkhnQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--a884644e0ce4a15468d7fa317b076972e8ef53bf/IMG_1412.jpeg" width="4032" height="2268" alt="IMG_1412.jpeg"></a>

in節に出てくる`y`、`m`、`d`は、case節の式に対応した要素が代入されるローカル変数になる。`record`が`[2021]`であれば、`in [y]`の`y`に`2021`が代入される。`[2019, 5]`であれば`in [y, m]`の`y`と`m`に`2019`と`5`がそれぞれ代入される。パターンマッチでは代入演算子の`=`を使わずに in節でローカル変数の宣言と代入が行われる点に注意すること。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBNkxnQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--a77d8934364ffff2bed31ec28121ee61d68a27c2/IMG_1413.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBNkxnQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--a77d8934364ffff2bed31ec28121ee61d68a27c2/IMG_1413.jpeg" width="4032" height="2268" alt="IMG_1413.jpeg"></a>

ちなみにパターンマッチでなく、case文を使って書くと次のコードになる。
```ruby
records.map do |record|
  case record.size
  when 1
    y = record[0]
    Date.new(y, 1, 1)
  when 2
    y = record[0]
    m = record[1]
    Date.new(y, m, 1)
  when 3
    y = record[0]
    m = record[1]
    d = record[2]
    Date.new(y, m, d)
  end
end
```
case文も、パターンマッチもどちらも case で始まるため Ruby の文法上では「**case式**」となる。そのため、「case/when式」「case/in式」と呼び分けることもある。
```ruby
# case文（case/when式）
case array
when [1, 2, 3]
  # 省略
end

# パターンマッチ（case/in式）
case [1, 2, 3]
in [a, b, c]
  # 省略
end
```

#### ハッシュをパターンマッチさせる
ハッシュをパターンマッチさせるコード例。今回はハッシュを要素に含む配列。
```ruby
cars = [
  {name: 'The Beatle', engine: '105ps'},
  {name: 'Prius', engine: '98ps', motor: '72ps'},
  {name: 'Tesla', motor: '306ps'}
]
```
それぞれの車のスペックを自動車の型式別に出力してみる。以下はパターンマッチを使用しない場合。
```ruby
irb(main):006* cars.each do |car|
irb(main):007*   if car.key?(:engine) && car.key?(:motor)
irb(main):008*     puts "Hybrid: #{car[:name]} / engine: #{car[:engine]} / motor: #{car[:motor]}"
irb(main):009*   elsif car.key?(:engine)
irb(main):010*     puts "Gasoline: #{car[:name]} / engine: #{car[:engine]}"
irb(main):011*   elsif car.key?(:motor)
irb(main):012*     puts "EV: #{car[:name]} / motor: #{car[:motor]}"
irb(main):013*   end
irb(main):014> end
Gasoline: The Beatle / engine: 105ps
Hybrid: Prius / engine: 98ps / motor: 72ps
EV: Tesla / motor: 306ps
```
次にパターンマッチを使った場合のコード例。
```ruby
irb(main):015* cars.each do |car|
irb(main):016*   case car
irb(main):017*   in {name:, engine:, motor:}
irb(main):018*     puts "Hybrid: #{name} / engine: #{engine} / motor: #{motor}"
irb(main):019*   in {name:, engine:}
irb(main):020*     puts "Gasoline: #{name} / engine: #{engine}"
irb(main):021*   in {name:, motor:}
irb(main):022*     puts "EV: #{name} / motor: #{motor}"
irb(main):023*   end
irb(main):024> end
Gasoline: The Beatle / engine: 105ps
Hybrid: Prius / engine: 98ps / motor: 72ps
EV: Tesla / motor: 306ps
```
in節で値を省略してキーだけを書いた場合は、自動的にキーと同じ名前のローカル変数が作成され、そこに値が代入されるようになっている。
```ruby
cars.each do |car|
  case car
  in {name:, engine:, motor:}
    # 値を省略してキーのみにすると、対応する値がキーと同じ名前のローカル変数に代入される
    puts "Hybrid: #{name} / engine: # {engine} / motor: #{motor}"
```
見た目は case文に似ていても、配列やハッシュの構造をパターン化して条件分岐させるところと、in節で`=`を使わずにローカル変数の宣言と代入が行われる点が、パターンマッチの大きな特徴になる。


---


## ✍🏻 感想
### 🍒 初めましてパターンマッチ
パターンマッチの基本の構文、ハッシュとのパターンマッチについて学びました。正直な感想として、「コードがシンプルに書けるやん！」と感じました。複雑な分岐処理を分かりやすく記述できるのはいいですね。

また、in節で`=`を使わずにローカル変数の宣言と代入が行われる点については、実際に手を動かしてコードを書いて挙動を確かめるのを幾度も繰り返すことで、慣れていきたいと思います。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 08 min
- Total: 1043 hours 39 min
