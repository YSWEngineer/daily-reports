# 2025/04/12(土)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [x] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [x] 9.6 例外処理についてもっと詳しく
   - [x] 9.7 この章のまとめ
- [x] 第10章  yield と Proc を理解する
   - [x] 10.1 イントロダクション
   - [x] 10.2 ブロックを利用するメソッドの定義と yield
   - [x] 10.3 Procオブジェクト
   - [x] 10.4 例題：ワードシンセサイザーの作成
   - [x] 10.5 Procオブジェクトについてもっと詳しく
   - [x] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [x] 11.1 イントロダクション
   - [x] 11.2 パターンマッチの基本
   - [x] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.3 パターンマッチの利用パターン
      - valueパターン
      - variableパターン
      - arrayパターン
      - hashパターン
      - Column：in節に書くのはあくまで「パターン」
      - asパターン
      - alternativeパターン
      - findパターン


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.4 例題：ログフォーマッターの作成
      - 入力データの取得 〜
    

---


## 💡 本日の学び・気付き
### 11.3 パターンマッチの利用パターン
パターンマッチは、いくつかの利用パターンがあり、それぞれに以下のような名前が付けられている。
- **valueパターン**
- **variableパターン**
- **arrayパターン**
- **hashパターン**
- **asパターン**
- **alternativeパターン**
- **findパターン**

#### valueパターン
in節に数値や文字列などを直接指定できる利用パターン。case節の式と in節の値が等しければ、対応する処理が実行される。
```ruby
irb(main):001> country = 'italy'
=> "italy"

irb(main):002* case country
irb(main):003* in 'japan'
irb(main):004*   'こんにちは'
irb(main):005* in 'us'
irb(main):006*   'Hello'
irb(main):007* in 'italy'
irb(main):008*   'Ciao'
irb(main):009> end
=> "Ciao"
```
case文と同様にパターンマッチも値を返すため、結果を変数に代入したりメソッドの戻り値にしたりすることができる。
```ruby
irb(main):010> country = 'italy'
=> "italy"

irb(main):011* message =
irb(main):012*   case country
irb(main):013*   in 'japan'
irb(main):014*     'こんにちは'
irb(main):015*   in 'us'
irb(main):016*     'Hello'
irb(main):017*   in 'italy'
irb(main):018*     'Ciao'
irb(main):019>   end
=> "Ciao"
```
`then`を使い、条件にマッチしたときの処理を1行で書ける点も case文と同じ。
```ruby
# thenで条件にマッチした場合の処理を1行で書ける
case country
in 'japan' then 'こんにちは'
in 'us' then 'Hello'
in 'italy' then 'Ciao'
end
```
case文と違うところは、パターンが1つもマッチしないとエラー（例外）が発生する点。
```ruby
irb(main):020> country = 'india'
=> "india"

# case文の場合は真になる条件が全くなくてもエラーにはならずnilが返るだけ
irb(main):021* case country
irb(main):022* when 'japan'
irb(main):023*   'こんにちは'
irb(main):024* when 'us'
irb(main):025*   'Hello'
irb(main):026* when 'italy'
irb(main):027*   'Ciao'
irb(main):028> end
=> nil

# パターンマッチではいずれの条件にもマッチしない場合は例外が発生する
irb(main):029* case country
irb(main):030* in 'japan'
irb(main):031*   'こんにちは'
irb(main):032* in 'us'
irb(main):033*   'Hello'
irb(main):034* in 'italy'
irb(main):035*   'Ciao'
irb(main):036> end
(irb):29:in `<main>': india (NoMatchingPatternError)
```
エラーを発生させたくない場合は else節を用意すると、どの条件にもマッチしなかった場合の処理が書ける。
```ruby
irb(main):037> country = 'india'
=> "india"

irb(main):038* case country
irb(main):039* in 'japan'
irb(main):040*   'こんにちは'
irb(main):041* in 'us'
irb(main):042*   'Hello'
irb(main):043* in 'italy'
irb(main):044*   'Ciao'
irb(main):045* else
irb(main):046*   'Unknown'
irb(main):047> end
=> "Unknown"
```
想定しなかった条件が発生したときに意図的に例外を`raise`するコードを書く場合は、**自動的に例外が発生するパターンマッチ**を使ったほうがシンプルに書ける。
```ruby
irb(main):048> country = 'india'
=> "india"

# 想定外の条件に備えてelse節で意図的に例外をraiseする
irb(main):049* case country
irb(main):050* when 'japan'
irb(main):051*   'こんにちは'
irb(main):052* when 'us'
irb(main):053*   'Hello'
irb(main):054* when 'italy'
irb(main):055*   'Ciao'
irb(main):056* else
irb(main):057*   raise "無効な国名です。#{country}"
irb(main):058> end
(irb):57:in `<main>': 無効な国名です。india (RuntimeError)

# パターンマッチでは自動的に例外が発生するのでelse節が不要
irb(main):059* case country
irb(main):060* in 'japan'
irb(main):061*   'こんにちは'
irb(main):062* in 'us'
irb(main):063*   'Hello'
irb(main):064* in 'italy'
irb(main):065*   'Ciao'
irb(main):066> end
(irb):59:in `<main>': india (NoMatchingPatternError)
```
else節の代わりに variableパターンを利用し、任意のオブジェクトにマッチする in節を用意することで例外の発生を防止することもできる。
```ruby
irb(main):067> country = 'india'
=> "india"

irb(main):068* case country
irb(main):069* in 'japan'
irb(main):070*   'こんにちは'
irb(main):071* in 'us'
irb(main):072*   'Hello'
irb(main):073* in 'italy'
irb(main):074*   'Ciao'
irb(main):075* in obj
# variableパターンを用いて任意のオブジェクトをマッチさせる（実質的なelse節）
irb(main):076*   "Unknown: #{obj}"
irb(main):077> end
=> "Unknown: india"
```
valueパターンでも case文と同じように in節で範囲オブジェクトやクラス名を書いても機能する。これは case文と同じく valueパターンでも **in節のオブジェクト === case節のオブジェクト**の結果を評価しているため。
```ruby
irb(main):078> value = "abc"
=> "abc"

irb(main):079* case value
irb(main):080* in Integer
irb(main):081*   '整数です'
irb(main):082* in String
# String === "abc"が真なのでここにマッチする
irb(main):083*   '文字列です'
irb(main):084> end
=> "文字列です"
```

#### variableパターン
in節のパターンに変数を書いてローカル変数の宣言と代入を同時に行う利用パターン。次のように`in obj`を書くと、あらゆるオブジェクトがマッチし変数obj に代入される。
```ruby
# 文字列もマッチ
irb(main):001* case 'Alice'
irb(main):002* in obj
irb(main):003*   "obj=#{obj}"
irb(main):004> end
=> "obj=Alice"

# 数値もマッチ
irb(main):005* case 123
irb(main):006* in obj
irb(main):007*   "obj=#{obj}"
irb(main):008> end
=> "obj=123"

# 配列もマッチ
irb(main):009* case [10, 20]
irb(main):010* in obj
irb(main):011*   "obj=#{obj}"
irb(main):012> end
=> "obj=[10, 20]"
```
代入ではなく、in節で事前に定義された変数の値を参照したい場合はピン演算子`^`を使用する。
```ruby
irb(main):013> alice = 'Alice'
=> "Alice"
irb(main):014> bob = 'Bob'
=> "Bob"
irb(main):015> name = 'Bob'
=> "Bob"

# ピン演算子を使って事前に定義した変数を参照する
irb(main):016* case name
irb(main):017* in ^alice # in 'Alice'と書いたのと同じ
irb(main):018*   'Aliceさん、こんにちは！'
irb(main):019* in ^bob # in 'Bob'と書いたのと同じ（ここにマッチ）
irb(main):020*   'Bobさん、こんにちは！'
irb(main):021> end
=> "Bobさん、こんにちは！"
```
ピン演算子は事前に定義された変数だけでなく、in節で代入された変数を同じ in節で参照することもできる。次のコードは、配列の値が3つとも同じだった場合とそれ以外で出力を切り分ける例。
```ruby
irb(main):001* records = [
irb(main):002*   [7, 7, 7],
irb(main):003*   [6, 7, 5]
irb(main):004> ]
=> [[7, 7, 7], [6, 7, 5]]

irb(main):005* records.each do |record|
irb(main):006*   case record
irb(main):007*   in [n, ^n, ^n] # 要素数が3つでなおかつ3つとも同じ値であればマッチ
irb(main):008*     puts "all same: #{record}"
irb(main):009*   else
irb(main):010*     puts "not same: #{record}"
irb(main):011*   end
irb(main):012> end
all same: [7, 7, 7]
not same: [6, 7, 5]
```
ちなみに、ピン演算子を使ったマッチは variableパターンではなく valueパターンとなり、マッチには`===`が利用される。そのため、次のようなコードも書くことができる。
```ruby
irb(main):013* records = [
irb(main):014*   [Integer, 1, 2],
irb(main):015*   [Integer, 3, 'X']
irb(main):016> ]
=> [[Integer, 1, 2], [Integer, 3, "X"]]

irb(main):017* records.each do |record|
irb(main):018*   case record
irb(main):019*   in [klass, ^klass, ^klass] # 最後の2要素が最初の要素のクラスのインスタンスであればマッチ
irb(main):020*     puts "match: #{record}"
irb(main):021*   else
irb(main):022*     puts "not match: #{record}"
irb(main):023*   end
irb(main):024> end
match: [Integer, 1, 2]
not match: [Integer, 3, "X"]
```
in節に指定できる変数はローカル変数のみ。インスタンス変数を使うと構文エラーになる。

#### arrayパターン
in節に`[ ]`を使い配列の構造パターンを指定する利用パターン。`[ ]`の中に書いた変数には対応する要素の値が代入される。
```ruby
irb(main):001* case [1, 2, 3]
irb(main):002* in [a, b, c]
# 配列の要素が3つであればマッチし、なおかつ対応する要素が変数a、b、cに代入される
irb(main):003*   "a=#{a}, b=#{b}, c=#{c}"
irb(main):004> end
=> "a=1, b=2, c=3"
```
配列は入れ子になってもよい。
```ruby
irb(main):005* case [1, [2, 3]]
irb(main):006* in [a, [b, c]]
irb(main):007*   "a=#{a}, b=#{b}, c=#{c}"
irb(main):008> end
=> "a=1, b=2, c=3"
```
上記のコード例は、次のように書くと入れ子になった配列を配列のまま1つの変数に代入することもできる。
```ruby
irb(main):009* case [1, [2, 3]]
irb(main):010* in [a, b]
# bには配列[2, 3]が代入される
irb(main):011*   "a=#{a}, b=#{b}"
irb(main):012> end
=> "a=1, b=[2, 3]"
```
変数はなく、数値や文字列をそのまま in節に指定すると「その値と等しいこと」がマッチの条件になる。
```ruby
irb(main):013* case [1, 999, 3]
irb(main):014* in [1, n, 3]
# 配列の要素数は3、かつ最初と最後の要素がそれぞれ1と3であればマッチ
# 2番目の要素は任意で対応する値が変数nに代入される
irb(main):015*   "n=#{n}"
irb(main):016> end
=> "n=999"
```
各要素のマッチ判定には`===`が使われるため、クラス名（クラスオブジェクト）や範囲オブジェクトを in節に指定して「そのクラスのインスタンスか？」「その範囲に収まる値か？」といった条件を指定することもできる。
```ruby
irb(main):017* case ['Alice', 999, 3]
irb(main):018* in [String, 10.., n]
# 配列の要素数は3、かつ最初の要素は文字列（String型）、かつ2番目の要素が10以上であればマッチ
# 3番目の要素は任意で対応する値が変数nに代入される
irb(main):019*   "n=#{n}"
irb(main):020> end
=> "n=3"
```
in節で同じ変数を2回以上使うことはできない。2回以上使うと構文エラーになる。
```ruby
# in節に同じ変数名を2回以上使うと構文エラーになる
irb(main):021* case [1, 2, 3]
irb(main):022* in [a, a, 3]
irb(main):023*   "a=#{a}"
irb(main):024> end
/Users/yoshiwo/.rbenv/versions/3.3.1/lib/ruby/3.3.0/irb/workspace.rb:117:in `eval': (irb):22: duplicated variable name (SyntaxError)

# 同じ値を同じ変数に代入しようとした場合も同様にエラーになる
irb(main):025* case [1, 1, 3]
irb(main):026* in [a, a, 3]
irb(main):027*   "a=#{a}"
irb(main):028> end
/Users/yoshiwo/.rbenv/versions/3.3.1/lib/ruby/3.3.0/irb/workspace.rb:117:in `eval': (irb):26: duplicated variable name (SyntaxError)
```
ただし、アンダースコア`_`1文字、またはアンダースコア`_`で始まる変数は例外的に2回以上使うことができる。
```ruby
irb(main):029* case [1, 2, 3]
irb(main):030* in [_, _, 3]
# 要素数が3つで最後の要素が3ならマッチ
# 最初と2番目の要素は任意（_は変数として使わない）
irb(main):031*   'matched'
irb(main):032> end
=> "matched"

# _の代わりに_aを使う（意味は上のコードと同じ）
irb(main):033* case [1, 2, 3]
irb(main):034* in [_a, _a, 3]
irb(main):035*   'matched'
irb(main):036> end
=> "matched"
```
in節で`*`を使うと任意の長さの要素を指定したことになる。
```ruby
irb(main):037* case [1, 2, 3, 4, 5]
irb(main):038* in [1, *rest]
# 最初の要素が1であればマッチ
# 2番目以降の要素は任意（0個以上）で、対応する要素が配列として変数restに代入される
irb(main):039*   "rest=#{rest}"
irb(main):040> end
=> "rest=[2, 3, 4, 5]"
```
arrayパターンの in節には必ず`[ ]`を付けていたが、一番外側の`[ ]`は省略ができる。
```ruby
# in節の一番外側の[ ]は省略可能
irb(main):041* case [1, [2, 3]]
irb(main):042* in a, [b, c]
irb(main):043*   "a=#{a}, b=#{b}, c=#{c}"
irb(main):044> end
=> "a=1, b=2, c=3"
```

#### hashパターン
in節に`{ }`を使いハッシュの構造パターンを指定する利用パターン。値に変数を指定すると、その変数に対応する値が格納される。
```ruby
irb(main):001* case {name: 'Alice', age: 20}
irb(main):002* in {name: name, age: age}
irb(main):003*   "name=#{name}, age=#{age}"
irb(main):004> end
=> "name=Alice, age=20"
```
値の変数を省略するとキーと同じ名前の変数に値が代入される。
```ruby
irb(main):005* case {name: 'Alice', age: 20}
irb(main):006* in {name:, age:}
irb(main):007*   "name=#{name}, age=#{age}"
irb(main):008> end
=> "name=Alice, age=20"
```
キーの順番はマッチの結果には影響しない。
```ruby
irb(main):009* case {name: 'Alice', age: 20}
irb(main):010* in {age:, name:}
# キーの順番が一致しなくてもマッチの結果には影響しない
irb(main):011*   "name=#{name}, age=#{age}"
irb(main):012> end
=> "name=Alice, age=20"
```
値には、固定の値や`===`で比較可能な値を指定できる。
```ruby
irb(main):013* case {name: 'Alice', age: 20, gender: :female}
irb(main):014* in {name: 'Alice', age: 18.., gender:}
# :nameの値がAlice、:ageの値が18以上かつ、キーに:genderが含まれればマッチ
# :genderに対応する値は変数genderに代入される
irb(main):015*   "gender=#{gender}"
irb(main):016> end
=> "gender=female"
```
hashパターンと arrayパターンを混在させることも可能
```ruby
irb(main):017* case {name: 'Alice', children: ['Bob']}
irb(main):018* in {name:, children: [child]}
irb(main):019*   "name=#{name}, child=#{child}"
irb(main):020> end
=> "name=Alice, child=Bob"
```
hashパターンの in節は、`key: value`形式のパターンしか許容されていない。`key => value`形式を使おうとすると構文エラーが発生する。この制約により hashパターンで使えるハッシュのキーは必然的にシンボルのみになる。

#### Column：in節に書くのはあくまで「パターン」
in節に書くパターンは一見、単なる配列やハッシュのように見える場合がある。
```ruby
# 配列のように見える
in [1, 2, 3]

# ハッシュのように見える
in {x: 10, y: 20}
```
だが、これはあくまで配列やハッシュの記法（リテラル）に似せただけの「パターン」。配列やハッシュそのものではない。
```ruby
# パターンとしては有効だが、配列リテラルとしては無効（これは配列ではなくパターン）
in 1, 2, 3

# パターンとしては有効だが、ハッシュリテラルとしては無効（これはハッシュではなくパターン）
in x:, y:
```
表面上は配列やハッシュのリテラルに似ていても、in節の中身は「パターン」である。パターンマッチでは in節の見かけに気を付けること！

#### asパターン
asパターンはパターンマッチでマッチしたオブジェクトを変数に代入する利用パターン。以下のようなパターンマッチは「:name が文字列で :age が18以上のハッシュ」にはマッチするが、`:name`や`:age`に対応する値を取得できない。
```ruby
irb(main):001* case {name: 'Alice', age: 20, gender: :female}
irb(main):002* in {name: String, age: 18..}
# マッチするが、:nameや:ageの値が取得できない
irb(main):003> end
=> nil
```
in節のパターンに`=> 変数名`と書くと、マッチしたオブジェクトを変数に代入できる。
```ruby
irb(main):004* case {name: 'Alice', age: 20, gender: :female}
irb(main):005* in {name: String => name, age: 18.. => age}
# => 変数名   の形式でマッチしたオブジェクトを変数に代入できる（asパターン）
irb(main):006*   "name=#{name}, age=#{age}"
irb(main):007> end
=> "name=Alice, age=20"
```
一番外側に`=> 変数名`と書くとマッチしたオブジェクト全体を取得できる。
```ruby
irb(main):008* case {name: 'Alice', age: 20, gender: :female}
irb(main):009* in {name: String, age: 18..} => person
# マッチしたハッシュ全体を変数personに代入できる
irb(main):010*   "person=#{person}"
irb(main):011> end
=> "person={:name=>\"Alice\", :age=>20, :gender=>:female}"
```

#### alternativeパターン
alternativeパターンは2つ以上のパターンを指定し、どれか1つにマッチすればマッチしたと見なす利用パターン。alternativeパターンではパターンをパイプ`|`で連結する。たとえば以下のコードでは、case節の値が0か1か2であればマッチする。
```ruby
irb(main):001* case 2
irb(main):002* in 0 | 1 | 2
irb(main):003*   'matched'
irb(main):004> end
=> "matched"
```
arrayパターンや hashパターンと alternativeパターンを組み合わせることも可能。
```ruby
irb(main):005* case {name: 'Bob', age: 25}
irb(main):006* in {name: 'Alice' | 'Bob' => name, age:}
# :nameの値が'Alice'または'Bob'、かつ:ageというキーがあればマッチ
# さらに:nameと:ageの値をそれぞれ変数nameとageに代入する
irb(main):007*   "name=#{name}, age=#{age}"
irb(main):008> end
=> "name=Bob, age=25"
```
ただし、alternativeパターンと variableパターンを組み合わせることはできない。構文エラーになる。

次のようにパターン全体を asパターンで変数に代入するのはエラーにならない。
```ruby
irb(main):009* case [2021, 4, 1]
irb(main):010* in [Integer, Integer, Integer] | Date => obj
# 整数を3つ含む配列またはDateオブジェクトであればマッチ
# さらにマッチしたオブジェクト全体が変数objに代入される
irb(main):011*   "obj=#{obj}"
irb(main):012> end
=> "obj=[2021, 4, 1]"
```

#### findパターン
findパターンは Ruby 3.0 で導入された利用パターン。たとえば、arrayパターンでは`*`を使い「任意の要素」をパターンとして指定することができた。
```ruby
irb(main):013* case [1, 2, 3, 4, 5]
irb(main):014* in [first, *]
irb(main):015*   "first=#{first}"
irb(main):016> end
=> "first=1"

irb(main):017* case [1, 2, 3, 4, 5]
irb(main):018* in [*, last]
irb(main):019*   "last=#{last}"
irb(main):020> end
=> "last=5"
```
Ruby 3.0 では`*`を2回使い「前と後ろにある任意の要素」をパターンとして表現できる。これにより、配列の中から特定のパターンに合致する部分を見つけて吹き出すことができる。以下は findパターンを使い「10以上の整数が3つ連続する部分」を見つけ出すコード例。
```ruby
irb(main):021* case [13, 11, 9, 6, 12, 10, 15, 5, 7, 14]
irb(main):022* in [*, 10.. => a, 10.. => b, 10.. => c, *]
# findパターンで配列の中から10以上の整数が3つ連続する部分を抜き出す
# 3つの整数はそれぞれ変数a、b、cに代入される
irb(main):023*   "a=#{a}, b=#{b}, c=#{c}"
irb(main):024> end
=> "a=12, b=10, c=15"
```


---


## ✍🏻 感想
### 🍒 パターンを味方につけよう
パターンマッチで使われるさまざまなパターンについて学びました。各パターンを上手に使いこなせれば、シュッとしたコードを書けるようになるでしょう。ただ、パターンマッチの概念はまだ少し複雑に感じています。まずは基本的な仕組みをしっかり身に付けるため、何度も読み書きして練習することから頑張ります🏋🏻


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 hours 55 min
- Total: 1048 hours 34 min
