# 2025/04/16(水)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [x] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [x] 9.6 例外処理についてもっと詳しく
   - [x] 9.7 この章のまとめ
- [x] 第10章  yield と Proc を理解する
   - [x] 10.1 イントロダクション
   - [x] 10.2 ブロックを利用するメソッドの定義と yield
   - [x] 10.3 Procオブジェクト
   - [x] 10.4 例題：ワードシンセサイザーの作成
   - [x] 10.5 Procオブジェクトについてもっと詳しく
   - [x] 10.6 この章のまとめ
- [x] 第11章  パターンマッチを理解する
   - [x] 11.1 イントロダクション
   - [x] 11.2 パターンマッチの基本
   - [x] 11.3 パターンマッチの利用パターン
   - [x] 11.4 例題：ログフォーマッターの作成
   - [x] 11.5 パターンマッチについてもっと詳しく
   - [x] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.5 パターンマッチについてもっと詳しく
      - ガード式
      - 1行パターンマッチ
      - 変数のスコープに関する注意点
      - 自作クラスをパターンマッチに対応させる


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第12章  Ruby のデバッグ技法を身につける
    - 12.1 イントロダクション 〜
    

---


## 💡 本日の学び・気付き
### 11.5 パターンマッチについてもっと詳しく
#### ガード式
パターンマッチでは次のような形式で in節に追加の条件式（if文や unless文）を追加できる。
```ruby
case 式
in パターン if （またはunless） 条件式
  パターンにマッチし、なおかつ条件式が真になった場合に実行する処理
end
```
条件式を追加すると case節の式が in節のパターンにマッチすることに加え、この条件式も真になった場合に in節に対応する処理が実行される。このような条件式を**ガード式**という。ガード式の中ではパターンマッチで代入された変数を参照することもできる。

以下はパターンにマッチした3つの値が連続した整数になっていることをガード式で判定する例。
```ruby
irb(main):001> data = [[1, 2, 3], [5, 4, 6]]
=> [[1, 2, 3], [5, 4, 6]]
irb(main):002* data.each do |numbers|
irb(main):003*   case numbers
irb(main):004*   in [a, b, c] if b == a + 1 && c == b + 1
# 要素が3つの配列かつ、3つの連続した整数であればマッチ
# 値が連続しているかどうかはガード式で判定する
irb(main):005*     puts "matched: #{numbers}"
irb(main):006*   else
irb(main):007*     puts "not matched: #{numbers}"
irb(main):008*   end
irb(main):009> end
matched: [1, 2, 3]
not matched: [5, 4, 6]
=> [[1, 2, 3], [5, 4, 6]]
```
ただし、findパターンとガード式を組み合わせるときは注意が必要。**最初にマッチした部分に対してのみガード条件が適用**され、その結果をもってパターンマッチの成功/失敗が決まる。
```ruby
# n, 2のパターンは1, 2にマッチする。ガード条件も真となる（マッチ成功）
irb(main):001* case [1, 2, 3, 2, 1]
irb(main):002* in [*, n, 2, *] if n == 1
irb(main):003*   "matched: #{n}"
irb(main):004* else
irb(main):005*   'not matched'
irb(main):006> end
=> "matched: 1"

# n, 2のパターンは1, 2にマッチするが、ガード条件は偽となる
# データ上、3, 2にもマッチするが、再検索は行われない（マッチ失敗）
irb(main):007* case [1, 2, 3, 2, 1]
irb(main):008* in [*, n, 2, *] if n == 3
irb(main):009*   "matched: #{n}"
irb(main):010* else
irb(main):011*   'not matched'
irb(main):012> end
=> "not matched"
```

#### 1行パターンマッチ
Ruby のパターンマッチでは case節を省略して**評価したい式 in パターン**を1行で書くこともできる（**1行パターンマッチ**）。マッチすれば true、しなければ false が返る。
```ruby
# 1行パターンマッチはマッチの結果をtrue/falseで返す
irb(main):001> [1, 2, 3] in [Integer, Integer, Integer]
=> true
irb(main):002> [1, 2, 'x'] in [Integer, Integer, Integer]
=> false
```
true または false を返す1行パターンマッチの特性を活かすと、if文でパターンマッチを使える。
```ruby
irb(main):003> person = {name: 'Alice', children: ['Bob']}
=> {:name=>"Alice", :children=>["Bob"]}
irb(main):004* if person in {name:, children: [_]}
# :nameと:childrenをキーに持ち、なおかつ:childrenが要素の1つの配列であれば以下の処理を実行する
irb(main):005*   "Hello, #{name}!"
irb(main):006> end
=> "Hello, Alice!"
```
次のコード例はパターンマッチと selectメソッドを組み合わせて、配列の中からキーに :name と :motor を含むハッシュだけを抽出している。
```ruby
irb(main):007* cars = [
irb(main):008*   {name: 'The Beatle', engine: '105ps'},
irb(main):009*   {name: 'Prius', engine: '98ps', motor: '72ps'},
irb(main):010*   {name: 'Tesla', motor: '306ps'}
irb(main):011> ]
=> 
[{:name=>"The Beatle", :engine=>"105ps"},
...

# selectメソッドと1行パターンマッチを使って、キーに:nameと:motorを含むハッシュだけを抽出する
irb(main):012* cars.select do |car|
irb(main):013*   car in {name:, motor:}
irb(main):014> end
=> [{:name=>"Prius", :engine=>"98ps", :motor=>"72ps"}, {:name=>"Tesla", :motor=>"306ps"}]
```
1行パターンマッチはもう1つ、**式 => パターン**という記法も用意されている。この記法は主にパターンマッチを使った変数代入を利用するために使う。
```ruby
# =>を使った1行パターンマッチで変数nameとchildにハッシュの値を代入する
irb(main):016> {name: 'Alice', children: ['Bob']} => {name:, children: [child]}
irb(main):017> name
=> "Alice"
irb(main):018> child
=> "Bob"
```
この1行パターンマッチ構文を使うと、左辺の式を右辺の変数に代入しているように見えるため、「**右代入**」と呼ばれることがある。
```ruby
# 構文上はパターンマッチだが、左から右へ代入しているようにも見える（通称：右代入）
irb(main):019> 123 => n
irb(main):020> n * 10
=> 1230
```
右代入のメリットは、「**長くて複雑な式を変数に代入する際に視線やキャレットを右端から先頭に戻さずに、そのまま変数を読み書きできる**」こと。
```ruby
irb(main):021> words = 'Ruby is fun'
=> "Ruby is fun"
# 右代入を使えば視線やキャレットを右から左へ戻さずに代入先の変数を読み書きできる
irb(main):022> words.split(' ').map { |word| word.upcase + '!' * 3 }.join(' ') => loud_voice
irb(main):023> loud_voice
=> "RUBY!!! IS!!! FUN!!!"
```
`=>`を使う1行パターンマッチ自体の戻り値はマッチすると`nil`が返り、マッチしないと例外（`NoMatchingPatternError`）が発生する。
```ruby
irb(main):001> 123 => n
=> nil
irb(main):002> 123 => [n, m]
(irb):2:in `<main>': 123: 123 does not respond to #deconstruct (NoMatchingPatternError)
```

#### 変数のスコープに関する注意点
Ruby のパターンマッチは独自の変数スコープ（有効範囲）を作らない。そのため、すでに同名のローカル変数が存在していると意図せず上書きされる可能性がある。また、パターンマッチ内で新たに定義されたローカル変数は、パターンマッチを抜けても使用可能。
```ruby
# 先にローカル変数のnameを定義しておく
irb(main):001> name = 'Alice'
=> "Alice"

# パターンマッチを実行する
irb(main):002* case {name: 'Bob', age: 25}
irb(main):003* in {name:, age:}
irb(main):004*   "name=#{name}, age=#{age}"
irb(main):005> end
=> "name=Bob, age=25"

# 変数nameはパターンマッチによって上書きされる
irb(main):006> name
=> "Bob"

# パターンマッチを抜けてもパターンマッチ内で代入された変数は使用可能
irb(main):007> age
=> 25
```

#### 自作クラスをパターンマッチに対応させる
パターンマッチでは組み込みライブラリだけでなく、自作クラスを対応させることもできる。

自作クラスを arrayパターンに対応させるためには deconstructメソッドを、hashパターンに対応させるためには deconstruct_keysメソッドをそれぞれ定義する。deconstructメソッドは自分自身の配列表現を、deconstruct_keysメソッドでは自分自身のハッシュ表現をそれぞれ戻り値として返すようにする。

例として、平面座標を表す単純な Pointクラスを作成し、このクラスをパターンマッチに対応させるために deconstructメソッドと deconstruct_keysメソッドを定義してみる。
```ruby
class Point
  def initialize(x, y)
    @x = x
    @y = y
  end

  # arrayパターンで呼ばれるメソッド
  def deconstruct
    [@x, @y]
  end

  # hashパターンで呼ばれるメソッド
  def deconstruct_keys(_keys)
    {x: @x, y: @y}
  end

  # 実行結果を分かりやすく表示するためにto_sメソッドもオーバーライドしておく
  def to_s
    "x:#{@x}, y:#{@y}"
  end
end
```
次にこの Pointクラスをパターンマッチで使ってみる。
```ruby
irb(main):023> point = Point.new(10, 20)
=> #<Point:0x00000001257466b8 @x=10, @y=20>
irb(main):024* case point
irb(main):025* in [1, 2]
# ここはマッチしない
irb(main):026* in [10, 20]
# ここにマッチする
irb(main):027*   'matched'
irb(main):028> end
=> "matched"

irb(main):029* case point
irb(main):030* in {x: 1, y: 2}
# ここはマッチしない
irb(main):031* in {x: 10, y: 20}
# ここにマッチする
irb(main):032*   'matched'
irb(main):033> end
=> "matched"
```
in節には`[1, 2]`や`{x: ,y:}`のような形式のパターンがあったが、もう一つ別の形式がある。それが`クラス名(パターン)`または`クラス名[パターン]`という形式。この記法を使うと、arrayパターンや hashパターンを利用しつつ、マッチさせたいオブジェクトの型を限定することができる。たとえば、以下のようなパターンマッチでは Pointオブジェクトが来ても、Arrayオブジェクト（ただの配列）が来ても、どちらもマッチしてしまう。
```ruby
# PointオブジェクトとArrayオブジェクトを混在させた配列を作る
irb(main):034* data = [
irb(main):035*   Point.new(10, 20),
irb(main):036*   [10, 20]
irb(main):037> ]
=> [#<Point:0x0000000125261e68 @x=10, @y=20>, [10, 20]]
irb(main):038* data.each do |obj|
irb(main):039*   case obj
irb(main):040*   in [10, 20]
# PointもArrayもどちらもマッチする
irb(main):041*     puts "obj=#{obj}"
irb(main):042*   end
irb(main):043> end
obj=x:10, y:20
obj=[10, 20]
=> [#<Point:0x0000000125261e68 @x=10, @y=20>, [10, 20]]
```
これを`in Point(10, 20)`や`in Array(10, 20)`に変えると、判定対象となるオブジェクトのデータ型を限定することができる。
```ruby
irb(main):044* data.each do |obj|
irb(main):045*   case obj
irb(main):046*   in Point(10, 20)
# Pointオブジェクトかつ、配列表現が[10, 20]ならマッチ
irb(main):047*     puts "point=#{obj}"
irb(main):048*   in Array(10, 20)
# Arrayオブジェクトかつ、配列表現が[10, 20]ならマッチ
irb(main):049*     puts "array=#{obj}"
irb(main):050*   end
irb(main):051> end
point=x:10, y:20
array=[10, 20]
=> [#<Point:0x0000000125261e68 @x=10, @y=20>, [10, 20]]
```
上記のコードは`()`の代わりに`[]`を使って`in Point[10, 20]`と書いても意味は同じになる。また、hashパターンの場合は`Point(x: 10, y: 20)`もしくは`Point[x: 10, y: 20]`と書く。
```ruby
irb(main):052> point = Point.new(10, 20)
=> #<Point:0x00000001257c9270 @x=10, @y=20>

# クラス名(パターン)の形式を使う場合
irb(main):053* case point
irb(main):054* in Point(x: 10, y: 20)
irb(main):055*   'matched'
irb(main):056> end
=> "matched"

# クラス名[パターン]の形式を使う場合
irb(main):057* case point
irb(main):058* in Point[x: 10, y: 20]
irb(main):059*   'matched'
irb(main):060> end
=> "matched"
```
deconstruct_keysメソッドの引数として渡されるオブジェクトの中身と利用目的について。まず、オブジェクトの中身については、この引数には hashパターンで参照されるキーの配列が渡される。
```ruby
irb(main):001* class Point
irb(main):002*   def initialize(x, y)
irb(main):003*     @x = x
irb(main):004*     @y = y
irb(main):005*   end
irb(main):006*   def deconstruct
irb(main):007*     [@x, @y]
irb(main):008*   end
irb(main):009*   def deconstruct_keys(keys)
# 確認用にkeysの内容を表示する
irb(main):010*     puts "keys=#{keys.inspect}"
irb(main):011*     {x: @x, y: @y}
irb(main):012*   end
irb(main):013*   def to_s
irb(main):014*     "x:#{@x}, y:#{@y}"
irb(main):015*   end
=> :to_s
irb(main):017> 
irb(main):018> point = Point.new(10, 20)

# hashパターンで参照されるキーの配列がdeconstruct_keysメソッドに渡される
irb(main):019> point in {x: 10, y: 20}
keys=[:x, :y]
=> true
irb(main):020> point in {x: 10}
keys=[:x]
=> true

# ただし、**restや**nilのようなパターンが指定された場合は、全ての要素を返す必要があるため、他のキー指定の有無に関わらずnilが渡される
irb(main):021> point in {x: 10, **rest}
keys=nil
=> true
irb(main):022> point in {x: 10, y: 20, **nil}
keys=nil
=> true
```
ハッシュの要素が大量にあったり、値の取得が重たい処理の場合は、毎回全ての要素を返すより、必要最小限の要素を返すようにしたほうが効率的。そこで、パフォーマンス上の懸念がある場合は引数で渡されるキー情報に応じて辺を苦する要素を取捨選択する。
```ruby
def deconstruct_keys(keys)
  # 引数のkeysを参照して、必要最低限の要素を返すコード例
  hash = {}
  hash[:x] = @x if keys.nil? || keys.include?(:x)
  hash[:y] = @y if keys.nil? || keys.include?(:y)
  hash
end
```
このキー情報を使うかどうかは任意。使わない場合はアンダースコア（_）で始まる引数名にして、「API の規約上必要だが、実際には使わない引数」であることを示すと良い。
```ruby
# キー情報は使わないので引数名をアンダースコア始まりにする
def deconstruct_keys(_keys)
  {x: @x, y: @y}
end
```


---


## ✍🏻 感想
### 🍒 パターンマッチを振り返って
Ruby 3.0 から導入されたパターンマッチは、コードをシンプルで読みやすくできる点に魅力を感じました。パターンマッチも他の機能と同様、まずは基本からしっかり手を動かして試し、徐々にガード式や1行パターンマッチなどの応用的な使い方にも挑戦していきたいと思います。

---


### ⏰ 学習時2
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 hours 55 min
- Total: 1051 hours 29 min
