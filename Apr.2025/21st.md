# 2025/04/21(月)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [x] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [x] 9.6 例外処理についてもっと詳しく
   - [x] 9.7 この章のまとめ
- [x] 第10章  yield と Proc を理解する
   - [x] 10.1 イントロダクション
   - [x] 10.2 ブロックを利用するメソッドの定義と yield
   - [x] 10.3 Procオブジェクト
   - [x] 10.4 例題：ワードシンセサイザーの作成
   - [x] 10.5 Procオブジェクトについてもっと詳しく
   - [x] 10.6 この章のまとめ
- [x] 第11章  パターンマッチを理解する
   - [x] 11.1 イントロダクション
   - [x] 11.2 パターンマッチの基本
   - [x] 11.3 パターンマッチの利用パターン
   - [x] 11.4 例題：ログフォーマッターの作成
   - [x] 11.5 パターンマッチについてもっと詳しく
   - [x] 11.6 この章のまとめ
- [x] 第12章  Ruby のデバッグ技法を身につける
   - [x] 12.1 イントロダクション
   - [x] 12.2 バックトレースの読み方
   - [x] 12.3 よく発生する例外クラスとその原因
   - [x] 12.4 プログラムの途中経過を確認する
   - [x] 12.5 汎用的なトラブルシューティング方法
   - [x] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第12章  Ruby のデバッグ技法を身につける
    - 12.4 プログラムの途中経過を確認する
    - 12.5 汎用的なトラブルシューティング方法
    - 12.6 この章のまとめ


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第13章  Ruby に関するその他のトピック
    - 13.1 イントロダクション 〜
    

---


## 💡 本日の学び・気付き
### 12.4 プログラムの途中経過を確認する
バックトレースを解析しても、それで毎回原因がわかるとは限らない。また、エラー（例外）が発生しなくても、プログラムの実効結果が期待した値と異なる場合もある。そんなときはプログラムが実行される順番や変数の中身を確認したりすると原因を突き止めることができる。

プログラムの途中経過や変数の中身を確認する方法はいくつか存在する。

#### printデバッグ
printデバッグは Ruby に限らず、ほかのプログラミング言語でもよく利用されるデバッグ方法で、printメソッドをプログラムに埋め込んでプログラムを実行し、ターミナルに出力される値を確認して不具合の原因を探る手法である。以下は printデバッグの実行例。
```ruby
def to_hex(r, g, b)
  [r, g, b].sum('#') do |n|
    # 変数（ブロックパラメータ）の中身をターミナルに出力する
    puts n
    n.to_s(16).rjust(2, '0')
  end
end
```
また、printデバッグは変数やメソッドの値を出力するだけでなく、メソッドや条件分岐が意図したとおりに実行されているかどうかを確認する場合にも使える。
```ruby
def greet(country)
  # greetメソッドが呼ばれたことを確認
  puts 'greet start.'
  return 'countryを入力してください' if country.nil?

  if country == 'japan'
    # 真の分岐に入ったことを確認
    puts 'japan'
    'こんにちは'
  else
    # 偽の分岐に入ったことを確認
    puts 'other'
    'hello'
  end
end
```
`puts`と`p`（または`pp`）の使い分けもできるようになると便利になる。putsメソッドは戻り値が`nil`になるが、pメソッドは引数がそのまま戻り値になるため、pメソッドを使うと以下のようにターミナルへの出力と変数への代入を一度に行うこともできる。
```ruby
def calc_fare(ticket)
  from = STATIONS.index(ticket.stamped_at)
  to = STATIONS.index(@name)
  # to - fromの結果をターミナルに出力しつつ、変数distanceに代入する
  distance = p to - from
  FARES[distance - 1]
end
```
printデバッグの注意点として、デバッグをした後はデバッグのために追加したコードを削除すること。削除しないとプログラムを実行するたびにターミナルにデバッグ用の文字列が出力されてしまう。

#### tapメソッドでメソッドチェーンをデバッグする
メソッドチェーンを使用している場合は、tapメソッドと printデバッグを組み合わせる方法もある。
```ruby
# ブロックパラメータのsには、tapメソッドのレシーバ（ここでは文字列の"hello"）が入る
irb(main):001> a = 'hello'.tap { |s| puts "<<#{s}>>" }
<<hello>>
=> "hello"

# tapメソッドはレシーバをそのまま返す（つまりa = 'hello'と同じ結果になる）
irb(main):002> a
=> "hello"
```
この特徴を利用すると、tapメソッドをメソッドチェーンの途中に挟み込むことで、途中の値を確認することができる。
```ruby
# メソッドチェーンを使っているこのコードをデバッグしたい
'#043c78'.scan(/\w\w/).map(&:hex)

# tapメソッドを使い、scanメソッドの戻り値をターミナルに表示する
irb(main):003> '#043c78'.scan(/\w\w/).tap { |rgb| p rgb }.map(&:hex)
["04", "3c", "78"]
```

#### ログにデバッグ情報を出力する
開発中の Rubyプログラムがログ出力できるようになっていれば、putsメソッドや pメソッドの代わりにログに値を書き出すようにしても良い。以下は Railsアプリケーションでログ出力するコード例。
```ruby
class User < ApplicationRecord
  def facebook_username
    info = facebook_auth.auth_info.info
    # ログに変数info.nameの値を出力する
    logger.debug "[DEBUG] info.name : #{info.name}"
    info.name
  end
end
```
デバッグ情報をログに出力する場合、大量のログが出力される時があるので、「ここでデバッグようにログ出力した」ということが見てわかるようにしておくと良い。上記の例では、`[DEBUG]`のような目印を付けたうえでログ出力されている。

#### デバッガ（debug.gem）を使う
printデバッグは手軽な反面、確認したい内容の分だけ出力用のコードを埋め込んでいく必要がある。また、printデバッグを使うと実際には非効率なところもある。そのため、デバッガも使えるようになっておくと便利。デバッガは対話的にデバッグすることができる。つまり、プログラムを1行ずつ実行しながら変数の中身を確認したり、実行される条件分岐を確認したりすることができる。

Ruby の代表的なデバッガには、標準ライブラリとして提供されている debugライブラリと、外部ライブラリ（gem）として提供されている Byebug がある。

第3章で作成した FizzBuzzプログラムのテストを使い、先ずはデバッガを起動させるポイントを指定する。今回は lib/fizz_buzz.rb の fizz_buzzメソッドに処理が移ったタイミングで停止させてみる。以下のように debugライブラリを`require`したあと、if文が始まる直前に`binding.break`というコードを挟み込んでみる。　
```ruby
# debugライブラリをrequireする
require 'debug'

def fizz_buzz(n)
# if文が始まる直前にbinding.breakを挟み込む
  binding.break
  if n % 15 == 0
    'Fizz Buzz'
  elsif n % 3 == 0
    'Fizz'
  elsif n % 5 == 0
    'Buzz'
  else
    n.to_s
  end
end
```
この状態で一度テストしてみる。
```shell
~/ruby-book % ruby test/fizz_buzz_test.rb
Run options: --seed 48592

# Running:

[1, 10] in ~/ruby-book/lib/fizz_buzz.rb
     1| require 'debug'
     2| 
     3| def fizz_buzz(n)
=>   4|   binding.break
     5|   if n % 15 == 0
     6|     'Fizz Buzz'
     7|   elsif n % 3 == 0
     8|     'Fizz'
     9|   elsif n % 5 == 0
    10|     'Buzz'
=>#0	Object#fizz_buzz(n=1) at ~/ruby-book/lib/fizz_buzz.rb:4
  #1	FizzBuzzTest#test_fizz_buzz at test/fizz_buzz_test.rb:6
  # and 18 frames (use `bt' command for all frames)
(rdbg) 
```
- `=>`はこれから実行する行を示している。
- `#0`と`#1`の2行は直近の2件のメソッド呼び出しの履歴を表示している。
- `# and 21 frames`はそれ以降の21件のメソッド呼び出しが省略されていることを示している。

##### debug.gemで使用できる主なコマンド
|コマンド   |説明   |
|---|---|
|step/s   |実行を1行進めて停止する。その行にメソッド呼び出しがあれば、そのメソッドの中に入って停止する（ステップイン）。   |
|next/n   |実行を1行進めて停止する。その行にメソッド呼び出しがあれば、そのメソッドを実行してから次の行で停止する（ステップオーバー）。   |
|finish/fin   |現在実行中のメソッドを最後まで実行し、呼び出し元に戻ってきたところで停止する（ステップアウト）。   |
|continue/c   |プログラムを再開する。停止すべきポイント（ブレークポイント）がなければ、そのプログラムの最後までプログラムを実行する。   |
|p式もしくはpp式   |Ruby の pメソッドや ppメソッドのように、指定された式の値を表示する。   |
|リターンキー   |直前に実行したコマンドを繰り返す。   |
|help/h   |使用可能なコマンドとその説明を表示する。**help + コマンド名**で特定のコマンドのヘルプを表示することもできる（例 help c など）。   |
|quit/q または CTRL + D   |デバッガを途中で終了する。quit の代わりに quit!（または q!）と入力すると、確認なしで即座に終了する。   |

### 12.5 汎用的なトラブルシューティング方法
バックトレースを読むこと、デバッガを使用すること以外にもエラーや不具合に対処する方法はさまざま。もし行き詰まってしまったら、以下の方法も試してみること。

#### irb上で簡単なコードを動かしてみる
Ruby には irb という対話型の実行環境がある。メソッドの使用や戻り値がわからないときは、irb上で簡単なコードを動かしてみると、どんな結果が返ってきているのかイメージしやすくなる。

#### ログを調べる
Rails のようなフレームワークではログを出力するものがある。うまく動かないときはログを見るとエラーや警告のメッセージが出力されていたり、何がどういう順番で処理されていたのかを把握する手がかりが残っているかもしれない。

#### 公式ドキュメントや公式リファレンスを読む
プログラミング言語や外部ライブラリは何らかの公式ドキュメントや公式リファレンスを提供している。公式ドキュメントはその技術における**一次情報**であり、網羅性や信憑性が高いレベルで担保されている。

Ruby の場合、公式リファレンスは日本語で提供されているが、gem（外部ライブラリ）の公式ドキュメントは英語で書かれていることが多い。英語の情報も恐れずに読み進めるようにすること。

#### issue を検索する
自分が遭遇した問題は、ほかの人がすでに遭遇していたものかもしれない。Ruby をはじめとするオープンソースソフトウェアはネット上に issueトラッキングシステムを公開していることが多い。この中を検索すると、過去に同じ問題が報告され、その解決方法が提示されている可能性がある。

#### ライブラリのコードを読む
外部ライブラリを使用している場合は、自分の書いたコードを見ているだけでは問題が解決しないこともある。そんなときはライブラリのコードまで降りていく必要がある。

ライブラリのコードがマシン内のどこに存在しているのかは、**Methodクラスの source_locationメソッド**を使って調べることができる。

Ruby に不慣れなうちは難しく感じるかもしれないが、デバッグを Ruby の勉強も兼ねて、ライブラリのコードを読むことにもチャレンジしてみること。

#### テストコードを書く
これはデバッグにかかる時間を節約するためのテクニック。テストコードを使ってデバッグするときは次のような手順になる。
- **①エラーや不具合が起きているロジックを通るようなテストコードを書く。**
- **②assert_equalなどを使って正常に動く場合を想定した検証コードを書く。**
- **③テストコードを実行すると失敗すること（= コードに問題があること）を確認する。**
- **④テストコードを実行しながらデバッグを繰り返し、テストをパスさせる（デバッグ終了）。**
- **⑤（オプション）修正したコードをさらにリファクタリングする。**

#### "警戒しながら"ネットの情報を参考にする
一番手軽かつ、一番危険な方法は「ネットを検索する」こと。理想は最初から公式ドキュメントを読みにいくことだが、公式ドキュメントはわかりにくくハードルが高いと感じる場合は、まずネットで見つけた情報で雰囲気を掴み、それから公式ドキュメントを読みにいって正確に理解する、という手順を踏むのが良い。

#### パソコンの前から離れる
プログラミング中にどうしても解決できない問題に遭遇した場合はパソコンの前を離れて時間を置くと解決する場合がある。以下のような気分転換をしてみること。
- **トイレに行く。**
- **飲み物を買いに行く。**
- **外を散歩する。**
- **昼寝する。**
- **ご飯を食べる。**
- **お風呂に入る。**
- **その日はもう寝る。**

#### 誰かに聞く
どうしても一人で解決できない場合は周りの同僚や熟練者に助けを求めること。

最初から最後まで一人で解決した方が自分の勉強になるという意見もあるが、効率的な時間の使い方を考えるのであれば、他の誰かの力を借りるのも一つの有効な選択肢である。


---


## ✍🏻 感想
### 🍒 デバッグ技法を身に付けよう
プログラミングに行き詰まったときの立ち回り方を学びました。一次情報はほとんど英語で提供されていますが、英語の情報を怖がらずに積極的に読み解く習慣を身に付けたいと思います。


---


### ⏰ 学習時2
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 04 min
- Total: 1055 hours 42 min
