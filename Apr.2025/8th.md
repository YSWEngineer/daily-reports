# 2025/04/08(火)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [x] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [x] 9.6 例外処理についてもっと詳しく
   - [x] 9.7 この章のまとめ
- [x] 第10章  yield と Proc を理解する
   - [x] 10.1 イントロダクション
   - [x] 10.2 ブロックを利用するメソッドの定義と yield
   - [x] 10.3 Procオブジェクト
   - [x] 10.4 例題：ワードシンセサイザーの作成
   - [x] 10.5 Procオブジェクトについてもっと詳しく
   - [x] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第10章  例外処理を理解する
    - 10.5 Procオブジェクトについてもっと詳しく
      - Procオブジェクトを実行するさまざまな方法
      - & と to_procオブジェクト
      - Column：で、yield や Proc ってどこで使うの？


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第11章  パターンマッチを理解する
    - 11.1 イントロダクション
      - この章の例題：ログフォーマッタープログラム 〜
    

---


## 💡 本日の学び・気付き
### 10.5 Procオブジェクトについてもっと詳しく
#### Procオブジェクトを実行するさまざまな方法
Procオブジェクトを実行する方法は call以外にもいくつかある。
```ruby
irb(main):001> add_proc = Proc.new { |a, b| a + b }

# callメソッドを使う
irb(main):002> add_proc.call(10, 20)
=> 30

# yieldメソッドを使う
irb(main):003> add_proc.yield(10, 20)
=> 30

# .()を使う
irb(main):004> add_proc.(10, 20)
=> 30

# []を使う
irb(main):005> add_proc[10, 20]
=> 30

# ===を使う方法もある
irb(main):006> add_proc === [10, 20]
=> 30
```
ちなみに、`.()`は`.call()`の糖衣構文（簡略記法）で、`add_proc.(10, 20)`と`add_proc.call(10, 20)`は全く同じ意味になる。

また、Procオブジェクトが`===`で呼び出せるようになっているのかというと、**case文の when節で Procオブジェクトを使えるようにするため**である。たとえば以下のコードは Procオブジェクトと case文を組み合わせて、大人、子供、二十歳のいずれかを判断する例。
```ruby
irb(main):001* def judge(age)
# 20より大きければtrueを返すProcオブジェクト
irb(main):002*   adult = Proc.new { |n| n > 20 }
# 20より小さければtrueを返すProcオブジェクト
irb(main):003*   child = Proc.new { |n| n < 20 }

irb(main):004*   case age
irb(main):005*   when adult
irb(main):006*     '大人です'
irb(main):007*   when child
irb(main):008*     '子どもです'
irb(main):009*   else
irb(main):010*     'はたちです'
irb(main):011*   end
irb(main):012> end
=> :judge

irb(main):013> judge(25)
=> "大人です"
irb(main):014> judge(18)
=> "子どもです"
irb(main):015> judge(20)
=> "はたちです"
```

#### & と to_procメソッド
Procオブジェクトをブロックとして渡したい場合は、引数の前に`&`を付ける必要がある。
```ruby
irb(main):001> reverse_proc = Proc.new { |s| s.reverse }
# mapメソッドにブロックを渡す代わりに、Procオブジェクトを渡す（ただし&が必要）
irb(main):002> ['Ruby', 'Java', 'Python'].map(&reverse_proc)
=> ["ybuR", "avaJ", "nohtyP"]
```
`&`の役割は Procオブジェクトをブロックと認識させるだけではない。厳密には右辺のオブジェクトに対して to_procメソッドを呼び出し、その戻り値として得られた Procオブジェクトを、ブロックを利用するメソッドに与える。

ただし、元から Procオブジェクトだった場合は to_procメソッドを読んでも自分自身が返るだけ。
```ruby
irb(main):003> reverse_proc = Proc.new { |s| s.reverse }
=> #<Proc:0x000000010f51c510 (irb):3>
irb(main):004> other_proc = reverse_proc.to_proc
# Procオブジェクトに対してto_procメソッドを読んでも自分自身が返るだけ
irb(main):005> reverse_proc.equal?(other_proc)
=> true
```
しかし、Ruby には Procオブジェクト以外で to_procメソッド持つものがある。その1つが**シンボル**。シンボルを変換してできた Procオブジェクトが変わっている点は、実行時の引数の数によって実行される処理の内容が微妙に変化するところ。

たとえば`:split`というシンボルを`to_proc`で Procオブジェクトに変換する。
```ruby
irb(main):001> split_proc = :split.to_proc
irb(main):002> split_proc
=> #<Proc:0x000000012a51ffd8(&:split) (lambda)>
```
この Procオブジェクトに引数を1つ渡して実行すると、1つめの引数をレシーバにし、そのレシーバに対して元のシンボルと同じ名前のメソッドを呼び出す。
```ruby
# 引数が1つの場合は 'a-b-c-d e'.split と同じ（ホワイトスペースで分割する）
irb(main):003> split_proc.call('a-b-c-d e')
=> ["a-b-c-d", "e"]
```
引数を2つ渡すと、1つ目の引数はレシーバのままだが、2つ目の引数がシンボルで指定したメソッドの第1引数になる。
```ruby
# 引数が2つの場合は 'a-b-c-d e'.split('-') と同じ（指定された文字で分割する）
irb(main):004> split_proc.call('a-b-c-d e', '-')
=> ["a", "b", "c", "d e"]
```
引数を3つ渡すと、3つ目の引数がシンボルで指定したメソッドの第2引数になる。
```ruby
# 引数が3つの場合は 'a-b-c-d e'.split('-', 3) と同じ（分割する個数を制限する）
irb(main):005> split_proc.call('a-b-c-d e', '-', 3)
=> ["a", "b", "c-d e"]
```
同じ容量で引数を4つ渡すと......というように、シンボルから Procオブジェクトを作成した場合は実行時の第1引数がメソッドのレシーバに、第2引数以降がメソッドの引数になる。また、シンボル自身はレシーバに対して呼び出すメソッドの名前になる。

「4.4.5 & とシンボルを使ってもっと簡潔に書く」では以下のような2つのコードが同じ結果になると説明があった。
```ruby
irb(main):001> ['ruby', 'java', 'python'].map { |s| s.upcase }
=> ["RUBY", "JAVA", "PYTHON"]
irb(main):002> ['ruby', 'java', 'python'].map(&:upcase)
=> ["RUBY", "JAVA", "PYTHON"]
```
具体的には以下のような説明になる。
- ①`&:upcase`はシンボルの`:upcase`に対して to_procメソッドを呼び出す。
- ②シンボルの`:upcase`が Procオブジェクトに変換され、mapメソッドにブロックとして渡される。
- ③上記②で作った Procオブジェクトは mapメソッドから配列の各要素を実行時の第1引数として受け取る。第1引数は upcaseメソッドのレシーバとなる。つまり、配列の各要素に対して upcaseメソッドを呼び出す。
- ④mapメソッドは Procオブジェクトの戻り値を順に新しい配列に詰め込む。
- ⑤上記③と④のコンビネーションにより、配列の各要素が大文字に変換された新しい配列が mapメソッドの戻り値になる。

#### Procオブジェクトとクロージャ
メソッドの引数やメソッドのローカル変数は通常、メソッドの実行が終わると参照できなくなる。しかし、Procオブジェクト内で引数やローカル変数を参照すると、メソッドの実行が完了しても Procオブジェクトは引き続き引数やローカル変数にアクセスし続けることができる。

たとえば以下のコードでは`generate_proc`という Procオブジェクトを生成して返すメソッドを定義している。
```ruby
def generate_proc(array)
  counter = 0
  # Procオブジェクトをメソッドの戻り値とする
  Proc.new do
    # ローカル変数のcounterを加算する
    counter += 10
    # メソッド引数のarrayにcounterの値を追加する
    array << counter
  end
end
```
次にメソッドの外部で`values`という空の配列を用意し、generate_procメソッドに渡して戻り値の Procオブジェクトを`sample_proc`という変数で受け取る。generate_procメソッドを呼び出した直後は`values`の中身は空のまま。
```ruby
irb(main):008> values = []
=> []
irb(main):009> sample_proc = generate_proc(values)
irb(main):010> values
=> []
```
generate_procメソッドの実行はすでに終わっているが、Procオブジェクトの中ではまだメソッド引数の`array`（メソッドに渡したときの変数名は values）やローカル変数の`counter`は生き続けている。そのため、Procオブジェクトを実行すると`counter`への加算や`array`への値追加が問題なく実行できる。結果として、最初に宣言した`values`の中身が Procオブジェクトを実行するたびにどんどん変わることになる。
```ruby
# Procオブジェクトを実行するとgenerate_procメソッドの引数だったvaluesの中身が書き換えられる
irb(main):011> sample_proc.call
irb(main):012> values
=> [10]

# generate_procメソッド内のローカル変数counterも加算され続ける
irb(main):013> sample_proc.call
irb(main):014> values
=> [10, 20]
```
一般に、生成時の変数情報などのコンテキストを保持している関数を**クロージャ**（closure、関数閉包）と言う。Ruby の**ブロックや Procオブジェクトはクロージャとして振る舞う**。

#### Column：で、yield や proc ってどこで使うの？
もし Railsアプリケーションを作る予定であれば、ほとんどの人が Proc（とくにラムダ）を使うシーンに遭遇する。それは、ActiveRecord のスコープ（scope）。
```ruby
class Guitar < ApplicationRecord
  scope :gold, -> { where(color: 'gold') }
end
```
上のコード例では scopeメソッドに2つの引数を渡している。1つめはスコープの名前である`:gold`、2つめはクエリの本体となる Procオブジェクト。ここでは`-> { }`の記法を使っているので、Procオブジェクトはラムダになる。Railsプログラマを目指す人なら誰もが Procオブジェクトを使うことになるので、押さえておくこと。

一方、yield はというとRuby初心者はあまり使う機会がないかもしれない。もし、他の人が書いたコードを読んでいて`yield`を見かけたら、この章をもう一度読み直すこと。


---


## ✍🏻 感想
### 🍒 少しずつ慣れていこう
`yield`と`Proc`について学びました。まだブロックや Procオブジェクトの理解が浅いですが、焦らず少しずつ慣れていきたいと思います。

次回は「パターンマッチ」について学びます。Ruby 3.0から導入された機能らしいのですが、こちらも全く知らなかったので初顔合わせですね。頑張ります😊


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 44 min
- Total: 1041 hours 31 min
