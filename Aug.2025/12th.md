# 2025/08/12(火)
## 📚 プラクティス『lsコマンドを作る1』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>


<details><summary>📌 要件</summary>

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと

</details>

<details><summary>📚 参考資料</summary>

<details><summary>参考</summary>

  - [x] [lsコマンドを作る](https://bootcamp.fjord.jp/pages/380)
</details>
 

<details><summary>学習の狙い</summary>

  - [x] [【lsコマンド】大きな問題を小さく分解してから取り組む](https://bootcamp.fjord.jp/pages/279)
</details>

<details><summary>ヒント</summary>

  - [x] [lsコマンドの使い方と覚えたい15のオプション【Linuxコマンド集】](https://eng-entrance.com/linux_command_ls)
  - [x] [library optparse (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/library/optparse.html)
  - [x] [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)
  - [ ] [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)
  - [ ] [binding.irb](https://docs.ruby-lang.org/ja/latest/method/Kernel/m/binding.html)
  - [ ] [Fileクラス](https://docs.ruby-lang.org/ja/latest/class/File.html)
  - [ ] [lsコマンドで表示されるファイルのモード(drwxr-xr-x) 〜RubyのFile::Stat#modeとは〜](https://zenn.dev/universato/articles/20201202-z-mode)
</details>

<details><summary>良いプログラムを書くための方法</summary>

  - [ ] [プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try](https://blog.jnito.com/entry/2020/10/20/092724)
  - [ ] [\[RubyTips\] ハッシュテーブルによる分岐数削減](https://docs.komagata.org/5691)
  - [ ] [プログラムを書くときの考え方](https://bootcamp.fjord.jp/pages/147)
  - [ ] [rubyでコマンドを作る](https://bootcamp.fjord.jp/pages/250)
  - [ ] [RubyTips - komagataのブログ](https://docs.komagata.org/tags/rubytips/)
  - [ ] [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)
  - [ ] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [ ] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
  - [ ] [代表的なデータ構造](https://bootcamp.fjord.jp/pages/148)
  - [ ] [配列の二人三脚を避ける](https://bootcamp.fjord.jp/pages/388)
  - [ ] [参考：lsコマンドの列幅が人によって異なるのはなぜ？ | FBC
](https://bootcamp.fjord.jp/questions/707)
</details>

 <details><summary>終了条件の確認</summary>

- [x] [終了条件 - lsコマンドを作る](https://bootcamp.fjord.jp/pages/ls-command#requirements)
</details>
</details>


---


### 🧑🏻‍💻 本日の取り組み
#### プラクティス『lsコマンドを作る1』🛠️💻
- [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)


---


### ⏭️ 次回
#### プラクティス『lsコマンドを作る1』🛠️💻
- [ ] [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)


---


### 💡 本日の学び・気付き
#### コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート
##### オプションごとにパラメータを受け取れるようにする
`on`メソッドでオプション名を指定するときに、その後ろにパラメータ名を指定すると、そのオプションにはパラメータ指定が必要であることを示すことができる。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-a', '--add ITEM', 'add an item') { |v| puts "Add #{v}" }
opt.on('-d', '--del ITEM', 'delete an item') { |v| puts "Delete #{v}" }
opt.parse(ARGV)
```
次のようにオプションごとにパラメータを受け取ることができるようになる。ロングオプションのパラメータの前は、スペースで区切っても、`=`で区切っても大丈夫。
```shell
~/opt % ruby sample.rb -a 100
Add 100
~/opt % ruby sample.rb --add 200
Add 200
~/opt % ruby sample.rb --del=300
Delete 300
```
各オプションに対してパラメータを単純に追記すると、そのパラメータ指定は必須だとみなされる。そのため、下記のようにパラーメータの指定を忘れるとエラーが発生する。
```shell
# オプションの後ろのパラメータを指定しないとエラーが発生
~/opt % ruby sample.rb -d
sample.rb:6:in `<main>': missing argument: -d (OptionParser::MissingArgument)
```

##### オプションのパラメータを省略可能にする
オプションごとのパラメータ名を`[`で始めると、そのパラメータは省略可能になる。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-a', '--add [ITEM]', 'add an item') do |val|
  if val != nil
    puts "Add #{val}"
  else
    puts "Add something"
  end
end
opt.parse(ARGV)
```
```shell
~/opt % ruby sample.rb --add 100
Add 100
# パラメータを指定しなくてもエラーは発生しなくなる
~/opt % ruby sample.rb --add    
Add something
```

##### ヘルプオプション('-h', '-help')の説明を表示する
`OptionParser`を使用すると、自動的に`-h`と`--help`オプションが定義されるが、それによるヘルプメッセージには`-h`と`--help`オプションの説明が表示されない。
```shell
~/opt % ruby sample.rb --help
Usage: sample [options]
    -a, --add                        add an item
```
ヘルプメッセージに`-h`と`--help`の説明を表示するには、他のオプションと同じように`on`メソッドでオプションを定義する。これらの**ハンドラ**の中では、`OptionParser`オブジェクト自体を出力するようにすると、ヘルプメッセージを表示することができる。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-a', '--add', 'add an item') { puts "Add"}
# -h または --help が指定されたときのハンドラを登録している
opt.on('-h', '--help', 'show this help') { puts opt; exit }
opt.parse(ARGV)
```
```shell
~/opt % ruby sample.rb --help
Usage: sample [options]
    -a, --add                        add an item
    -h, --help                       show this help
```
###### ハンドラ（handler）とは？
- ハンドラとは、**そのイベントが起きたときに実行する処理**のこと。
- 玄関のチャイムを「ハンドラ」に例えると、誰かが訪問してインターホンを押した（イベント）ときに「（ピンポーンと）音を鳴らす」「受話器を取る」などの行動を行う仕組みがハンドラ。
- 今回のコード例では、`opt.on(...) { ... }`の`{ }`ブロックの中に書いた部分が「そのオプションが見つかったときに実行される**ハンドラ**」となる。

##### オプションではない引数も扱う
例えば、下記のようにコマンドライン引数を指定したとする。
```shell
$ ruby sample.rb -n 100 hoge
```
最後に指定した`hoge`という引数は、オプションのパラメータとしてはみなされないので、`OptionParser#on('-n' ...)`によるハンドラの中で取得することができない。このような場合は、`OptionParser#parse!`を使用してコマンドライン引数を**パース**することで、`ARGV`の中に`hoge`だけが残るようにする。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-n VALUE', 'do something') { |v| puts "do something with #{v}" }
opt.parse!(ARGV)

# ARGV の中にオプションとしてパースされなかった残りの引数が残っている
puts "ARGV = #{ARGV}"
```
```shell
~/opt % ruby sample.rb -n 100 hoge
do something with 100
ARGV = ["hoge"]
```
###### そもそもパース（parse）とは？
- 「パース（parse）」は、渡された言葉（ARGV）を読み取り、意味ごとに分けて解釈すること。具体的には「これはオプションです」「これはオプションの値です」「これはただの引数です」と判断して、それぞれに応じた処理をすることを指す。
###### そもそも ARGV とは？
- `ARGV`は「Rubyスクリプトに渡されたコマンドライン引数が全て入った配列」のこと。プログラムを起動するときにシェルが渡す言葉たちが、文字列の配列としてここに入る。
- `ARGV`の中身は文字列の配列（`Array`）。要素は全て`String`。

##### オプションの取得部分をクラス化する
`OptionParser`クラスを使用して、そのアプリケーションに必要なコマンドライン引数をパースするためのクラスを作成しておくと、オプションの扱うコードの見通しがよくなる。下記の例では、内部的に`OptionParser`を使用するクラス（`AppOption`）を作成している。
```ruby
class AppOption
  require 'optparse'

  # インスタンス化と同時にコマンドライン引数をパース
  def initialize
    @options = {}
    OptionParser.new do |o|
      o.on('-a', '--add ITEM [OPT]', 'add item') { |v| @options[:add] = v }
      o.on('-d', '--delete ITEM', 'delete item') { |v| @options[:del] = v }
      o.on('-h', '--help', 'show this help') { |v| puts o; exit }
      o.parse!(ARGV)
    end
  end

  # オプションが指定されたかどうか
  def has?(name)
    @options.include?(name)
  end

  # オプションごとのパラメータを取得
  def get(name)
    @options[name]
  end

  # オプションパース後に残った部分を取得
  def get_extras
    ARGV
  end
end

# 使用例
option = AppOption.new
if option.has?(:add)
  puts option.get(:add)   # --add オプションのパラメータを取得
  puts option.get_extras  # 残りのコマンドライン引数を取得
end
```
```shell
~/opt % ruby sample.rb --add AAA BBB
AAA
BBB
```


---


### ✍🏻 感想
#### 🏋🏻 基本を押さえる
lsコマンドを実装する際、「どのように使われるのかな？」と想像しながら`optparse`の基本を確認しました。今はインプット中心ですが、時間をかけすぎず早く課題に取り組みたいと考えています。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 10 min
- Total: 1229 hours 44 min
