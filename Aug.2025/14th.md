# 2025/08/14(木)
## 📚 プラクティス『lsコマンドを作る1』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>


<details><summary>📌 要件</summary>

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと

</details>

<details><summary>📚 参考資料</summary>

<details><summary>参考</summary>

  - [x] [lsコマンドを作る](https://bootcamp.fjord.jp/pages/380)
</details>
 

<details><summary>学習の狙い</summary>

  - [x] [【lsコマンド】大きな問題を小さく分解してから取り組む](https://bootcamp.fjord.jp/pages/279)
</details>

<details><summary>ヒント</summary>

  - [x] [lsコマンドの使い方と覚えたい15のオプション【Linuxコマンド集】](https://eng-entrance.com/linux_command_ls)
  - [x] [library optparse (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/library/optparse.html)
  - [x] [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)
  - [x] [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)
  - [x] [binding.irb](https://docs.ruby-lang.org/ja/latest/method/Kernel/m/binding.html)
  - [x] [Fileクラス](https://docs.ruby-lang.org/ja/latest/class/File.html)
  - [x] [lsコマンドで表示されるファイルのモード(drwxr-xr-x) 〜RubyのFile::Stat#modeとは〜](https://zenn.dev/universato/articles/20201202-z-mode)
</details>

<details><summary>良いプログラムを書くための方法</summary>

  - [x] [プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try](https://blog.jnito.com/entry/2020/10/20/092724)
  - [x] [\[RubyTips\] ハッシュテーブルによる分岐数削減](https://docs.komagata.org/5691)
  - [x] [プログラムを書くときの考え方](https://bootcamp.fjord.jp/pages/147)
  - [x] [rubyでコマンドを作る](https://bootcamp.fjord.jp/pages/250)
  - [x] [RubyTips - komagataのブログ](https://docs.komagata.org/tags/rubytips/)
  - [ ] [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)
  - [ ] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [ ] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
  - [x] [代表的なデータ構造](https://bootcamp.fjord.jp/pages/148)
  - [ ] [配列の二人三脚を避ける](https://bootcamp.fjord.jp/pages/388)
  - [ ] [参考：lsコマンドの列幅が人によって異なるのはなぜ？ | FBC
](https://bootcamp.fjord.jp/questions/707)
</details>

 <details><summary>終了条件の確認</summary>

- [x] [終了条件 - lsコマンドを作る](https://bootcamp.fjord.jp/pages/ls-command#requirements)
</details>
</details>


---


### 🧑🏻‍💻 本日の取り組み
#### プラクティス『lsコマンドを作る1』🛠️💻
- [プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try](https://blog.jnito.com/entry/2020/10/20/092724)
- [\[RubyTips\] ハッシュテーブルによる分岐数削減](https://docs.komagata.org/5691)
- [プログラムを書くときの考え方](https://bootcamp.fjord.jp/pages/147)
- [代表的なデータ構造](https://bootcamp.fjord.jp/pages/148)
- [rubyでコマンドを作る](https://bootcamp.fjord.jp/pages/250)
- [RubyTips - komagataのブログ](https://docs.komagata.org/tags/rubytips/)

---


### ⏭️ 次回
#### プラクティス『lsコマンドを作る1』🛠️💻
- [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)


---


### 💡 本日の学び・気付き
#### プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try
- 変数名やメソッド名に略称を使うのは長年の経験から「この略称は一般的だから誤解を招くことはきっと少ないだろう」とか「前後の文脈から、変数の中身は誰が見ても明らかだろう」という想像が付いた場合だけ。
- 省略して書く場合がある単語
  - execute = exec
  - initialize = init
  - calculate = calc
  - character = char
  - arguments = args
- 寿命が短いローカル変数や仮引数に対して付ける場合のある単語
  - average = avg
  - maximum / minimum = max / min
  - message = msg
  - exception = e または ex
  - event = e
- 単純なループの変数に対して付けることがある略称
  - 文字列の場合 = s または str（string の略）
  - 文字の場合 = c（character の略）
  - 数値の場合 = i（integer の略）または n（number の略）
  - ファイルオブジェクトの場合 = f（file の略）
- 無味無臭な名前も避ける
  - `data`
  - `info`
  - `item`
  - `element`
  - `obj`
  - `array`（`ary`, `arr`）
  - `list`

↑著書の伊藤さん曰く、上記の変数名を「無味無臭な名前」と読んでいるとのこと。プログラムに出てくる変数は全て何らかのデータなので、data なんて、名前をつけてないのと同じ。**中身が想像できる名前**にすること。


---


#### [RubyTips] ハッシュテーブルによる分岐数削減
**悪い例：**
```ruby
def kana(name)
  result = ""
  if name == "komagata"
    result = "コマガタ"
  elsif name == "machida"
    result = "マチダ"
  elsif name == "tanaka"
    result = "タナカ"
  elsif name == "yamada"
    result = "ヤマダ"
  end
  result
end
```
- 悪い例の if文は分岐を複数書いているが、書き過ぎてしまうと返って読みづらくなってしまう。

**良い例：**
```ruby
def kana(name)
  {
    "komagata" => "コマガタ",
    "machida" => "マチダ",
    "tanaka" => "タナカ",
    "yamada" => "ヤマダ"
  }[name]
end
```
- 良い例は、「鍵（key）を渡したら対応する値（value）を返してくれる」**ハッシュ**をを使用。上記の if文に比べて読みやすくなっているのが分かる。


---


#### プログラムを書くときの考え方
##### 手順
1. 入力と出力を考える
2. データ構造を考える
3. ライブラリを探す
4. ベタに書く
5. クラスに分ける
6. 清書する

##### 入力と出力を考える
ls のプログラムに例えると......

- 入力
  - ファイルのパス
  - オプション
- 出力
  - 文字列（ターミナルに出力する）

##### データ構造を考える
「複数のファイルを持って、それをいろんな形に出すだけだろう。だから Fileクラスの配列かな」と考える。
```ruby
files = [File.new, File.new, File.new]
```
「Fileクラスはこんな雰囲気だろう（-l でいろいろ表示するための情報がいるだろうからなあ）」と考える。
```ruby
class File
  @name
  @permission
  @size
end
```

##### ライブラリを探す
先ず公式のマニュアルで組み込みライブラリ・標準組み込みライブラリから探す。
無ければ、[rubygems.org](https://rubygems.org/) からライブラリを探す。

##### ベタに書く
全てではなくてもいいので、だいたいこんなものかという見通しが立つぐらいにベタに書いてみる。
- ベタに書く：（ここでは）クラス・メソッド構成をあまり深く考えず動くこと優先で書く、という意味。

##### クラスに分ける
「Fileクラスは組み込みのクラスとかぶってしまうため全体を LS という module で囲おう」
`LS::File`
「ターミナルから実行する部分は`command`クラスでいいかな」
`LS::Command`
データ構造を表示方法は分けたい（それぞれ複数の種類があるので増えた場合にも対応できるようにしたい）ので、表示方法毎にクラスに分けたらいいかな。
- `LS::HorizontalFormatter`
- `LS::VerticalFormatter`

「最終的にはこんな感じで実行したい」
```ruby
require "ls/command"

LS::Command.new(ARGV)
```

##### 清書する
ベタに書いたものを上記で考えたクラス・メソッド構成に当てはまるように書いていく。
実装しながら現実に即していない構成だったことに気付いてクラス分け（クラス設計）をやり直すこともある。

##### 慣れてくると・・・
やったことのある内容の場合、最初から設計しつつできるようになるが、実装方法が想像できない場合はベタに書いてから設計したほうが良い。

##### クラス設計のポイント
###### データ構造と表現方法は分ける
表現方法は見た目の話なのでよく変わる。
例えば、
- 「横一列に出してたけどやっぱり縦一列に出したい」
- 「ターミナルに表示してたけどWebに出したい」
- 「音声でスマートスピーカーから出したい」
- 「別のシステムに渡したい」

など。
分けておけばクラスを追加するだけで対応できるようになる。
データ構造はその問題の本質に近いので変わることが少ない。

###### クラス名（名詞） + メソッド名（動詞）で考える
上記のフォーマットで意味が通るようにする。

###### カプセル化を心がける
オブジェクト指向プログラミングにおけるカプセル化とは、「そのクラスを使う他の人にとって必要な情報だけ公開し、不要な情報を隠蔽すること」。
例えば、ls で出てくるクラスだったら、そのクラスを使う人は、
- 「ファイルを一覧したい」
- 「-l が付いていたら詳細な情報が出て欲しい」
- 「-r が付いていたら降順に並んで欲しい」

ぐらいの情報しか持っていないので、ls のクラスを実装する上で必要な「8進数をアルファベットに変換する必要がある」といった情報は外部からは隠蔽するべき。
隠蔽されているというのは「変数やメソッドが public なものとして存在しない」ということ。
```ruby
class Foo
  attr_reader :a

  def initialize(a, b, c)
    @a = a
    @b = b
    @c = c
  end

  def aaa
  end

  def bbb
  end

  private
  def ccc
  end

  def ddd
  end
```
このようなクラスだとすると外部から見るとこのような感じになる。
```shell
foo = Foo.new
foo.a
foo.aaa
foo.bbb
```
この見える部分が他人にとってわかりやすくなるように心がける。

###### このクラスを使うことになった他のプログラマー目線で設計する
簡単な呼び出し方を書いてから作ると客観的に設計できる。
```ruby
require "ls/command"

LS::Command.new(ARGV)
```


---



#### 代表的なデータ構造
##### array
複数のものに使う。順番がある時に使う。
```ruby
array = ["apple", "orange", "banana"]
```

##### set
集合に使う。順番がない時に使う。
```ruby
require "set"

Set["apple", "orange", "banana"]
```

##### stack
重ねておくものに使う。
```ruby
stack = []

# 要素を末尾に追加する
stack.push '大きい皿'
stack.push '小さい皿'
stack #=> ["大きい皿", "小さい皿"]

# 末尾の要素を取得して削除する
stack.pop #=> "小さい皿"
stack.pop #=> "大きい皿"
stack     #=> []
```

##### queue
待ち行列に使う。
```ruby
queue = []

# 要素を末尾に追加する
queue.push '田中'
queue.push '鈴木'
queue #=> ["田中", "鈴木"]

# 先頭の要素を取得して削除する
queue.shift #=> "田中"
queue.shift #=> "鈴木"
queue       #=> []
```

##### hash
名前と値の組み合わせに使う。
```ruby
hash = { apple: 100, orange: 300, banana: 200 }
```


---


#### rubyでコマンドを作る
```shell
$ command.rb
```
このようにコマンドとして使えるプログラムを書く方法。

##### helloコマンド
`hello`と表示するプログラムを書く。
`hello.rb`というファイルを下記の内容で作る。
```ruby
puts 'hello'
```
```shell
$ ruby hello.rb
hello
```

##### 直接実行できるプログラム
`ruby`コマンド経由で rubyスクリプトを実行せず、直接実行できるようにする。

`shebang`を追加
```ruby
#!/usr/bin/env ruby

puts 'hello'
```
```shell
% ./hello.rb
zsh: permission denied: ./hello.rb
% ls -l
total 8
-rw-r--r--  1 yoshiwo  staff  33  8 14 15:57 hello.rb
```
- `./hello.rb`でファイルを直接実行しようとしたが、**実行権限がない**ため`zsh`が拒否。
- ファイルがあっても、実行権限（`x`）が付与されていなければスクリプトは直接動かすことはできない。

そこで、`user`での実行権限を追加する。
```shell
% chmod u+x hello.rb 
```
- `chmod`コマンドで権限を変更する。
- `u`：ユーザー。
- `+x`：実行権限を追加する。
- つまり、「**自分にこのファイルの実行権限を与える**」という操作をしている。

権限の確認、そして直接実行。
```shell
% ls -l
total 8
-rwxr--r--  1 yoshiwo  staff  33  8 14 15:57 hello.rb
% ./hello.rb
hello
```
- 最初の部分が`-rwxr--r--`に変わり、ユーザー（自分）の実行が可能になった。

##### パスを省略して実行する
```shell
% ./hello.rb
```
今いる場所からの相対パスを示す`./`をなくし、以下のようなコマンドを打ち込みたい。
```shell
% hello.rb
```
↑これをできるようにするには`PATH`の通ったディレクトリに置けば良い。

環境変数`PATH`を見てみる。
```shell
% echo %PATH
```
自分用のディレクトリを追加。
```shell
% mkdir ~/bin
```
自分のコマンド置き場を作成。
```shell
% export PATH=$PATH:~/bin
```
作成したディレクトリに先程の`hello.rb`コマンドを移動させる。
```shell
% mv hello.rb ~/bin/
% hello.rb
hello
```
`PATH`（`./`）を省略して実行できるようになった。

##### PATH の設定を永続化する
`export`コマンドで設定した`PATH`は、Terminal を抜ける（ログアウト）すると消えてしまう。永続化するためには`~/.zshrc`などの設定ファイルに書く必要がある。

`~/.zshrc`ファイルを開き、`export PATH=$PATH:~/bin`を書き込む。
```shell
# ~/.zshrcファイルを開き、nano（テキストエディタ）で編集
% nano ~/.zshrc
```

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeGtFQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--183644a5c10a6cab818d2f3fd51205a1828499e3/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202025-08-14%2017.45.59.png" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeGtFQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--183644a5c10a6cab818d2f3fd51205a1828499e3/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202025-08-14%2017.45.59.png" width="3104" height="1974" alt="スクリーンショット 2025-08-14 17.45.59.png"></a>

##### 拡張子が気になる？
```shell
% hello.rb
hello
```
拡張子を無くしたい場合はファイル名を`hello`に変えると良い。
```shell
# hello.rbを~/bin/に移動させたので、移動する
% cd ~/bin
# binの中身を確認
~/bin % ls 
hello.rb
# ファイル名をhelloに変更
~/bin % mv hello.rb hello
# 念の為、helloファイルにユーザーの実行権限を与える
~/bin % chmod +x hello
# .rb拡張子なしでコマンドが実行される
~/bin % hello
hello
```


---


##### [RubyTips] 組み込み・標準添付ライブラリの単語を使おう
独自の構造や単語を考える前に、組み込みライブラリ・標準添付ライブラリでよく使われている構造や単語（クラス名・メソッド名）で表現できないか考えること。

rubyプログラマーにお馴染みの構造・単語でなるべく作ること。

**悪い例：**
```ruby
class Status
  def self.make_stat(file)
    {
      username: self.username(file),
      size: self.size(file),
      basename: File.basename(file)
    }
  end

  def self.username(file)
    # ...
  end

  def self.size(file)
    # ...
  end
end

puts Status.make_stat(file) # => {username => 'komagata', :size => 1234, basename: 'ls.rb'}
```
- メソッド名の前に`self.`を付けたクラスメソッド？が多く使われている。
- メソッド名が分かりにくい。
- 引数`file`を毎回渡している。

**良い例：**
```ruby
class Status
  def initialize(file)
    @file = file
  end

  def to_h
    {
      username: username, 
      size: size, 
      basename: File.basename(@file)
    }
  end

  def username
    # ...
  end

  def size
    # ...
  end
end

puts Status.new(file).to_h # => {username => 'komagata', :size => 1234, basename: 'ls.rb'}
```
- インスタンスメソッドを使用している。
- `@`で始まる変数、インスタンス変数を使用しているので、毎回引数を渡す必要がない？
- メソッド名が直感的で分かりやすい。

**復習：インスタンスメソッドとクラスメソッド**
- Ruby では、クラスを作るメソッドには 2つの種類がある。それが**インスタンスメソッド**と**クラスメソッド**。
- インスタンスメソッドは**インスタンス**（オブジェクト）に対して呼び出すメソッド。
- クラスメソッドは**クラス**に対して呼び出すメソッド。
- クラスメソッドは`def self.メソッド名`のようにメソッド名の前に`self.`を書いて定義する。

|名前   |定義方法   |呼び出し方法   |レシーバ   |ドキュメントでの記法   |
|---|---|---|---|---|
|インスタンスメソッド   |def メソッド名   |インスタンス.メソッド   |インスタンス   |クラス名#メソッド名   |
|クラスメソッド   |def self.メソッド名   |クラス.メソッド   |クラス   |クラス名.メソッド名   |

---


### ✍🏻 感想
#### 🏋🏻 今日も復習とインプット
- 変数名とメソッド名は略さず、意味がわかる名前にすること
- ハッシュを使って分岐を整理すること
- インスタンスメソッドを使うことでコードが読みやすくなること

を学びました。課題に取り組む際は、インプットした内容を意識して活用したいと思います。もし忘れてしまっても、振り返ってまた思い出せばいいくらいの気持ちで、力まずコツコツとインプットを続けていきます。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 hours 41 min
- Total: 1238 hours 44 min
