# 2025/08/20(水)
## 📚 プラクティス『lsコマンドを作る1』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>


<details><summary>📌 要件</summary>

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと

</details>

<details><summary>📚 参考資料</summary>

<details><summary>参考</summary>

  - [x] [lsコマンドを作る](https://bootcamp.fjord.jp/pages/380)
</details>
 

<details><summary>学習の狙い</summary>

  - [x] [【lsコマンド】大きな問題を小さく分解してから取り組む](https://bootcamp.fjord.jp/pages/279)
</details>

<details><summary>ヒント</summary>

  - [x] [lsコマンドの使い方と覚えたい15のオプション【Linuxコマンド集】](https://eng-entrance.com/linux_command_ls)
  - [x] [library optparse (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/library/optparse.html)
  - [x] [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)
  - [x] [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)
  - [x] [binding.irb](https://docs.ruby-lang.org/ja/latest/method/Kernel/m/binding.html)
  - [x] [Fileクラス](https://docs.ruby-lang.org/ja/latest/class/File.html)
  - [x] [lsコマンドで表示されるファイルのモード(drwxr-xr-x) 〜RubyのFile::Stat#modeとは〜](https://zenn.dev/universato/articles/20201202-z-mode)
</details>

<details><summary>良いプログラムを書くための方法</summary>

  - [x] [プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try](https://blog.jnito.com/entry/2020/10/20/092724)
  - [x] [\[RubyTips\] ハッシュテーブルによる分岐数削減](https://docs.komagata.org/5691)
  - [x] [プログラムを書くときの考え方](https://bootcamp.fjord.jp/pages/147)
  - [x] [rubyでコマンドを作る](https://bootcamp.fjord.jp/pages/250)
  - [x] [RubyTips - komagataのブログ](https://docs.komagata.org/tags/rubytips/)
  - [x] [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)
  - [x] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [x] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
  - [x] [代表的なデータ構造](https://bootcamp.fjord.jp/pages/148)
  - [x] [配列の二人三脚を避ける](https://bootcamp.fjord.jp/pages/388)
  - [x] [参考：lsコマンドの列幅が人によって異なるのはなぜ？ | FBC
](https://bootcamp.fjord.jp/questions/707)
</details>

 <details><summary>終了条件の確認</summary>

- [x] [終了条件 - lsコマンドを作る](https://bootcamp.fjord.jp/pages/ls-command#requirements)
</details>
</details>


---


### 🧑🏻‍💻 本日の取り組み
#### プラクティス『lsコマンドを作る1』🛠️💻
- [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)
- [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
- [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
- [配列の二人三脚を避ける](https://bootcamp.fjord.jp/pages/388)
- [参考：lsコマンドの列幅が人によって異なるのはなぜ？ | FBC
](https://bootcamp.fjord.jp/questions/707)


---


### ⏭️ 次回
#### プラクティス『lsコマンドを作る1』🛠️💻
- lsコマンド作成に着手


---


### 💡 本日の学び・気付き
#### Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita
- スクリプト：Rubyファイルをそのまま実行する形式のプログラム。
- トップレベル：クラスやモジュールの中ではない「一番外側」の場所。トップレベルでは「変数の定義・メソッドの定義・条件分岐」などが書ける。

##### あるコードの問題点について
```ruby
require 'date'

def play
  puts 'あそぶよー'
end

def study
  puts '勉強するよー'
end

# トップレベルで変数宣言
today = Date.today

# トップレベルで条件分岐とメソッド呼び出し
if today.sunday?
  play
else
  study
end
```
上記のコードには以下のような問題点がある。

###### コードリーディング時に下から上に進まないといけない
- プログラムとしてのロジックが開始されるのは`today = Date.today`の行からだが、プログラムの構造上、メソッド定義(`def play`や`def study`)を先に書かざるを得なくなる。
- よって、コードリーディング時は先にファイルの下に進んでから、メソッドの内容を確認するために上にスクロールしなければならなくなる。
- 可能なら実行の起点となるコードはスクリプトの先頭に書いて、上から下へ文章のように自然に読みたい。

###### 可読性の低いコードを書いても Rubocop に指摘されない
- トップレベルに書いたロジックはダラダラと何行に渡って書いても、Rubocop に「コードが長すぎる」と指摘されることはない。
- その結果、他の人にとって理解しづらいメソッドを書いてしまう恐れがある。

##### mainメソッドを導入してみる
- このような問題を避けるために、著者（メンターの伊藤さん）は明示的な`main`メソッドを導入することが多い。
```ruby
require 'date'

# トップレベルに書いていたロジックをmainメソッドに移動させる
def main
  today = Date.today
  if today.sunday?
    play
  else
    study
  end
end

def play
  puts 'あそぶよー'
end

def study
  puts '勉強するよー'
end

# トップレベルではmainメソッドの呼び出しを最後に書くだけ
main
```

###### mainメソッドを導入するメリット
- `main`メソッドを導入すると、実行の起点となるコードをスクリプトの先頭に書くことができるため、コードを上から下へ順に読み下しやすくなる。
- また、`main`メソッドが無駄に長くなると Rubocop のチェックで指摘されるようになる。

###### なぜmainという名前なのか
- `main`という名前にしておけば他の開発者も「ここから処理が始まる」と推測しやすくなる。


---


#### 初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ
##### Files changed を確認したか
- PR を作ったら必ず Files changed を確認する癖を付ける。GitHub のソースコードビューワーの機能で色々と気付ける点もある。

##### lint を通しているか
- ruby だったら rubocop、js だったら eslint。
- まずは lint を通しているか否か。

##### ファイルの末尾に改行があるか
- どのエディターでも設定で自動的に入るように設定すること。

##### 同じコミットログが続いていないか
- コミットログはちゃんと見られるものだということを理解する。

##### コミットログが英語 / 日本語になってないか
- プロジェクトのルールに合わせること。

##### コミットログが雑になっていないか
- `modify`だけ、`追加`だけは後から見た人が困るので駄目。困る人には1ヶ月後の自分も含まれる。

##### コミットしたユーザーアイコンが Octcat になっていないか
- gitクライアントに設定した emailアドレスが GitHub のユーザーのメールアドレスと違う場合にこうなる。

##### 不要なファイルをコミットしてないか
`.DS_Store`（Macのみ）とか`xxx~`（viのみ）とかその人にしか必要ないファイルを含めてしまってないか。開発に参加するみんなに必要なものだけを含めるようにする。

##### 無意味なファイルがないか
- generator が作成した無意味なファイルは削除しよう。実装のない module とか、中身のない test、fixtures とか。

##### gem の group が適切か
- test でしか使わない gem が group 無しで全group で読み込まれいている。必要なところだけにしよう。

##### 不要な respond to がないか
- `json`でアクセスする必要がないのに`scaffold`のコードをそのままで残っている。html だけが必要なら`respond_to`や`format`は削除しよう。削除するときに`respond_to`と`format`が何をやっているのか調べた上で消すのも忘れずに。

##### 何でもリファクタリングと言ってないか
- リファクタリングはプログラムの振る舞いを変えずに内部構造を帰ることなので、ちょっとした修正という意味で使ってはいけない。

##### 秘密の情報がコミットされていないか
- oauth の secret とか、コード中では環境変数にしておこう。

##### .gitignore は適切か
- `.DS_Store`は mac だけのファイル。`.idea`は JetBrains のエディター独自のファイル。そういった特定の環境の人向けのファイルは`.gitignore`に含めるべきじゃない。
- プロジェクト毎の設定じゃなくて自分のマシン固有の設定に書くべき。

##### 大量の依存 gem がコミットされていないか
- gem のインストール場所を`vendro/bundle`にあって、その中にある大量の gem のファイルがコミットされてしまっていないか確認すること。

##### メソッドが長すぎないか
- 「1メソッドは5行以内に収めるべし」という Sandi Metzルールというものがある。

##### CI をパスする前にレビュー依頼をしない
- 自分は何にも変えてないから通るはずだと過信しない。

##### 理解せずコピペしてないか
- ググった内容を自分のコードに取り入れることは問題ない。しかし、その内容を自分で理解せずそのまま使うのはよくない。理解していないコードでは何が起きるか分からない。
- 意味を理解した上で自分のコードの文脈に合わせた内容を変えて使うこと。


---


#### 配列の二人三脚を避ける
2つ（もしくは2つ以上）の配列を作って、それらをシンクロさせながらループ処理するロジックをよく見かける。
```ruby
names = ['Alice', 'Bob', 'Carol']
points = [90, 98, 85]

names.size.times do |i|
  name = names[i]
  point = points[i]
  puts "#{name}さんは#{point}点です"
end
#=> Aliceさんは90点です
#   Bobさんは98点です
#   Carolさんは85点です
```
しかし、このロジックは2つの配列の要素数と並ぶ順番に大きく依存する。たとえば片方の要素が増えたり、片方の要素がソートされたりすると、おかしな内容を表示することになる。
```ruby
names = ['Alice', 'Bob', 'Carol']
points = [90, 98, 85]

# 名前だけ要素が増える
names << 'Dave'

names.size.times do |i|
  name = names[i]
  point = points[i]
  puts "#{name}さんは#{point}点です"
end
#=> Aliceさんは90点です
#   Bobさんは98点です
#   Carolさんは85点です
#   Daveさんは点です
```
```ruby
names = ['Alice', 'Bob', 'Carol']
points = [90, 98, 85]

# 点数がソートされる
points.sort!

names.size.times do |i|
  name = names[i]
  point = points[i]
  puts "#{name}さんは#{point}点です"
end
#=> Aliceさんは85点です
#   Bobさんは90点です
#   Carolさんは98点です
```
- `sort`：配列の要素を順に並べるメソッド。配列の要素が数字のときは、小さい順に並び換えられる。
- `sort!`：配列をソート（並び換え）して、元の配列そのものを書き換えてしまう（←これを**破壊的変更**という）。
- メソッドの末尾に`!`が付くメソッド：オブジェクトを破壊的に変更するものが多い。

##### 配列の二人三脚？
メンターの伊藤さん曰く、上記のようなロジックを見ると配列同士が二人三脚しているように見えるとのこと。

##### 自分が書いたコードは絶対に大丈夫？でも実務では......
仕事で書くコードは巨大で複雑。二人三脚のようなロジックを書いていると、予期しないところで配列の中身が変更されるかもしれない。よってこうしたロジックは避けるべき。

##### 解決策：ハッシュを使おう
解決策はいくつかあるが、一番お手軽なのはハッシュを使うこと。ハッシュを使えば、`name`だけが増えたり、`point`だけがソートされたりすることは起きにくくなる。
```ruby
exam_results = []
exam_results << {name: 'Alice', point: 90}
exam_results << {name: 'Bob', point: 98}
exam_results << {name: 'Carol', point: 85}

exam_results.each do |result|
  puts "#{result[:name]}さんは#{result[:point]}点です"
end
#=> Aliceさんは90点です
#   Bobさんは98点です
#   Carolさんは85点です
```
「`name`と`point`はいつでも1つのセットだよ！」ということが保証できるようなデータ構造を使うのが大事なポイント。

###### ポイントまとめ
- ① 配列が二人三脚するようなロジックを書かない（順番が崩れると対応ができない）。
- ② **ハッシュを使用して1つのセットとしてまとめる** → 今回の例の場合「名前と点数が必ずセットで動く」ため、**データを安全に管理できる**。

##### 「もろいプログラム」と「堅牢なプログラム」
プログラムの良し悪しを評価するときに「このプログラムはもろい」、「このプログラムは堅牢だ」という言い方をするときがある。

もろいプログラムは「壊れやすいプログラム」という意味。「うっかり〇〇してしまうと、エラーが出たりおかしな結果になったりする」という場合はもろいプログラムと言える。「2つの配列を用意して二人三脚するロジック」はもろいプログラムである。

反対に堅牢なプログラムは「壊れにくいプログラム」という意味。「よっぽど特殊なことをしない限り、エラーが出たりおかしな結果になったりすることはない」というプログラムは堅牢なプログラムだと言える。

ちなみに、ハッシュは配列の二人三脚に比べれば堅牢だが、実はそこまで堅牢ではない。より堅牢さを求めるのであればクラスを導入する方がベター。


---


### ✍🏻 感想
#### 📚 とりあえずインプット完了
参考資料を一通り読み終えました。まだ lsコマンドを実際に作るイメージはぼんやりしていますが、指定された要件を一つずつ確認しながら進めていきたいと思います。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 hours 13 min
- Total: 1244 hours 26 min
