# 2024/12/19(木)

## 📚 プラクティス『ボウリングのスコア計算プログラム』


## 🧩 タスクばらし
- [x] ボウリングのルールを知る
- [x] 各参考ページを確認
- [ ] ボウリングのスコア計算プログラムを作成
- [ ] 課題提出


## 🐾 スモールステップ
<details><summary>ボウリングのルールを知る</summary>

- [x] ルール詳細を確認
</details>

<details><summary>各参考ページを確認</summary>

- [x] [Docs: 「新ルール（カレントフレームシステム）」のボウリングのスコア計算プログラムの書き方](https://bootcamp.fjord.jp/pages/249)
- [x] [Docs: ボウリングのルールとスコアの付け方](https://bootcamp.fjord.jp/pages/619)
- [x] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
</details>

<details><summary>ボウリングのスコア計算プログラムを作成</summary>

- [ ] ボウリングのスコア計算プログラムを作成
</details>

<details><summary>課題提出</summary>

- [ ] ボウリングのスコア計算プログラムに rubocop-fjord を通す
- [ ] ボウリングのスコア計算プログラムを Pull Request として提出
- [ ] 提出物作成・メンターさんへの提出
   - [ ] Pull Request の URL を貼り付ける
   - [ ] Terminal で実行した結果を**テキスト**で提出物本文に貼り付ける
   - [ ] 「プログラム実行の例」にある入力例全て実行結果をスクリーンショットで貼り付ける
   - [ ] rubocop-fjord のチェックが全てパスした内容をスクリーンショットで貼り付ける
</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『ボウリングのスコア計算プログラム』
- ボウリングのスコア計算プログラムを作成
   - 一行ずつコード化

## 🎯 次回
### プラクティス『ボウリングのスコア計算プログラム』
- ボウリングのスコア計算プログラムを作成
   - 一行ずつ書いていこう
   

------------


## 💡 本日の学び・気付き
### 新ルール（カレントフレームシステム）のコードから旧ルールに書き換えるために必要なこと
#### フレームの定義を変更する
- 新ルール（カレントフレームシステム）：1フレームは2投で固定されていた。ストライクの場合は2投目を0として追加していた。
- 旧ルール：1フレームは2投で区切るが、ストライクの場合は1投でフレームを完結させる。

#### スコア計算のルールを変更する
- 新ルール（カレントフレームシステム）：ストライクは固定で30点、スペアは固定で10点が加算されていた。
- 旧ルール：ストライクの場合、次の2投の得点を加算する。スペアの場合、次の1投の得点を加算する。それ以外はそのフレームの得点をそのまま加算する。

### #frozen_string_literal: true
#### 1. そもそも文字列とは？
文字列とは、コンピュータで言葉や文字を書いたもののこと。
```ruby
"ピヨルド"
"りんご"
"123"
```

#### 2. 文字列は普段どのようにして動くのか？
Ruby では、文字列はあとから変更することができる。
```ruby
greeting = "こんにちは"
greeting << "、お元気ですか？" # 文字をくっつける
puts greeting # => こんにちは、お元気ですか？
```
「こんにちは」から、「、お元気ですか？」が追加された。

#### 3. # frozen_string_literal: ture とは？
この指示を書くと、「**文字列はあとから変えられない**」ようにするルールをプログラムに伝える。
```ruby
# frozen_string_literal: ture
greeting = "こんにちは"
greeting << "、お元気ですか？" # ここでエラーが出る！
```
エラーが出る理由は、「文字列はもう変えられません」というルールが決まっているから。

#### 4. 「文字列はあとから変えられない」というルールが何故あるのか？
**① コンピュータを速くするため**
文字列を変えられないようにするルールを決めておくと、コンピュータが「この文字列は絶対に変わらないな」と判断して（余計な心配はせずに）速く処理できるようになる。

**② 間違いを防ぐため**
プログラムを書いているときに、間違って文字列を変えてしまうことを防げる。

#### 5. 実際に使うときは？
Ruby のプログラムの一番上に書く
```ruby
# frozen_string_literal: true
```
しかし、shebang行を書くときは、一番上にshebang行、その下に# frozen_string_literal: true を書くこと。

##### shebang行を一番上に書く理由
**① OS が shebang行を探すため**
- プログラムを実行するとき、OS はまずファイルの一番上を見て「どのプログラムで実行するか」を判断する。
- shebang行が一番上にないと、OS が正しくスクリプト（命令やコードが書かれたファイル）を実行できない可能性がある。

**② 他の設定やコメントより優先だから**
- プログラムの中にはコメントや設定を書くことがあるが、shebang行が一番上にあると確実にコンピュータに認識される。
- たとえば、`# frozen_string_literal: true`などの特別な指示も、shebang行の後に書くべき。

##### shebang行がない場合はどうなるのか？
これは以前のプラクティスでも確認したが、大きく2つの問題が発生する。
- ① 正しいプログラムで実行されずエラーになる。
- ② 手動でプログラムを指定する必要が出てくる。たとえば、`ruby bowling.rb`と毎回入力しなければならなくなる。

##### 2つのコードを書くときの位置は？
```ruby
#!/usr/bin/env ruby
# frozen_string_literal: true

puts "Hello, world!"
```
と書けばOK。

### << って何？
`<<`は、Ruby で使える便利な演算子の一つ。主に「**データを追加する**」ために使う。いかに簡単な説明をする。
#### 1. << の使い方
**① 文字列に使う**
文字列の後ろに新しい文字や別の文字列を追加できる。
```ruby
greeting = "こんにちは"
greeting << "、お元気ですか？"
puts greeting
# => こんにちは、お元気ですか？
```
- 最初に変数`greeting`に`"こんにちは"`を入れる。
- `<< "、お元気ですか？"`で、 `"、お元気ですか？"`を後ろに付けた。

**② 配列に使う**
配列（データを並べたもの）の中に、新しいデータを追加する。
```ruby
numbers = [1, 2, 3]
numbers << 4
puts numbers.inspect
# => [1, 2, 3, 4]
```
- 最初は`[1, 2, 3]`という配列で、それが変数`numbers`に代入される。
- `<<4`で、`4`を追加して`[1, 2, 3, 4]`となる。

#### 2. << は「左に追加する」というイメージ
- 左側にあるもの（例えば、文字列や配列）の後ろに、右側のものを追加する。
- 実際には「左にデータを追加するから`<<`」と覚えると分かりやすいかも。

#### 3. + との違いは？
- `+`は新しいデータを作る。
- `<<`は元のデータを直接変える（これを「**破壊的操作**」という）。
```ruby
word = "Hello"
word + " World"
puts word
# => "Hello"（元は変わらない）

word << " World"
puts word
# => "Hello World"（元が変わる）
```

#### 4. まとめ
- 文字列や配列にデータを追加したい時に使用。
- 元のデータを直接変える（破壊的操作）。
- イメージとしては「左に追加する」。

### コードを書いてみる
```ruby
# shebang行とfrozen_string_literal: trueを冒頭に書く ※書く順番に気を付ける
#!/usr/bin/env ruby
# frozen_string_literal: true

# コマンドライン引数の最初の要素を変数scoreに代入する。ARGVはコマンドライン引数を格納する特別な配列
score = ARGV[0]

# scoreに格納された文字列をカンマで分割し、結果を変数scoreに代入
scores = score.split(',')

# 空の配列となる変数shotsを初期化する。この空の配列に各ショットの点数が格納される。
shots = []

# スコアを数値化し、"X"を10に置き換える
scores.each do |s| # リストの中にある1つ1つのスコア（`s`）を順番に取り出して、以下の処理を行う。
  if s == 'X' # もしもスコアがX（ストライク）だったら
    shots << 10 # ストライクの点数は10点なので、それを変数shotsに追加する
  else # ストライクではなかったら
    shots << s.to_i # そのスコア（s）を数字に変換して、変数`shots`に追加する
  end
end

# 先ほどのshots = []と同様、空の配列となる変数framesを初期化する。この空の配列に各フレームのショットを格納する。
frames = []
```

### 第6回ゆるっとOSSカフェ☕️
#### 第5回のおさらい
- extbringer に実装した convert_wordメソッドのテストを書いた。
- convert_word は引数に渡した回数、テキストエディタ上の単語に対してブロックで渡した処理を行う。

#### リファクタリング
- リファクタリングは、既存のコードを改善するプロセス。機能の動作は変えずに、コードの構造や可読性を向上させることを目的とする。分かりやすく言い換えると、**コードがより理解しやすくなり、メンテナンスが容易になる。**
- 可読性についての理解が浅いことが分かった。これは実践を積み重ねるしかない。

##### 何故、リファクタリングが必要なのか？
- 可読性の向上：読みやすいコードは、他の開発者や将来の自分にとって理解しやすくなる。
- 保守性の向上：分かりやすいコードはバグの修正や機能追加が容易になる。
- 性能の向上：リファクタリングによって、効率的なデータ構造を使うことができる。
- コードの再利用性の向上：汎用的な構造にすることで、他のプロジェクトでも再利用しやすくなる。

#### Ruby 3.4
- Ruby 3.4 の仕様についてお話。

#### git rebase を使う時に利用するコマンドについて
`pick`：コミットをそのまま使用する。最も一般的に使われるオプションで、指定したコミットを新しいベースにそのまま適用する。
`reword`：コミットメッセージを変更するが、コミット内容自体はそのまま使用する。コミットメッセージを修正したいときに使う。
`edit`：コミットを利用するが、一旦中断してそのコミットを変更したり、修正を追加する。エラー修正や、より細かい変更を加えたいときに使用する。
`squash`：コミットを前のコミットと統合する。メッセージは結合され、１つのコミットにまとめられる。複数の小さなコミットを一つにまとめたいときに使用する。
`fixup`：コミットメッセージを前のコミットに合わせて捨てる。前のコミットに対する小さな修正を加えるときに使用する。
`exec`：指定されたシェルコマンドを実行する。例えばテストを実行したいときなどに便利。
`break`：一時的にrebaseプロセスを中断する。手動での修正や、追加の作業を行いたいときに使用する。
`drop`：コミットを破棄する。適用したくないコミットを完全に除去するときに使用する。



------------


## ✍🏻 感想
### 🧑🏻‍💻 ヒントをちゃんと活かして書く
頭の中で考えていることを紙に書き出し、一行ずつ書き進めました。引き続きプラクティスの説明や日報にあるヒントを活かしていきます。

### 第6回ゆるっとOSSカフェ☕️
皆さんのやりとりの中で気になった用語を一つずつピックアップし、自分の言葉に置き換える作業を行いました。リファクタリングの様子を拝見して、改めてリファクタリングの重要性を感じました。しかし、リファクタリングを行うためには、コードをしっかり読んで理解し、適切な命名にも気を配る必要があり、非常に難しいですよね。

次回は1月9日（木曜日）とのことです。来年も皆さんの背中を見て学びたいと思います！


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 6 hours 01 min
- Total: 783 hours 27 min
