# 2024/12/21(土)

## 📚 プラクティス『ボウリングのスコア計算プログラム』


## 🧩 タスクばらし
- [x] ボウリングのルールを知る
- [x] 各参考ページを確認
- [ ] ボウリングのスコア計算プログラムを作成
- [ ] 課題提出


## 🐾 スモールステップ
<details><summary>ボウリングのルールを知る</summary>

- [x] ルール詳細を確認
</details>

<details><summary>各参考ページを確認</summary>

- [x] [Docs: 「新ルール（カレントフレームシステム）」のボウリングのスコア計算プログラムの書き方](https://bootcamp.fjord.jp/pages/249)
- [x] [Docs: ボウリングのルールとスコアの付け方](https://bootcamp.fjord.jp/pages/619)
- [x] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
</details>

<details><summary>ボウリングのスコア計算プログラムを作成</summary>

- [ ] ボウリングのスコア計算プログラムを作成
</details>

<details><summary>課題提出</summary>

- [ ] ボウリングのスコア計算プログラムに rubocop-fjord を通す
- [ ] ボウリングのスコア計算プログラムを Pull Request として提出
- [ ] 提出物作成・メンターさんへの提出
   - [ ] Pull Request の URL を貼り付ける
   - [ ] Terminal で実行した結果を**テキスト**で提出物本文に貼り付ける
   - [ ] 「プログラム実行の例」にある入力例全て実行結果をスクリーンショットで貼り付ける
   - [ ] rubocop-fjord のチェックが全てパスした内容をスクリーンショットで貼り付ける
</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『ボウリングのスコア計算プログラム』
- ボウリングのスコア計算プログラムを作成
   - 一行ずつコード化

## 🎯 次回
### プラクティス『ボウリングのスコア計算プログラム』
- ボウリングのスコア計算プログラムを作成
   - 作成したコードをリファクタリングする
   

------------


## 💡 本日の学び・気付き
### .sum
中身を全て足したものを得るメソッド。たとえば、`[7, 2]`の場合は`7 + 2 = 9`。取り出したスコアが空（次のフレームがない場合）なら合計は`0`。要するに今回のコードでは、**投げて獲得したボールの点数のを全て足して**くれる。

### Enumerable#take, Array#take
**Rubyリファレンスマニュアル**
> Enumerable オブジェクトの先頭から n 要素を配列として返します。

> 配列の先頭から n 要素を配列として返します。このメソッドは自身を破壊的に変更しません。

**まとめると**
- `take(n)`の`n`は「何個取り出すか」を決める数字。
- 元のリストや配列の順番を変えたりはしない。
```ruby
fruits = ["りんご", "バナナ", "みかん", "キウイ", "パイナップル"]
fruits.take(2)
#=> ["りんご", "バナナ"]

fruits = ["りんご", "バナナ", "みかん", "キウイ", "パイナップル"]
fruits.take(5)
#=> ["りんご", "バナナ", "みかん", "キウイ", "パイナップル"]
```

### コードを書いてみる（はじめから最後まで）
<details><summary>⚠️ ネタバレ注意</summary>

```ruby
#!/usr/bin/env ruby # shebang行：スクリプトがどのインタプリタで実行されるべきかを指定している。
# frozen_string_literal: ture # 「文字列はあとから変えられないようにする」というルールをプログラムに伝える。

score = ARGV[0] # コマンドラインから入力された最初の引数を変数scoreに格納する。ARGV（アーグブイ）は引数を格納する特別な配列。
scores = score.split(',') # 変数scoreに格納された文字列をsplitメソッド
shots = [] # 空の配列となる変数shotsを初期化（作る）する。この空の配列に各投球の点数が格納される。

# スコアを数値化し、"X"を10に置き換え
scores.each do |s| # 配列scoresの中にある各要素sを順番に処理する。
  if s == 'X' # もし、s（スコア）がX（ストライク）ならば以下の処理をせよ。
    shots << 10 # 配列shotsに10点を追加。
  else # X（ストライク）でなければ以下の処理をせよ。
    shots << s.to_i # s（スコア）を整数に変換して配列shotsに追加。
  end # if文の終了。
end # ブロックの終了。

frames = [] # 空の配列となる変数framesを初期化する。この空の配列に各フレームの倒したピンの数を格納する。

# フレーム分割
current_frame = [] # 空の配列となる変数current_frameを初期化する。「今投げたスコア」を一時的に記録するための箱。
shots.each do |shot| # 投球（shot）を1つずつ順番に処理する。
  current_frame << shot # 今の投球を変数current_frame（現在のフレーム）に追加する。
  if current_frame[0] == 10 || current_frame.size == 2 # もし、最初の投球がストライク、または2回投げ終えた場合
    frames << current_frame # 今のフレームを変数frames（全体のフレームのリスト）に追加する。
    current_frame = [] # 次のフレームを準備するために変数current_frameを初期化（箱の中身を空にする）する。
  end # if文の終了
end # ブロックの終了。

# 最後のフレームが分割されていない場合（10フレーム目のボーナス投球）
frames << current_frame unless current_frame.empty? # 変数current_frameにスコアがあるのなら、それを変数framesに追加せよ

point = 0 # スコアの合計を格納する変数pointに初期値0を再入して初期化する。

frames.each_with_index do |frame, i| # 変数framesという配列を順番に取り出し、その要素（変数frame）とその位置を使い繰り返し処理を行う。iは現在のフレームが何番目かを表す番号（インデックス）。
  if i < 10 # もし、フレームの番号iが10未満（10フレーム目まで）であれば以下を実行せよ。
    if frame[0] == 10 # もしも、このフレームの1投目が10点なら、以下の処理を実行せよ。
      point += 10 + (frames[i + 1] || []).take(2).sum # 変数pointに10点を加え、次のフレーム（frames[i + 1]）の最初の2投分のスコアを合計して加える。
      point += frames[i + 2][0] if frames[i + 1] && frames[i + 1].size == 1 && frames[i + 2] # 次のフレーム（frames[i + 1]）が1投しかなく、さらに次の次のフレーム（frames[i + 2]）が存在する場合は、frames[i + 2][0]（次の次のフレームの1頭目のスコア）を変数pointに加える。
    elsif frame.sum == 10 # フレームの2投分の合計が10（スペア）であれば、以下を実行せよ。
      point += 10 + (frames[i + 1] || [])[0].to_i # 変数pointに10点を加えて、次のフレーム（frames[i + 1]）の1投目のスコアを加える。
    else # ストライクでもスペアでもない場合は以下を実行せよ。
      point += frame.sum # 現在のフレームのスコアの合計を変数pointに加える。
    end # if文の終了
  end # if文の終了
end # ブロックの終了

puts point # スコアの合計を表示
```

</details>


------------


## ✍🏻 感想
### 😄😰 動いてめっちゃ嬉しいけど......
るりまサーチ、Rubyリファレンスマニュアル、『プロを目指す人のためのRuby入門』、そして『Rubyコードレシピ集』を参考にして、いろいろなコードを試しながら値を変えてみたりして、ボウリングのスコアを出せるようになりました。とても嬉しいのですが、「コードってこういう作り方で合っているのかな？」「作ったけど、冗長な気がする......」と、納得いかない気持ちの方がとても大きいです。とりあえずちゃんと動くようになったので、次回は作成したコードをリファクタリングします。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 56 min
- Total: 793 hours 04 min
