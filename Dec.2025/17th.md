# 2025/12/17(水)
## 📚 プラクティス『🛠️💻 lsコマンドを作る2』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外にも便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名・メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>

<details><summary>📌 要件（Docs：lsコマンドを作る 参照）</summary>

- [ ] `-a`オプションを付けたとき、`.`で始まる隠しファイルも表示対象にする
- [ ] ⚠️ 注意事項：`..`は表示されなくてもよい
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと
</details>

<details><summary>📍 処理の流れ ※ 随時、追加・変更あり</summary>

**1. オプションの有無を判定**

**2. ファイル一覧取得**

**3. 出力するファイルを選別（隠しファイルを含む or 含まない）**

**4. 表示するための整形**

**5. 1 〜 4 を踏まえた上での出力**
</details>

<details><summary> 🧩 タスクばらし ※ 随時、追加・変更あり</summary>

- [x] タスク1：前提の整理
  - [x] `ls`コマンド、`-a`オプションについて確認

- [ ] タスク2：`-a`オプションを受け取れる状態にする
  - [ ] `OptionParser`を使用して引数を確認する
  - [ ] `-a`オプションを含む処理 / 含まない処理を分けて考える（条件分岐🤔）

- [ ] タスク3：ディレクトリの中身を取得

- [ ] タスク4：隠しファイルの扱いを決める
  - [ ] `-a`オプションが付いているなら`.`から始まるファイルを表示させる
  - [ ] `-a`オプションが付いていないなら隠しファイルは表示させない

- [ ] タスク5：レイアウトの調整
  - [ ] 『lsコマンドを作る1』で作成したレイアウトの処理をそのまま使用🤔
  - [ ] `-a`オプションを使ったときに隠しファイルが表示されるようにする

- [ ] タスク6：rubocop-fjord に通す

- [ ] タスク7：提出
  - [ ] 作成した lsコマンドを Pull Request として提出
  - [ ] 提出物にlsコマンドの実行結果とOS標準（macなど自分の使ってるOS）のlsコマンドをのスクリーンショットを併記して貼る
  - [ ] rubocop-fjord のチェックが全てパスした画面をスクショして添付
</details>


---


## 🧑🏻‍💻 本日の取り組み
### 📚 プラクティス『🛠️💻 lsコマンドを作る2』 
- `ls`コマンド、`-a`オプション、`ARGV`などについて参考URLやテキストで確認
  - [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)
  - [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)


---


## ⏭️ 次回
### 📚 プラクティス『🛠️💻 lsコマンドを作る2』
- `-a`オプションを受け取れる状態にする


---


### 💡 本日の学び・気付き
#### OptionParserクラス
- `OptionParser`クラスを使用すると、`-a`や`--add`といったコマンドラインオプションを扱うことができる。
- `OptionParser`でハンドルすべきオプションは、`on`メソッドで設定する。
  - ↑この一文を噛み砕くと......「コマンドラインから渡されるオプションのうち、自分のプログラムで意味を持たせたいものを、`on`メソッドで受け止めて処理内容を決める」という意味。
  - ハンドル（handle）：この場合の「ハンドル」は、受け取る、解釈する、それに応じた処理を実行する、というニュアンス。分かりやすく言い換えると、「**コマンドラインオプションを受け取り、意味付けして、対応する処理を行うこと**」。
  - 今回のプラクティスの文脈で言えば、`-a`オプションや`-l`オプションをどう解釈して、コード内でどう使うかを決めることが「ハンドル」。

#### オプションをハンドルする
- `OptionParser`を使用して、`-a`オプション、`--add`オプション、`-d`オプション、`--delete`オプションをハンドルする。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-a', '--add', 'add an item') { puts 'Added' }
opt.on('-d', '--del', 'delete an item') { puts 'Deleted' }
opt.parse(ARGV)

# 実行結果
% ruby sample.rb -a
Added

% ruby samle.rb -d
Deleted

% ruby sample.rb -a -d
Added
Deleted
```
① `require 'optparse'`
- Ruby標準ライブラリの`OptionParser`を使えるようにする。
- `-a`や`-r`などのコマンドライン引数を解析するためのツールを読み込んでる。
- つまり、「これからオプションを解析をする準備をする」という宣言。

② `opt = OptionParser.new`
- `OptionParser`クラスのインスタンスを作成し、それを変数`opt`に代入。
- この`opt`が、すべてのオプションを受け止める役になる。

③ `opt.on('-a', '--add', 'add an item') { puts 'Added' }`
- `opt.on(...)`
  - 「このオプションをハンドルする」という宣言。
  - `on`メソッドで、どんなオプションをどう扱うかを決める。
- `-a`
  - 短い形式のオプション（ショートネームオプション）。
- `--add`
  - 長い形式のオプション（ロングネームオプション）。
- `add an item`
  - ヘルプ用の説明文。
- `{ puts 'Added' }`
  - このオプションが指定された時に実行される処理の内容。

④ `opt.on('-d', '--del', 'delete an item') { puts 'Deleted' }`
- これも③と全く同じ構造。
- 違うのは、
  - オプションが`-d` / `--del`。
  - 実行される処理の内容が`puts 'Deleted'`。
  - つまり、`-d`または`--del`が指定されたら『Deleted』と表示する。

⑤`opt.parse(ARGV)`
- `ARGV`
  - コマンドラインから渡された引数の配列。
- `parse`
  - それを1つずつ調べて、`on`で登録したルールに当てはめる。
- 要するに、「**実際に渡されたオプションを解析して、該当する処理を実行せよ**」という**命令**。

#### デフォルトで-hオプションが定義
- `OptionParser`を使用すると、デフォルトで`-h（--help）`オプションが定義され、`on`メソッドの`desc`オプションで指定した説明文が表示される。
```shell
% ruby sample.rb --help
Usage: strings [options]
    -a, --add                        add an item
    -d, --del                        delete an item
```

#### オプションごとにパラメータを受け取れるようにする
- `on`メソッドでオプション名を指定するときに、その後ろにパラメータ名を指定すると、そのオプションにはパラメータ指定が必要であることを示すことができる。
```ruby
require 'optparse'

opt = OptionParser.new
opt.on('-a', '--add ITEM', 'add an item') { |v| puts "Add #{v}" }
opt.on('-d', '--del ITEM', 'delete an item') { |v| puts "Delete #{v}" }
opt.parse(ARGV)

# 実行結果
% ruby sample.rb -a 100
Add 100

% ruby sample.rb --add 200
Add 200

% ruby sample.rb --del=300
Delete 300
```
##### 「パラメータ付きオプション」とは何か？
今までの例は、こうだった。
```ruby
ruby sample.rb -a
```
- `-a`は**あるか/ないか**だけを見ていた。
- **値**は付いていなかった。

今回は、
```ruby
ruby sample.rb -a 100
```
ここでは、
- `-a`だけでは不十分。
- 「**何を add するのか**」という情報が必要。

そして、この`100`が、**オプションに渡されるパラメータ（引数・値）**。
言語化すると、`on`メソッドで`--add ITEM`のように書くと、「**このオプションは、ITEM という値を必ず伴う**」というルールを`OptionParser`に教えている。

##### コードを見てみる
① `opt.on('-a', '--add ITEM', 'add an item') { |v| puts "Add #{v}" }`
- `-a`
  - 短いオプション名（ショートネームオプション）。
- `--add ITEM`
  - 長いオプション名（ロングネームオプション）。
  - `ITEM`が付いている。
    - この`ITEM`が意味するのは、「`--add`オプションには、必ず`ITEM`という値を受け取る」という宣言。
- `{ |v| puts "Add #{v}" }`
  - `|v|`は受け取った値の入れ物。
  - コマンドラインで指定された値が`v`に入る。
つまり、
```ruby
ruby sample.rb -a 100
```
の場合、
```ruby
v = "100"
```
になってから、
```ruby
puts "Add #{v}"
```
が実行される。
だから、
```ruby
Add 100
```
と表示される。

② `ruby sample.rb --add 200`
- `--add ITEM`と定義されている。
- `200`が`ITEM`に対応。それが、`v`に入る。

結果、
```shell
Add 200
```

③ `ruby sample.rb --del=300`
- `--del ITEM`
- `ITEM`に`300`を渡している。

中で起きていることは同じ。
```ruby
v = "300"
puts "Delete #{v}"
```
だから、
```shell
Delete 300
```
になる。

#### 引数は定数ARGVから取れる
```ruby
#!/usr/bin/env ruby
puts ARGV[0]

# 実行結果
% ./arg.rb foo
foo
```
`ARGV`とは、
- Ruby に最初から用意されている定数。
- コマンドライン引数が配列として入っている。

たとえば、
```shell
./arg.rb foo bar
```
なら、
```ruby
ARGV #=> ["foo", "bar"]
```
となる。

`ARGV[0]`の意味
- 配列の **0番目**。
- つまり、最初に渡された引数。
```ruby
ARGV[0] #=> "foo"
```
だから、
```ruby
puts ARGV[0]
```
は、「**最初の引数を表示する**」という処理になる。

#### ARGVとOptionParserの役割の違い
`ARGV`
- ただの配列。
- 渡された順番がそのまま入っている。
- 解釈は自分で書く必要がある。

例：
```ruby
if ARGV[0] == "-a"
# 処理の内容を書く
end
```

`OptionParser`
- オプションの意味付けをしてくれる。
- `-a`や`--add=100`を自動で解析。
- ヘルプを用意してくれる。

#### ショートネームオプションの処理
```ruby
#!/usr/bin/env ruby
require 'optparse'

options = ARGV.getopts('a')
puts options

# 実行結果
% ./arg.rb -a 
{"a"=>true}
```
先ずこのプログラムは、「`-a`というショートネームオプションが指定されたかどうかを調べる」という内容。

① `require 'optparse'`
- `ARGV.getopts`は`optparse`を require すると使える。
- `OptionParser`クラスを直接使わなくても、その機能の一部が使える。

② `options = ARGV.getopts('a')`
`ARGV.getopts`とは？
- `ARGV`（コマンドライン引数の配列）に対して、「このオプションを探せ」と指示するメソッド。

`'a'`とは？
- ショートネームオプション`-a`を探す。
- 引数を取らないオプション。

つまり、
```ruby
ARGV.getopts('a')
```
は、「`ARGV`の中に`-a`があるかどうかを調べろ」という命令になる。

③戻り値`options`
```ruby
options = ARGV.getopts('a')
```
結果として**ハッシュ**を返す。

④実行結果
```shell
% ./arg.rb -a
```
- `ARGV`は`["-a"]`。
- `getopts('a')`が`-a`を見つける。
- `-a`が指定されているので、以下の結果となる。
```ruby
options #=> {"a"=>true}
```


---


## ✍🏻 感想
`-a`オプションの実装に必要な知識を一通り確認しました。
次のタスクとして、`-a`オプションを受け取れる状態にするためのコードを作っていきます。
あまり深く考えすぎず、分からない箇所が出てきたら、その都度立ち止まって確認し直すスタンスで進める予定です。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 hours 37 min
- Total: 1444 hours 18 min
