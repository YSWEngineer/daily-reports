# 2025/02/17(月)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.3 クラスの定義


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.4 例題：改札機プログラムの作成


------------


## 💡 本日の学び・気付き
### 7.3 クラスの定義
Ruby のクラスを定義する場合は次のような構文を使う。
```ruby
class クラス名
end
```
クラス名は必ず**大文字**で始める。**小文字で始めると構文エラー**になる。慣習として、`User`や`OrderItem`のようにキャメルケースで書くのが一般的。
```ruby
# Userクラスの定義
class User
end

# OrderItemクラスの定義
class OrderItem
end
```

#### オブジェクトの作成と initializeメソッド
クラスからオブジェクトを作成する場合は newメソッドを使う。
```ruby
User.new
```
このときに呼ばれるのが initializeメソッド。インスタンスを初期化するために実行したい処理があれば、この initializeメソッドでその処理を実装する（特に必要がなければ定義しなくてもよい）。次のようにすると、newメソッドを呼び出したときに、initializeメソッドが呼ばれていることがわかる。
```ruby
irb(main):062* class User
irb(main):063*   def initialize
irb(main):064*     puts 'Initialized.'
irb(main):065*   end
irb(main):066> end
irb(main):067> User.new
Initialized.
```
initializeメソッドは特殊なメソッドで、デフォルトで privateメソッドになっているため**外部から呼び出すことはできない**。
```ruby
irb(main):009> user = User.new
irb(main):010> user.initialize
Initialized.
(irb):10:in `<main>': private method `initialize' called for an instance of User (NoMethodError)
```
initializeメソッドに引数を付けると、newメソッドを呼ぶときにも引数が必要になる。
```ruby
irb(main):011* class User
irb(main):012*   def initialize(name, age)
irb(main):013*     puts "name: #{name}, age: #{age}"
irb(main):014*   end
irb(main):015> end
irb(main):016> User.new
(irb):12:in `initialize': wrong number of arguments (given 0, expected 2) (ArgumentError)
irb(main):017> User.new('Alice', 20)
name: Alice, age: 20
```

#### インスタンスメソッドの定義
クラス構文の内部で以下のようにメソッドを定義すると、そのメソッドは**インスタンスメソッド**になる。インスタンスメソッドは、**そのクラスのインスタンスに対して呼び出すことができるメソッド**。
```ruby
irb(main):001* class User
# インスタンスメソッドの定義
irb(main):002*   def hello
irb(main):003*     "Hello!"
irb(main):004*   end
irb(main):005> end
=> :hello
irb(main):006> user = User.new
=> #<User:0x00000001261390a8>
# インスタンスメソッドの呼び出し
irb(main):007> user.hello
=> "Hello!"
```

#### インスタンス変数とアクセサメソッド
クラスの内部ではインスタンス変数を使うことができる。インスタンス変数は同じインスタンス（同じオブジェクト）の内部で共有される変数のこと。Ruby では`@`で始まる変数がインスタンス変数になる。
```ruby
irb(main):008* class User
irb(main):009*   def initialize(name)
# インスタンス作成時に渡された名前をインスタンス変数に保存する
irb(main):010*     @name = name
irb(main):011*   end
irb(main):012*   def hello
# インスタンス変数に保存されている名前を表示する
irb(main):013*     "Hello, I am #{@name}."
irb(main):014*   end
irb(main):015> end
=> :hello
irb(main):016> user = User.new('Alice')
irb(main):017> user.hello
=> "Hello, I am Alice."
```
`@`、`@@`、`$`といったプレフィックス（接頭辞）が付かない変数は**ローカル変数**になる。`@@`は**クラス変数**の、`$`は**グローバル変数**のプレフィックス。また、アルファベットの大文字で始まる識別子は**定数**とみなされる。

メソッドやブロックの内部で宣言（代入）されたローカル変数のスコープ（有効範囲）はその**変数が宣言された位置から、自身が宣言されたメソッド又はブロックの終わりまで**。メソッドやブロックが繰り返し呼ばれると、その都度新しいローカル変数が作られる。以下はローカル変数の使用例。
```ruby
irb(main):018* class User
irb(main):019*   def initialize(name)
irb(main):020*     @name = name
irb(main):021*   end
irb(main):022* 
irb(main):023*   def hello
# shuffled_nameはローカル変数
irb(main):024*     shuffled_name = @name.chars.shuffle.join
irb(main):025*     "Hello, I am #{shuffled_name}."
irb(main):026*   end
irb(main):027> end
=> :hello
irb(main):028> user = User.new('Alice')
irb(main):029> user.hello
=> "Hello, I am celAi."
```
ローカル変数は参照する前に必ず`=`で値を代入して作成する必要がある。まだ作成されていないローカル変数を参照するとエラーが発生する。
```ruby
irb(main):030* class User
irb(main):031*   def initialize(name)
irb(main):032*     @name = name
irb(main):033*   end
irb(main):034* 
irb(main):035*   def hello
# わざとローカル変数への代入をコメントアウトする
irb(main):036*     # shuffled_name = @name.chars.shufffle.join
irb(main):037*     "Hello, I am #{shuffled_name}."
irb(main):038*   end
irb(main):039> end
=> :hello
irb(main):040> user = User.new('Alice')
# いきなりshuffled_nameを参照したためエラーになる
irb(main):041> user.hello
(irb):37:in `hello': undefined local variable or method `shuffled_name' for an instance of User (NameError)
```
一方、インスタンス変数は作成（値を代入）する前にいきなり参照してもエラーにはならない。まだ作成されていないインスタンス変数を参照した場合は nil が返る。
```ruby
irb(main):042* class User
irb(main):043*   def initialize(name)
# わざとインスタンス変数への代入をコメントアウトする
irb(main):044*     # @name = name
irb(main):045*   end
irb(main):046*   def hello
irb(main):047*     "Hello, I am #{@name}."
irb(main):048*   end
irb(main):049> end
=> :hello
irb(main):050> user = User.new('Alice')
# @nameを参照するとnilになる（名前の部分に何も出ない）
irb(main):051> user.hello
=> "Hello, I am ."
```
このため、インスタンス変数名をうっかりタイプミスすると、不具合の原因になる。
```ruby
irb(main):052* class User
irb(main):053*   def initialize(name)
irb(main):054*     @name = name
irb(main):055*   end
irb(main):056*   def hello
# 間違えて@nameを@mameと書いた（@mameはnilを返す）
irb(main):057*     "Hello, I am #{@mame}."
irb(main):058*   end
irb(main):059> end
=> :hello
irb(main):060> user = User.new('Alice')
# タイプミスによって、Aliceが表示されない
irb(main):061> user.hello
=> "Hello, I am ."
```
インスタンス変数はクラスの外部から参照することができない。もし参照したい場合は参照用のメソッド作る必要がある。
```ruby
irb(main):062* class User
irb(main):063*   def initialize(name)
irb(main):064*     @name = name
irb(main):065*   end
# @nameを外部から参照するためのメソッド
irb(main):066*   def name
irb(main):067*     @name
irb(main):068*   end
irb(main):069> end
=> :name
irb(main):070> user = User.new('Alice')
# nameメソッドを経由して@nameの内容を取得する
irb(main):071> user.name
=> "Alice"
```
インスタンス変数の内容を外部から変更したい場合も変更用のメソッドを定義する。Ruby は`=`で終わるメソッドを定義すると、変数に代入するような形式でそのメソッドを呼び出すことができる。
```ruby
irb(main):072* class User
irb(main):073*   def initialize(name)
irb(main):074*     @name = name
irb(main):075*   end
# @nameを外部から参照するためのメソッド
irb(main):076*   def name
irb(main):077*     @name
irb(main):078*   end
# @nameを外部から変更するためのメソッド
irb(main):079*   def name=(value)
irb(main):080*     @name = value
irb(main):081*   end
irb(main):082> end
=> :name=
irb(main):083> user = User.new('Alice')
=> #<User:0x00000001267b35a0 @name="Alice">
# 変数に代入しているように見えるが、実際はname=メソッドを呼び出している
irb(main):084> user.name = 'Bob'
irb(main):085> user.name
=> "Bob"
```
`name`メソッドのように**値を読み出すメソッド**を「**ゲッターメソッド**」、`name=`メソッドのように**値を書き込むメソッド**を「**セッターメソッド**」と呼ぶ。また、ゲッターメソッドとセッターメソッドを総称して、「**アクセサメソッド**」と呼ぶ。

Ruby の場合、単純にインスタンス変数の内容を外部から読み書きするのであれば、`attr_accessor`というメソッドを使い退屈なアクセスメソッドの定義を省略することができる。attr_accessorメソッドを使うと、上記のコードは次のように書き換えられる。
```ruby
irb(main):086* class User
# @nameを読み書きするメソッドが自動的に定義される
irb(main):087*   attr_accessor :name
irb(main):088*   def initialize(name)
irb(main):089*     @name = name
irb(main):090*   end
# nameメソッドやname=メソッドを明示的に定義する必要がない
irb(main):091> end
=> :initialize
irb(main):092> user = User.new('Alice')
=> #<User:0x0000000126298ca0 @name="Alice"> 
# @nameを変更する
irb(main):093> user.name = 'Bob'
# @nameを参照する
irb(main):094> user.name
=> "Bob"
```
インスタンス変数の内容を読み取り専用にしたい場合は attr_accessor の代わりに attr_readerメソッドを使う。
```ruby
irb(main):001* class User
# 読み取り用のメソッドだけを定義する
irb(main):002*   attr_reader :name
irb(main):003*   def initialize(name)
irb(main):004*     @name = name
irb(main):005*   end
irb(main):006> end
=> :initialize
irb(main):007> user = User.new('Alice')
=> #<User:0x0000000123bfa350 @name="Alice">
# @nameの参照はできる
irb(main):008> user.name
=> "Alice"
# @nameを変更しようとするとエラーになる
irb(main):009> user.name = 'Bob'
(irb):9:in `<main>': undefined method `name=' for an instance of User (NoMethodError)
```
逆に書き込み専用にしたい場合は attr_writer を使う。
```ruby
irb(main):001* class User
# 書き込み用のメソッドだけを定義する
irb(main):002*   attr_writer :name
irb(main):003*   def initialize(name)
irb(main):004*     @name = name
irb(main):005*   end
irb(main):006> end
=> :initialize
irb(main):007> user = User.new('Alice')
=> #<User:0x0000000128b337c8 @name="Alice">
# @nameは変更できる
irb(main):008> user.name = 'Bob'
# @nameの参照はできない
irb(main):009> user.name
(irb):9:in `<main>': undefined method `name' for an instance of User (NoMethodError)
```
カンマで複数の引数を渡すと、複数のインスタンス変数に対するアクセサメソッドを定義することもできる。
```ruby
irb(main):001* class User
# @nameと@ageへのアクセサメソッドを定義する
irb(main):002*   attr_accessor :name, :age
irb(main):003*   def initialize(name, age)
irb(main):004*     @name = name
irb(main):005*     @age = age
irb(main):006*   end
irb(main):007> end
=> :initialize
irb(main):008> user = User.new('Alice', 20)
=> #<User:0x0000000124f2f8f8 @age=20, @name="Alice">
irb(main):009> user.name
=> "Alice"
irb(main):010> user.age = 30
=> 30
```

#### クラスメソッドの定義
クラス構文の内部で単純にメソッドを定義すると、そのメソッドはインスタンスメソッドになる。インスタンスメソッドはそのクラスのインスタンスに対して呼び出すことができるメソッドであり、インスタンスに含まれるデータ（インスタンス変数）を読み書きする場合はインスタンスメソッドを定義する。
```ruby
irb(main):001* class User
irb(main):002*   def initialize(name)
irb(main):003*     @name = name
irb(main):004*   end
# これはインスタンスメソッド
irb(main):005*   def hello
# @nameの値はインスタンスによって異なる
irb(main):006*     "Hello, I am #{@name}."
irb(main):007*   end
irb(main):008> end
=> :hello
irb(main):009> alice = User.new('Alice')
# インスタンスメソッドはインスタンス（オブジェクト）に対して呼び出す
irb(main):010> alice.hello
=> "Hello, I am Alice."
irb(main):011> bob = User.new('Bob')
# インスタンスによって内部のデータが異なるため、helloメソッドの結果も異なる
irb(main):012> bob.hello
=> "Hello, I am Bob."
```
ひとつひとつのインスタンスに含まれるデータは使わないメソッドを定義したい場合は、クラスメソッドを定義した方が使い勝手が良くなる。クラスメソッドを定義する方法の1つは、メソッド名の前に`self.`を付けること。
```ruby
# クラスメソッドを定義する方法 その1
class クラス名
  def self.クラスメソッド
    # クラスメソッドの処理
  end
end
```
もうひとつは`class << self`から`end`の間にメソッドを書く方法。
```ruby
# クラスメソッドを定義する方法 その2
class クラス名
  class << self
    def クラスメソッド
      # クラスメソッドの処理
    end
  end
end
```
クラスメソッドを呼び出す場合は以下のように、クラス名の直後にドット（`.`）を付けてメソッドを呼び出す。
```ruby
クラス名.メソッド名
```
例として Userクラスにクラスメソッドを追加してみる。
```ruby
irb(main):001* class User
irb(main):002*   def initialize(name)
irb(main):003*     @name = name
irb(main):004*   end
# self.を付けるとクラスメソッドになる
irb(main):005*   def self.create_users(names)
irb(main):006*     names.map do |name|
irb(main):007*       User.new(name)
irb(main):008*     end
irb(main):009*   end
# これはインスタンスメソッド
irb(main):010*   def hello
irb(main):011*     "Hello, I am #{@name}."
irb(main):012*   end
irb(main):013> end
=> :hello
irb(main):014> names = ['Alice', 'Bob', 'Carol']
=> ["Alice", "Bob", "Carol"]
# クラスメソッドの呼び出し
irb(main):015> users = User.create_users(names)
=> [#<User:0x000000012a7a6f68 @name="Alice">, #<User:0x000000012a7a6ec8 @name="Bob">, #<User:0x000000012a7a6ea0 @name="Car...
irb(main):016* users.each do |user|
# インスタンスメソッドの呼び出し
irb(main):017*   puts user.hello
irb(main):018> end
Hello, I am Alice.
Hello, I am Bob.
Hello, I am Carol.
=> [#<User:0x000000012a7a6f68 @name="Alice">, #<User:0x000000012a7a6ec8 @name="Bob">, #<User:0x000000012a7a6ea0 @name="Carol">]
```

#### 定数
クラスの中には定数を定義することもできる。
```ruby
irb(main):001* class Product
# デフォルトの価格を定数として定義する
irb(main):002*   DEFAULT_PRICE = 0
irb(main):003*   attr_reader :name, :price
# 第2引数priceのデフォルト値を定数DEFAULT_PRICE（つまり0）とする
irb(main):004*   def initialize(name, price = DEFAULT_PRICE)
irb(main):005*     @name = name
irb(main):006*     @price = price
irb(main):007*   end
irb(main):008> end
=> :initialize
irb(main):009> product = Product.new('A free movie')
irb(main):010> product.price
=> 0
```
定数は必ず**大文字**で始める必要がある。慣習的に**アルファベットの大文字と数字、アンダースコア**で構成されることが多い。
```ruby
# 定数名の例
DEFAULT_PRICE = 0 
UNITS = { m: 1.0, ft: 3.28, in: 39.37 }
```
定数はインスタンスメソッド内でもクラスメソッド内でも同じ方法で参照することができる。
```ruby
irb(main):001* class Product
irb(main):002*   DEFAULT_PRICE = 0
irb(main):003*   def self.default_price
# クラスメソッドから定数を参照する
irb(main):004*     DEFAULT_PRICE
irb(main):005*   end
irb(main):006*   def default_price
# インスタンスメソッドから定数を参照する
irb(main):007*     DEFAULT_PRICE
irb(main):008*   end
irb(main):009> end
irb(main):010> Product.default_price
=> 0
irb(main):011> product = Product.new
irb(main):012> product.default_price
=> 0
```



-------------


## ✍🏻 感想
### 🤔 クラス定義の奥深さを知る
Ruby のクラス定義が奥深さに少し混乱しています。複雑に感じるので、
1. 一度に全部覚えようとしない
2. 小さなプログラムを書く
3. 手を動かして慣れる

以上の点を踏まえて、一つひとつ理解していきたいと思います。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 55 min
- Total: 944 hours 17 min
