# 2025/02/19(水)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.5 selfキーワード
    - 7.6 クラスの継承 途中まで


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.6 クラスの継承 途中から


------------


## 💡 本日の学び・気付き
### 7.5 selfキーワード
Ruby にはインスタンス自身を表す selfキーワードがある。メソッドの内部で他のメソッドを呼び出す場合は暗黙的に self に対してメソッドを呼び出している。以下は self なしで nameメソッドを呼び出す場合と、self 付きで呼び出す場合、直接インスタンス変数を参照する場合の3パターンで @name の内容を参照してみる。
```ruby
irb(main):004*   def initialize(name)
irb(main):005*     @name = name
irb(main):006*   end
irb(main):007* 
irb(main):008*   def hello
# selfなしでnameメソッドを呼ぶ
irb(main):009*     "Hello, I am #{name}."
irb(main):010*   end
irb(main):011* 
irb(main):012*   def hi
# self付きでnameメソッドを呼ぶ
irb(main):013*     "Hi, I am #{self.name}."
irb(main):014*   end
irb(main):015* 
irb(main):016*   def my_name
# 直接インスタンス変数の@nameにアクセスする
irb(main):017*     "My name is #{@name}."
irb(main):018*   end
=> :my_name
irb(main):020> user = User.new('Alice')
irb(main):021> user.hello
=> "Hello, I am Alice."
irb(main):022> user.hi
=> "Hi, I am Alice."
irb(main):023> user.my_name
=> "My name is Alice."
```
↑name も self.name も @name も同じ文字列 "Alice" を返すので、「これが正解」と1つを選ぶことはできない。人によって書き方が異なる。

#### self の付け忘れで不具合が発生するケース
```ruby
irb(main):001* class User= name
irb(main):002*   attr_accessor :name
irb(main):003* 
irb(main):004*   def initialize(name)
irb(main):005*     @name = name
irb(main):006*   end
irb(main):007* 
irb(main):008*   def rename_to_bob
# selfなしでname=メソッドを呼ぶ（？）
irb(main):009*     name = 'Bob'
irb(main):010*   end
irb(main):011* 
irb(main):012*   def rename_to_carol
# self付きでname=メソッドを呼ぶ
irb(main):013*     self.name = 'Carol'
irb(main):014*   end
irb(main):015* 
irb(main):016*   def rename_to_dave
# 直接インスタンス変数を書き換える
irb(main):017*     @name = 'Dave'
irb(main):018*   end
irb(main):019> end
irb(main):020> user = User.new('Alice')
=> #<User:0x000000011d5424c8 @name="Alice">

# Bobにリネームできていない
irb(main):021> user.rename_to_bob
irb(main):022> user.name
=> "Alice"

# Carolにリネーム
irb(main):023> user.rename_to_carol
irb(main):024> user.name
=> "Carol"

# Daveにリネーム
irb(main):025> user.rename_to_dave
irb(main):026> user.name
=> "Dave"
```
`name=`のようなセッターメソッドを呼び出したい場合は、必ず`self`を付ける必要がある。`self.name = 'Bob'`のように書けば、ローカル変数の代入とは構文が異なるため確実に`name=`メソッドを呼び出すことができる。
```ruby
def rename_to_bob
  # メソッド内でセッターメソッドを呼び出す場合はselfを必ず付ける
  self.name = 'Bob'
end
```

#### クラスメソッドの内部やクラス構文直下の self
クラス定義内に登場する self は場所によって「**そのクラスのインスタンス自身**」を表したり、「**クラス自身**」を表したりする。
```ruby
irb(main):001* class Foo
# 注：このputsはクラス定義の読み込み時に呼び出される
irb(main):002*   puts "クラス構文の直下のself: #{self}"
irb(main):003* 
irb(main):004*   def self.bar
irb(main):005*     puts "クラスメソッド内のself: #{self}"
irb(main):006*   end
irb(main):007* 
irb(main):008*   def baz
irb(main):009*     puts "インスタンスメソッド内のself: #{self}"
irb(main):010*   end
irb(main):011> end
クラス構文の直下のself: Foo
=> :baz
irb(main):012> Foo.bar
クラスメソッド内のself: Foo
=> nil
irb(main):013> foo = Foo.new
=> #<Foo:0x0000000104e23da8>
irb(main):014> foo.baz
インスタンスメソッド内のself: #<Foo:0x0000000104e23da8>
=> nil
```
クラス構文の直下とクラスメソッド内での self は Foo と表示されている。この Foo は「Fooクラス自身」を表している。インスタンスメソッド内での self は`#<Foo:0x0000000104e23da8>`と表示されている。これは「Fooクラスのインスタンス」を表している。

よって、次のようなコードはエラーになる。
```ruby
irb(main):001* class Foo
irb(main):002*   def self.bar
# クラスメソッドからインスタンスメソッドのbazを呼び出す？
irb(main):003*     self.baz
irb(main):004*   end
irb(main):005* 
irb(main):006*   def baz
# インスタンスメソッドからクラスメソッドのbarを呼び出す？
irb(main):007*     self.bar
irb(main):008*   end
irb(main):009> end
# selfが異なるためクラスメソッドのbarからはインスタンスメソッドのbazは呼び出せない
irb(main):010> Foo.bar
(irb):3:in `bar': undefined method `baz' for class Foo (NoMethodError)
# selfが異なるためインスタンスメソッドのbazからはクラスメソッドのbarは呼び出せない
irb(main):011> foo = Foo.new
=> #<Foo:0x0000000100c1c810>
irb(main):012> foo.baz
(irb):7:in `baz': undefined method `bar' for an instance of Foo (NoMethodError)
```
クラス構文の直下ではクラスメソッドを呼び出すことができる。self がどちらも「クラス自身」になるから。ただし、この場合でもクラスメソッドを定義したあと、つまりクラスメソッドの定義よりも下側でクラスメソッドを呼び出す必要がある。
```ruby
irb(main):001* class Foo
# この時点ではクラスメソッドbarが定義されていないので呼び出せない
# （NoMethodErrorが発生する）
# self.bar
irb(main):002*   def self.bar
irb(main):003*     puts 'hello'
irb(main):004*   end
irb(main):005* 
# クラス構文の直下でクラスメソッドを呼び出す
# （クラスメソッドbarが定義されたあとなので呼び出せる）
irb(main):006*   self.bar
irb(main):007> end
hello
```

#### クラスメソッドをインスタンスメソッドで呼び出す
クラスメソッドをインスタンスメソッドの内部から呼び出す場合は、次のように書く。
```ruby
クラス名.メソッド名
```
インスタンスメソッドからクラスメソッドを呼び出すコード例。
```ruby
irb(main):001* class Product
irb(main):002*   
irb(main):002*   attr_reader :name, :price
irb(main):003* 
irb(main):004*   def initialize(name, price)
irb(main):005*     @name = name
irb(main):006*     @price = price
irb(main):007*   end
irb(main):008* 
# 金額を整形するクラスメソッド
irb(main):009*   def self.format_price(price)
irb(main):010*     "#{price}円"
irb(main):011*   end
irb(main):012* 
irb(main):013*   def to_s
# インスタンスメソッドからクラスメソッドを呼び出す
irb(main):014*     formatted_price = Product.format_price(price)
irb(main):015*     "name: #{name}, price: #{formatted_price}"
irb(main):016*   end
=> :to_s
irb(main):018> 
irb(main):019> product = Product.new('A great movie', 1000)
irb(main):020> product.to_s
=> "name: A great movie, price: 1000円"
```

### 7.6 クラスの継承
たとえば、DVDクラスが Productクラスを継承するとき、Productクラスのことを DVDクラスの「**スーパークラス**（または**親クラス**）」と呼ぶ。逆に Productクラスから見ると、DVDクラスは Productクラスの「**サブクラス**（または**子クラス**）」と呼ぶ。

クラスの継承関係を図解するときは、**クラス図**と呼ばれる図がよく使われる。クラス図は多くの場合、スーパークラスを上に、サブクラスを下に配置し、サブクラスからスーパークラスへ向かって矢印を伸ばすことで、サブクラスがスーパークラスを継承していることを表す。

継承を使いたいと思ったときは、**性質や概念の共通点に着目**すること。性質や概念が共通しているかどうか（つまりクラスの継承が適切かどうか）を判断する方法の1つは、

- 「**サブクラスはスーパークラスの一種である（サブクラス is a スーパークラス）**」

と、声に出して読んだときに違和感がないか確かめること。これは「**is-a の関係**」と呼ばれる。たとえば販売管理を行うシステムで、商品クラスがスーパークラス、DVDクラスがサブクラスだった場合、

- 「**DVD は商品の一種である（DVD is a product）**」

と、声に出して読んでも違和感がない。こういうケースは適切な継承関係である可能性が高い。

また、サブクラスはスーパークラスの性質を**特化**したもので、反対にスーパークラスはサブクラスの性質を**汎化**したもの、という関係が成り立つ。
- **特化**：性質がより細かく具体的になること。
- **汎化**：性質がより大雑把に抽象化されること。

たとえば DVD と商品を比較した場合、DVD のほうが単に「商品」と読んだときよりも性質や概念が具体的になっている。逆に商品は DVD に比べると中身が曖昧。つまり、商品は DVD よりも抽象的な概念になっている。これが特化と汎化の関係。

#### 標準ライブラリの継承関係
Ruby の継承は**単一継承**。つまり、継承できるスーパークラス（親クラス）1つだけ。

標準ライブラリの継承関係において、継承関係の頂点にいるのは BasicObjectクラス。それを Objectクラスが継承している。Stringクラスや Arrayクラスといった代表的なクラスは、すべて Objectクラスを継承している。このことから Stringクラスや Arrayクラスは、Objectクラスと is-a の関係にある、つまり String は Object の一種で、Array も Object の一種と言える。

#### デフォルトで継承される Objectクラス
継承元を指定せずに作成したクラスはデフォルトで Objectクラスを継承している。たとえば、中身を全く描かないクラスを作成したとする。
```ruby
class User
end
```
Userクラスにはメソッドを定義していないが、Userクラスのオブジェクトは to_sメソッドや nil?メソッドを呼び出すことができる。
```ruby
irb(main):001* class User
irb(main):002> end
irb(main):003> user = User.new
=> #<User:0x000000012049ce80>
irb(main):004> user.to_s
=> "#<User:0x000000012049ce80>"
irb(main):005> user.nil?
=> false
```
これは Userクラスが Objectクラスを継承しているため。
```ruby
irb(main):006> User.superclass
=> Object
```
次のようにすると Objectクラスから継承したメソッドの一覧を確認できる。
```ruby
irb(main):007> user = User.new
irb(main):008> user.methods.sort
=> 
[:!,
 :!=,
 :!~,
 :<=>,
 :==,
 :===,
 :__id__,
 :__send__,
 :class,
 :clone,
 :define_singleton_method,
 :display,
 :dup,
 :enum_for,
 :eql?,
 :equal?,
 :extend,
 :freeze,
 :frozen?,
 :hash,
 :inspect,
 :instance_eval,
 :instance_exec,
 :instance_of?,
 :instance_variable_defined?,
 :instance_variable_get,
 :instance_variable_set,
 :instance_variables,
 :is_a?,
 :itself,
 :kind_of?,
 :method,
 :methods,
 :nil?,
 :object_id,
 :pretty_inspect,
 :pretty_print,
 :pretty_print_cycle,
 :pretty_print_inspect,
 :pretty_print_instance_variables,
 :private_methods,
 :protected_methods,
 :public_method,
 :public_methods,
 :public_send,
 :remove_instance_variable,
 :respond_to?,
 :send,
 :singleton_class,
 :singleton_method,
 :singleton_methods,
 :tap,
 :then,
 :to_enum,
 :to_s,
 :yield_self]
```

#### オブジェクトのクラスを確認する
オブジェクトのクラスを調べる場合は classメソッドを使う。
```ruby
irb(main):001* class User
irb(main):002> end
=> nil
irb(main):003> user = User.new
irb(main):004> user.class
=> User
```
instance_of?メソッドを使って調べることもできる。
```ruby
irb(main):005> user = User.new
# userはUserクラスのインスタンスか？
irb(main):006> user.instance_of?(User)
=> true
# userはStringクラスのインスタンスか？
irb(main):007> user.instance_of?(String)
=> false
```
継承関係（is-a関係にあるかどうか）を含めて確認したい場合は is_a?メソッド（エイリアスメソッドは kind_of?）を使う。
```ruby
irb(main):008> user = User.new
# instance_of?は引数で指定したクラスそのもののインスタンスでないとtrueにならない
irb(main):009> user.instance_of?(Object)
=> false
# is_a?はis-a関係にあればtrueになる
irb(main):010> user.is_a?(User)
=> true
irb(main):011> user.is_a?(Object)
=> true
irb(main):012> user.is_a?(BasicObject)
=> true
# is-a関係にない場合はfalse
irb(main):013> user.is_a?(String)
=> false
```

#### 他のクラスを継承したクラスを作る
独自のクラスを定義する際は Objectクラス以外のクラスを継承することもできる。先程の Product と DVD を例にする。
```ruby
class Product
end
```
DVDクラスは Productクラスを継承する必要がある。Objectクラス以外のクラスを継承する場合は次のような構文を使う。
```ruby
class サブクラス < スーパークラス
end
```
よって、DVDクラスは次のように定義する。
```ruby
# DVDクラスはProductクラスを継承する
class DVD < Product
end
```


-------------


## ✍🏻 感想
### 🤔 selfキーワード
Ruby においてオブジェクト自身を表す selfキーワードは、コードを書く場所や状況によって self が指すものが変わることを知りました。さまざまな書き方を理解することで、Ruby のオブジェクト指向の仕組みがより深く理解できると思います。焦らずに、実際のコードを書きながらゆっくりと慣れていきます。

------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 4 hours 50 min
- Total: 951 hours 11 min
