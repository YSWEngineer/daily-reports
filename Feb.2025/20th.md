# 2025/02/20(木)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.6 クラスの継承


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.7 メソッドの可視性


------------


## 💡 本日の学び・気付き
### 7.6 クラスの継承
#### super でスーパークラスのメソッドを呼び出す
Productクラスと DVDクラスに属性を追加してみる。Productクラスは商品名（name）と価格（price）という属性を持つことにする。
```ruby
irb(main):001* class Product
irb(main):002*   attr_reader :name, :price
irb(main):003*   def initialize(name, price)
irb(main):004*     @name = name
irb(main):005*     @price = price
irb(main):006*   end
irb(main):007> end
=> :initialize
irb(main):008> product = Product.new('A great movie', 1000)
irb(main):009> product.name
=> "A great movie"
irb(main):010> product.price
=> 1000
```
DVDクラスはこれらに加えて再生時間（running_time）を持つことにする。initializeメソッドでも引数を3つ受け取るようにしておく。またインスタンス変数への代入も実行する。
```ruby
irb(main):011* class DVD < Product
# nameとpriceはスーパークラスでattr_readerが設定されているので定義不要
irb(main):012*   attr_reader :running_time
irb(main):013* 
irb(main):014*   def initialize(name, price, running_time)
# スーパークラスにも存在している属性
irb(main):015*     @name = name
irb(main):016*     @price = price
# DVDクラス独自の属性
irb(main):017*     @running_time = running_time
irb(main):018*   end
irb(main):019> end
=> :initialize
irb(main):020> dvd = DVD.new('A great movie', 1000, 120)
irb(main):021> dvd.name
=> "A great movie"
irb(main):022> dvd.price
=> 1000
irb(main):023> dvd.running_time
=> 120
```
しかし、name と price については、スーパークラスの initializeメソッドでも同じように値を代入しているので、同じ処理を繰り返し書くよりもスーパークラスの処理を呼んだほうがシンプル。こういう場合は super を使うとスーパークラスの同名メソッドを呼び出すことができる。
```ruby
irb(main):024* class DVD < Product
irb(main):025*   attr_reader :running_time
irb(main):026* 
irb(main):027*   def initialize(name, price, running_time)
# スーパークラスのinitializeメソッドを呼び出す
irb(main):028*     super(name, price)
irb(main):029*     @running_time = running_time
irb(main):030*   end
irb(main):031> end
=> :initialize
irb(main):032> dvd = DVD.new('A great movie', 1000, 120)
irb(main):033> dvd.name
=> "A great movie"
irb(main):034> dvd.price
=> 1000
irb(main):035> dvd.running_time
=> 120
```
スーパークラスとサブクラスで引数の数が同じ場合は、引数なしの super を呼ぶだけで自分に渡された引数をすべてスーパークラスに引き渡すことができる。
```ruby
irb(main):036* class DVD < Product
irb(main):037*   def initialize(name, price)
# 引数を全てスーパークラスのメソッドに渡す。つまりsuper(name, price)と書いたのと同じ
irb(main):038*     super
# サブクラスで必要な初期化処理を書く
irb(main):039*   end
irb(main):040> end
=> :initialize
irb(main):041> dvd = DVD.new('A great movie', 1000)
irb(main):042> dvd.name
=> "A great movie"
irb(main):043> dvd.price
=> 1000
```
ただし、`super()`と書いた場合は「引数0個でスーパークラスの同名メソッドを呼び出す」という意味になるので注意。
```ruby
irb(main):044* class DVD < Product
irb(main):045*   def initialize(name, price)
# super()だと引数なしでスーパークラスのメソッドを呼び出す
# （ただし数が合わないためこのコードはエラーになる）
irb(main):046*     super()
irb(main):047*   end
irb(main):048> end
# スーパークラスのinitializeメソッドを引数0個で呼び出そうとするためエラーになる
irb(main):049> dvd = DVD.new('A great movie', 1000)
(irb):3:in `initialize': wrong number of arguments (given 0, expected 2) (ArgumentError)
```
そもそもスーパークラスとサブクラスで実行する処理が変わらなければ、サブクラスで同名メソッドを定義したり super を呼んだりする必要はない。
```ruby
irb(main):032* class DVD < Product
# サブクラスで特別な処理をしないなら、同名メソッドを定義する必要はない
# （スーパークラスに処理を任せる）
# def initialize(name, price)
#   super
# end
irb(main):033> end
=> nil
irb(main):034> dvd = DVD.new('A great movie', 1000)
=> #<DVD:0x00000001262f7b88 @name="A great movie", @price=1000>
irb(main):035> dvd.name
=> "A great movie"
irb(main):036> dvd.price
=> 1000
```

#### メソッドのオーバーライド
サブクラスではスーパークラスと同名のメソッドを定義することで、スーパークラスの処理を上書きすることができる。これを**メソッドのオーバーライド**（override）と言う。
```ruby
irb(main):001* class Product
irb(main):002*   attr_reader :name, :price
irb(main):003*   def initialize(name, price)
irb(main):004*     @name = name
irb(main):005*     @price = price
irb(main):006*   end
irb(main):007> end
=> :initialize
irb(main):008> 
irb(main):009* class DVD < Product
irb(main):010*   attr_reader :running_time
irb(main):011*   def initialize(name, price, running_time)
irb(main):012*     super(name, price)
irb(main):013*     @running_time = running_time
irb(main):014*   end
irb(main):015> end
=> :initialize
irb(main):016> 
irb(main):017> product = Product.new('A great movie', 1000)
irb(main):018> product.to_s
=> "#<Product:0x000000010b384788>"
irb(main):019> dvd = DVD.new('An awesome film', 3000, 120)
irb(main):020> dvd.to_s
=> "#<DVD:0x0000000126429e70>"
```
もう少しわかりやすい文字列が返ってくるように、Productクラスで to_sメソッドをオーバーライドしてみる。
```ruby
irb(main):022* class Product
irb(main):023*   attr_reader :name, :price
irb(main):024*   def initialize(name, price)
irb(main):025*     @name = name
irb(main):026*     @price = price
irb(main):027*   end
irb(main):028* 
# to_sメソッドをオーバーライド
irb(main):029*   def to_s
irb(main):030*     "name: #{name}, price: #{price}"
irb(main):031*   end
irb(main):032> end
=> :to_s
irb(main):033> 
irb(main):034> product = Product.new('A great movie', 1000)
irb(main):035> product.to_s
=> "name: A great movie, price: 1000"
irb(main):036> dvd = DVD.new('An awesome film', 3000, 120)
irb(main):037> dvd.to_s
=> "name: An awesome film, price: 3000"
```
DVDクラスでも to_sメソッドをオーバーライドする。
```ruby
irb(main):038* class Product
irb(main):039*   attr_reader :name, :price
irb(main):040*   def initialize(name, price)
irb(main):041*     @name = name
irb(main):042*     @price = price
irb(main):043*   end
irb(main):044* 
irb(main):045*   def to_s
irb(main):046*     "name: #{name}, price: #{price}"
irb(main):047*   end
irb(main):048> end
=> :to_s
irb(main):049> 
irb(main):050* class DVD < Product
irb(main):051*   attr_reader :running_time
irb(main):052*   def initialize(name, price, running_time)
irb(main):053*     super(name, price)
irb(main):054*     @running_time = running_time
irb(main):055*   end
irb(main):056* 
# DVDクラスでto_sメソッドをオーバーライド
irb(main):057*   def to_s
irb(main):058*     "name: #{name}, price: #{price}, running_time: #{running_time}"
irb(main):059*   end
irb(main):060> end
=> :to_s
irb(main):061> 
irb(main):062> dvd = DVD.new('An awesome film', 3000, 120)
irb(main):063> dvd.to_s
=> "name: An awesome film, price: 3000, running_time: 120"
```
super を使いスーパークラスのメソッドも活用してあげる。
```ruby
irb(main):064* class Product
irb(main):065*   attr_reader :name, :price
irb(main):066*   def initialize(name, price)
irb(main):067*     @name = name
irb(main):068*     @price = price
irb(main):069*   end
irb(main):070* 
irb(main):071*   def to_s
irb(main):072*     "name: #{name}, price: #{price}"
irb(main):073*   end
irb(main):074> end
=> :to_s
irb(main):075> 
irb(main):076* class DVD < Product
irb(main):077*   attr_reader :running_time
irb(main):078*   def initialize(name, price, running_time)
irb(main):079*     super(name, price)
irb(main):080*     @running_time = running_time
irb(main):081*   end
irb(main):082* 
# superでスーパークラスのto_sメソッドを呼び出す
irb(main):083*   def to_s
irb(main):084*     "#{super}, running_time: #{running_time}"
irb(main):085*   end
irb(main):086> end
=> :to_s
irb(main):087> 
irb(main):088> dvd = DVD.new('An awesome film', 3000, 120)
irb(main):089> dvd.to_s
=> "name: An awesome film, price: 3000, running_time: 120"
```

#### クラスメソッドの継承
クラスを継承すると、クラスメソッドも継承される。
```ruby
irb(main):090* class Foo
irb(main):091*   def self.hello
irb(main):092*     'hello'
irb(main):093*   end
irb(main):094> end
=> :hello
irb(main):095> 
irb(main):096* class Bar < Foo
irb(main):097> end
=> nil
# Fooを継承したBarでもクラスメソッドのhelloが呼び出せる
irb(main):098> Foo.hello
=> "hello"
irb(main):099> Bar.hello
=> "hello"
```
↑ただし、インスタンスメソッドに比べ、継承されたクラスメソッドを活用する機会は少ない。


-------------


## ✍🏻 感想
### 🤔 クラスの継承を振り返る
Ruby においてクラスの継承とは、既存のクラス（スーパークラス（親クラス））の機能や特性を引き継いで、新しいクラス（サブクラス（子クラス））を作成する仕組みです。これにより、コードの再利用が可能になります。クラスの継承も、オブジェクト指向プログラミングの核となる概念だと感じています。実際にコードを書いて動かしながら、理解していきたいと思います。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 20 min
- Total: 954 hours 31 min
