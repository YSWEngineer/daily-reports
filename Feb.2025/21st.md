# 2025/02/21(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.7 メソッドの可視性
    - 7.8 定数についてもっと詳しく 途中まで


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.8 定数についてもっと詳しく  途中から
      - 定数と再代入


------------


## 💡 本日の学び・気付き
### 7.7 メソッドの可視性
Ruby のメソッドには以下のような3つの可視性がある。
- public
- protected
- private

#### publicメソッド
publicメソッドはクラスの外部からでも自由に呼び出せるメソッド。initializeメソッド以外のインスタンスメソッドはデフォルトで publicメソッドになる。
```ruby
irb(main):001* class User
# デフォルトはpublic
irb(main):002*   def hello
irb(main):003*     'Hello!'
irb(main):004*   end
irb(main):005> end
=> :hello
irb(main):006> user = User.new
# publicメソッドなのでクラスの外部から呼び出せる
irb(main):007> user.hello
=> "Hello!"
```

#### privateメソッド
publicメソッドが外部に公開されるメソッドに対し、privateメソッドは外部に公開されないメソッド。すなわち「**クラスの外からは呼び出せず、クラスの内部でのみ使えるメソッド（レシーバが self に限定されるメソッド）**」となる。クラス内で privateキーワードを書くと、そこから下で定義されたメソッドは privateメソッドになる。
```ruby
irb(main):008* class User
# ここから下で定義されたメソッドはprivate
irb(main):009*   private
irb(main):010*   def hello
irb(main):011*     'Hello'
irb(main):012*   end
irb(main):013> end
=> :hello
irb(main):014> user = User.new
# privateメソッドなのでクラスの外部から呼び出せない
irb(main):015> user.hello
(irb):15:in `<main>': private method `hello' called for an instance of User (NoMethodError)
```

#### privateメソッドから先に定義する場合
privateキーワードの下に定義したメソッドが privateメソッドになるように、publicキーワードの下に定義したメソッドは publicメソッドになる。この考え方を使うと privateメソッドや publicメソッドを好きな順番で定義することができる。
```ruby
class User
# ここから下はprivateメソッド
  private

  def foo
  end

# ここから下はpublicメソッド
  public

  def bar
  end
end
```
↑通常は privateキーワードを使うのは1回だけにして、クラスの最後のほうに privateメソッドの定義をまとめることのほうが多い。

#### privateメソッドはサブクラスでも呼び出せる
Ruby では「privateメソッドはそのクラスだけでなく、サブクラスでも呼び出せる」という仕様になっている。
```ruby
irb(main):001* class Product
irb(main):002*   private
# これはprivateメソッド
irb(main):003*   def name
irb(main):004*     'A great movie'
irb(main):005*   end
irb(main):006> end
=> :name
irb(main):007* class DVD < Product
irb(main):008*   def to_s
# nameはスーパークラスのprivateメソッド
irb(main):009*     "name: #{name}"
irb(main):010*   end
irb(main):011> end
=> :to_s
irb(main):012> 
irb(main):013> dvd = DVD.new
# 内部でスーパークラスのprivateメソッドを呼んでいるがエラーにはならない
irb(main):014> dvd.to_s
=> "name: A great movie"
```
スーパークラスの privateメソッドが呼び出せるということは、オーバーライド（override）もできるということ。
```ruby
irb(main):001* class Product
irb(main):002*   def to_s
# nameは常に"A great movie"になる、とは限らない
irb(main):003*     "name: #{name}"
irb(main):004*   end
irb(main):005*   private
irb(main):006*   def name
irb(main):007*     'A great movie'
irb(main):008*   end
irb(main):009> end
=> :name
irb(main):010* class DVD < Product
irb(main):011*   private
# スーパークラスのprivateメソッドをオーバーライドする
irb(main):012*   def name
irb(main):013*     'An awesome film'
irb(main):014*   end
irb(main):015> end
=> :name
irb(main):016> product = Product.new
=> #<Product:0x00000001225dab10>
# Productクラスのnameメソッドが使われる
irb(main):017> product.to_s
=> "name: A great movie"
irb(main):018> dvd = DVD.new
# オーバーライドしたDVDクラスのnameメソッドが使われる
irb(main):019> dvd.to_s
=> "name: An awesome film"
```
Ruby で継承を使う場合はスーパークラスの実装もしっかりと把握していなければならない。また、サブクラスでオーバーライドすると、可視性も同時に変更できる。このため、意図せず可視性を変更しないように注意する必要がある。
```ruby
# nameをprivateメソッドとして定義する
irb(main):001* class Product
irb(main):002*   private
irb(main):003*   def name
irb(main):004*     'A great movie'
irb(main):005*   end
irb(main):006> end
=> :name
# nameをpublicメソッドとしてオーバーライドする
irb(main):007* class DVD < Product
irb(main):008*   public
irb(main):009*   def name
irb(main):010*     'An awesome film'
irb(main):011*   end
irb(main):012> end
=> :name
# Productクラスのnameメソッドは呼び出せない
irb(main):013> product = Product.new
irb(main):014> product.name
(irb):14:in `<main>': private method `name' called for an instance of Product (NoMethodError)
# DVDクラスのnameメソッドは呼び出せる
irb(main):015> dvd = DVD.new
irb(main):016> dvd.name
=> "An awesome film"
```

#### クラスメソッドを private にしたい場合
```ruby
irb(main):001* class User
irb(main):002*   private
# クラスメソッドもprivateメソッドになる？
irb(main):003*   def self.hello
irb(main):004*     'Hello!'
irb(main):005*   end
irb(main):006> end
# クラスメソッドは privateメソッドにならない！
irb(main):007> User.hello
=> "Hello!"
```
クラスメソッドを private にしたい場合は、class << self の構文を使う。
```ruby
iirb(main):001* class User
irb(main):002*   class << self
# class << selfの構文ならクラスメソッドでもprivateが機能する
irb(main):003*     private
irb(main):004*     def hello
irb(main):005*       'Hello!'
irb(main):006*     end
irb(main):007*   end
irb(main):008> end
irb(main):009> User.hello
(irb):9:in `<main>': private method `hello' called for class User (NoMethodError)
```
class << self を使わない場合は、private_class_method でクラスメソッドの定義後に可視性を変更することができる。
```ruby
irb(main):001* class User
irb(main):002*   def self.hello
irb(main):003*     'Hello!'
irb(main):004*   end
# 後からクラスメソッドをprivateに変更する
irb(main):005*   private_class_method :hello
irb(main):006> end
irb(main):007> User.hello
(irb):7:in `<main>': private method `hello' called for class User (NoMethodError)
```
**クラスメソッドはインスタンスメソッドと同じように privateキーワードの下に定義しても private なクラスメソッドにはならない**、という点に注意すること。

#### メソッドの可視性を変える方法あれこれ
privateキーワードは実際にはメソッドなので、引数を渡すことができる。既存のメソッド名を privateキーワード（privateメソッド）に渡すと、そのメソッドが privateメソッドになる。また、引数を渡した場合はその下に定義したメソッドの可視性は変更されない。
```ruby
irb(main):001* class User
# いったんpublicメソッドとして定義する
irb(main):002*   def foo
irb(main):003*     'foo'
irb(main):004*   end
irb(main):005*   def bar
irb(main):006*     'bar'
irb(main):007*   end
# fooとbarをprivateメソッドに変更する
irb(main):008*   private :foo, :bar
# bazはpublicメソッド
irb(main):009*   def baz
irb(main):010*     'baz'
irb(main):011*   end
irb(main):012> end
=> :baz
irb(main):013> user = User.new
irb(main):014> user.foo
(irb):14:in `<main>': private method `foo' called for an instance of User (NoMethodError)
irb(main):015> user.bar
(irb):15:in `<main>': private method `bar' called for an instance of User (NoMethodError)
irb(main):016> user.baz
=> "baz
```
さらに、Ruby のメソッド定義は式になっていて、メソッド定義が完了するとメソッド名をシンボルとして返す。
```ruby
# 実はメソッド定義も値も返している
irb(main):017* def foo
irb(main):018*   'foo'
irb(main):019> end
=> :foo
```
この知識を応用すると、メソッド定義と同時にそのメソッドを privateメソッドにすることが可能。
```ruby
irb(main):020* class User
# メソッド定義の戻り値 :foo をprivateキーワード（実際はメソッド）の引数とする
# 結果としてfooはprivateメソッドになる
irb(main):021*   private def foo
irb(main):022*     'foo'
irb(main):023*   end
irb(main):024> end
=> :foo
irb(main):025> user = User.new
irb(main):026> user.foo
(irb):26:in `<main>': private method `foo' called for an instance of User (NoMethodError)
```
アクセサメソッドを privateメソッドにしたいときは、privateキーワードにゲッターメソッドとセッターメソッドの名前を渡す。
```ruby
irb(main):001* class User
irb(main):002*   attr_accessor :name
# ゲッターメソッドとセッターメソッドをそれぞれprivateメソッドにする
irb(main):003*   private :name, :name=
irb(main):004*   def initialize(name)
irb(main):005*     @name = name
irb(main):006*   end
irb(main):007> end
=> :initialize
irb(main):008> user = User.new('Alice')
irb(main):009> user.name
(irb):9:in `<main>': private method `name' called for an instance of User (NoMethodError)
irb(main):010> user.name = 'Bob'
(irb):10:in `<main>': private method `name=' called for an instance of User (NoMethodError)
```
Ruby 3.0 では privateキーワードと attr_accessorキーワード（どちらもメソッド）の引数と戻り値の仕様が変更された関係で、1行で private なアクセサメソッドを定義することができるようになった。
```ruby
irb(main):001* class User
irb(main):002*   private attr_accessor :name
irb(main):003*   def initialize(name)
irb(main):004*     @name = name
irb(main):005*   end
irb(main):006> end
=> :initialize
irb(main):007> 
irb(main):008> user = User.new('Alice')
irb(main):009> user.name
(irb):9:in `<main>': private method `name' called for an instance of User (NoMethodError)
irb(main):010> user.name = 'Bob'
(irb):10:in `<main>': private method `name=' called for an instance of User (NoMethodError)
```
##### 復習：ゲッターメソッドとセッターメソッド
- **ゲッターメソッド**：インスタンス変数の値を外部から取得するためのメソッド。
- **セッターメソッド**：インスタンス変数の値を外部から設定するためのメソッド。

Ruby では、`attr_accessor`、`attr_reader`、`attr_writer`を使い、簡単にこれらのメソッドを定義できる。

#### protectedメソッド
protectedメソッドはそのメソッドを定義したクラス自身と、そのサブクラスのインスタンスメソッドからレシーバ付きで呼び出せる。たとえば、名前（name）と体重（weight）を持つ Userクラスがあったとする。ただし、体重を公開せず、外部から取得できるのは名前だけにする。
```ruby
class 
  # weightは外部に公開しない
  attr_reader :name
  
  def initialize(name, weight)
    @name = name
    @weight = weight
  end
end
```
しかし、ユーザ同士の体重を比較しなければならなくなったため、次のようなメソッドを定義する。
```ruby
irb(main):001* class User
irb(main):002*   attr_reader :name
irb(main):003* 
irb(main):004*   def initialize(name, weight)
irb(main):005*     @name = name
irb(main):006*     @weight = weight
irb(main):007*   end
irb(main):008* 
irb(main):009*   def heavier_than?(other_user)
irb(main):010*     other_user.weight
irb(main):011*   end
irb(main):012> end
=> :heavier_than?
irb(main):013> 
irb(main):014> alice = User.new('Alice', 50)
=> #<User:0x0000000121e5bce0 @name="Alice", @weight=50>
irb(main):015> bob = User.new('Bob', 60)
=> #<User:0x0000000121e14200 @name="Bob", @weight=60>
# AliceはBobのweightを取得できない
irb(main):016> alice.heavier_than?(bob)
(irb):10:in `heavier_than?': undefined method `weight' for an instance of User (NoMethodError)
```
↑外部には公開したくないが、同じクラスやサブクラスの中であればレシーバ付きで呼び出せるようにしたい、というときに登場するのが protectedメソッド。protectedキーワードを使い、weightメソッドを protectedメソッドにする。
```ruby
irb(main):001* class User
irb(main):002*   attr_reader :name
irb(main):003*   def initialize(name, weight)
irb(main):004*     @name = name
irb(main):005*     @weight = weight
irb(main):006*   end
irb(main):007*   def heavier_than?(other_user)
irb(main):008*     other_user.weight < @weight
irb(main):009*   end
irb(main):010*   protected
# protectedメソッドなので同じクラスかサブクラスであればレシーバ付きで呼び出せる
irb(main):011*   def weight
irb(main):012*     @weight
irb(main):013*   end
irb(main):014> end
=> :weight
irb(main):015> alice = User.new('Alice', 50)
=> #<User:0x000000010d51d700 @name="Alice", @weight=50>
irb(main):016> bob = User.new('Bob', 60)
# 同じクラスのインスタンスメソッド内であればweightが呼び出せる
irb(main):017> alice.heavier_than?(bob)
=> false
irb(main):018> bob.heavier_than?(alice)
=> true
# クラスの外ではweightは呼び出せない
irb(main):019> alice.weight
(irb):19:in `<main>': protected method `weight' called for an instance of User (NoMethodError)
```

### 7.8 定数についてもっと詳しく
定数はクラスの外部から直接参照することも可能。クラスの外部から定数を参照する場合は次のような構文を使う。
```ruby
クラス名::定数名
```
以下はクラスの外部から定数を参照するコード例。
```ruby
irb(main):001* class Product
irb(main):002*   DEFAULT_PRICE = 0
irb(main):003> end
irb(main):004> Product::DEFAULT_PRICE
=> 0
```
定数をクラスの外部から参照させたくない場合は private_constant で定数名を指定する。
```ruby
irb(main):001* class Product
irb(main):002*   DEFAULT_PRICE = 0
# 定数をprivateにする
irb(main):003*   private_constant :DEFAULT_PRICE
irb(main):004> end
# privateなのでクラスの外部からは参照できない
irb(main):005> Product::DEFAULT_PRICE
(irb):5:in `<main>': private constant Product::DEFAULT_PRICE referenced (NameError)
```
Ruby では**「メソッド内にスコープを限定した定数」は定義できない**。ゆえに、メソッドの内部で定数を定義しようとするとエラーになる。
```ruby
irb(main):001* def foo
irb(main):002*   BAR = 123
irb(main):003*   BAR * 10
irb(main):004> end
/Users/yoshiwo/.rbenv/versions/3.3.1/lib/ruby/3.3.0/irb/workspace.rb:117:in `eval': (irb):2: dynamic constant assignment (SyntaxError)
  BAR = 123
  ^~~
```
そのため、**定数の定義は必ずクラス構文の直下、もしくはトップレベルで行う**必要がある。
```ruby
# トップレベルで定義する定数
SOME_VALUE = 123

class Product
  # クラス構文の直下で定義する定数
  DEFAULT_PRICE = 0
end
```
また、Ruby の定数定義（= を使った代入）はそれ自体が値を返す（つまり、式になっている）。
```ruby
# 定数定義はそれ自体が値を返している（ここでは0が返る）
irb(main):005> GREEN = 0
=> 0
```
この仕組みを利用すると、次のように配列を定数で定義しつつ、その要素も同時に定数として定義することも可能。
```ruby
irb(main):006* class TrafficLight
# 配列COLORSを定数として定義し、その各要素も定数として同時に定義する
irb(main):007*   COLORS = [
irb(main):008*     GREEN = 0,
irb(main):009*     YELLOW = 1,
irb(main):010*     RED = 2,
irb(main):011*   ]
irb(main):012> end
irb(main):013> TrafficLight::GREEN
=> 0
irb(main):014> TrafficLight::YELLOW
=> 1
irb(main):015> TrafficLight::RED
=> 2
irb(main):016> TrafficLight::COLORS
=> [0, 1, 2]
```
定数にはリテラルで作られる静的な値だけでなく、メソッドや条件分岐を使った動的な値も代入可能。
```ruby
# mapメソッドの戻り値を定数に代入する
irb(main):001> NUMBERS = [1, 2, 3].map { |n| n * 10 }
irb(main):002> NUMBERS
=> [10, 20, 30]

# 三項演算子を使った条件分岐の結果を定数に代入する（windows?は実行環境のOSを判定する架空のメソッド）
NEW_LINE = windows? ? "\r\n" : "\n"
```


-------------


## ✍🏻 感想
### 🤔 メソッドの可視性
Ruby では、クラスで定義したメソッドが、外部からアクセスできるかを制御するために、`public`、`private`、`protected`の3つのキーワードを使用します。これらを使うことで、クラスの設計において、必要な部分だけを外部に公開し、内部の実装を隠すことができます。それぞれの使い分けができるようになるには、実際にコードを書いて試してみることが王道ですね。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 4 hours 09 min
- Total: 958 hours 40 min
