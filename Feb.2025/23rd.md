# 2025/02/23(日)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.8 定数についてもっと詳しく  途中から
      - 定数と再代入
    - 7.9 さまざまな種類の変数
    - 7.10 クラス定義や Ruby の言語使用に関する高度な話題 途中まで


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
    - 7.10 クラス定義や Ruby の言語使用に関する高度な話題 途中から
    


------------


## 💡 本日の学び・気付き
### 7.8 定数についてもっと詳しく
#### 定数と再代入
Ruby の定数は再代入が可能で、定数の値を後から書き換えることができる。
```ruby
irb(main):001* class Product
irb(main):002*   DEFAULT_PRICE = 0
# 再代入して定数の値を書き換える
irb(main):003*   DEFAULT_PRICE = 1000
irb(main):004> end
(irb):3: warning: already initialized constant Product::DEFAULT_PRICE
# 再代入後の値が返る
irb(main):005> Product::DEFAULT_PRICE
=> 1000
# クラスの外部からでも再代入が可能
irb(main):006> Product::DEFAULT_PRICE = 3000
(irb):6: warning: already initialized constant Product::DEFAULT_PRICE
irb(main):007> Product::DEFAULT_PRICE
=> 3000
```
`already initialized constant`と警告は表示されるが、再代入自体は成功している。

クラス外部からの再代入を防ぎたい場合はクラスを freeze（凍結）する。こうすることで、クラスは変更を受け付けなくなる。
```ruby
irb(main):008> Product.freeze
=> Product
irb(main):009> Product::DEFAULT_PRICE = 5000
(irb):9:in `<main>': can't modify frozen #<Class:Product>: Product (FrozenError)
```
Ruby の場合、`freeze`を呼べば再代入を防ぐことができるが、そのあとでメソッドの定義もできなくなってしまうため、`freeze`を呼ぶことはまずない。

#### 定数はミュータブルなオブジェクトに注意する
再代入をしなくてもミュータブルなオブジェクトであれば定数の値を変えることができる。ミュータブルなオブジェクトとは、文字列（String）、配列（Array）、ハッシュ（Hash）など。
```ruby
irb(main):001* class Product
irb(main):002*   NAME = 'A product'
irb(main):003*   SOME_NAMES = ['Foo', 'Bar', 'Baz']
irb(main):004*   SOME_PRICES = { foo: 1000, bar: 2000, baz: 300
0 }
irb(main):005> end

# 文字列を破壊的に大文字に変更する
=> {:foo=>1000, :bar=>2000, :baz=>3000}
irb(main):006> Product::NAME.upcase!
irb(main):007> Product::NAME
=> "A PRODUCT"

# 配列に新しい要素を追加する
irb(main):008> Product::SOME_NAMES << 'Hoge'
irb(main):009> Product::SOME_NAMES
=> ["Foo", "Bar", "Baz", "Hoge"]

# ハッシュに新しいキーと値を追加する
irb(main):010> Product::SOME_PRICES[:hoge] = 4000
irb(main):011> Product::SOME_PRICES
=> {:foo=>1000, :bar=>2000, :baz=>3000, :hoge=>4000}
```
定数の値を変数に代入したり、メソッドの引数として受け取ったりしてしまうと定数を変更していることに気付きにくくなる。
```ruby
irb(main):001* class Product
irb(main):002*   SOME_NAMES = ['Foo', 'Bar', 'Baz']
irb(main):003*   def self.names_without_foo(names = SOME_NAMES)

# namesがデフォルト値だと、以下のコードは定数のSOME_NAMESを破壊的に変更していることになる
irb(main):004*     names.delete('Foo')
irb(main):005*     names
irb(main):006*   end
irb(main):007> end
irb(main):008> Product.names_without_foo
=> ["Bar", "Baz"]

# 定数の中身が変わった
irb(main):009> Product::SOME_NAMES
=> ["Bar", "Baz"]
```
こうした事故を防ぐためには、定数の値を`freeze`する。こうすることで定数に対して破壊的な変更ができなくなる。
```ruby
irb(main):001* class Product

# 配列を凍結する
irb(main):002*   SOME_NAMES = ['Foo', 'Bar', 'Baz'].freeze

irb(main):003*   def self.names_without_foo(names = SOME_NAMES)
# freezeしている配列に対しては破壊的な変更はできない
irb(main):004*     names.delete('Foo')
irb(main):005*     names
irb(main):006*   end
irb(main):007> end

# エラーが発生するので予期せずに定数の値が変更される事故が防げる
irb(main):008> Product.names_without_foo
(irb):4:in `delete': can't modify frozen Array: ["Foo", "Bar", "Baz"] (FrozenError)
```
配列やハッシュを`freeze`すると配列やハッシュそのものへの変更は防止できるが、配列やハッシュの各要素は`freeze`しない。よって、次のようなコードを書くと定数の内容は変更されてしまう。
```ruby
irb(main):001* class Product

# 配列はfreezeされるが中身の文字列はfreezeされない
irb(main):002*   SOME_NAMES = ['Foo', 'Bar', 'Baz'].freeze
irb(main):003> end
=> ["Foo", "Bar", "Baz"]

# 1番目の要素を破壊的に大文字に変更する
irb(main):004> Product::SOME_NAMES[0].upcase!

# 1番目の要素の値が変わった
irb(main):005> Product::SOME_NAMES
=> ["FOO", "Bar", "Baz"]
```
この事故を防ぐには、各要素の値も別途freezeする必要がある。
```ruby
irb(main):001* class Product

# 中身の文字列もfreezeする
irb(main):002*   SOME_NAMES = ['Foo'.freeze, 'Bar'.freeze, 'Baz'.freeze].freeze
irb(main):003> end

# 中身もfreezeしているので破壊的な変更はできない
irb(main):004> Product::SOME_NAMES[0].upcase!
(irb):4:in `upcase!': can't modify frozen String: "Foo" (FrozenError)
```
なお、mapメソッドを使うと、`freeze`を何度も書かずに済む。
```ruby
# mapメソッドで各要素をfreezeし、最後にmapメソッドの戻り値の配列をfreezeする
SOME_NAMES = ['Foo', 'Bar', 'Baz'].map(&:freeze).freeze
```
配列やハッシュの中身まですべて`freeze`するのは大変なので、プログラムの規模や要件（堅牢性がどこまで重視されるかなど）に応じて、`freeze`を適用するレベル（深さ）を検討すること。

- **堅牢性**：システムや製品、プログラムなどが予期しない状況や障害、エラーが発生しても安定して動作し続ける能力のことを指す。簡単に言い換えると、「壊れにくさ」「耐久性」といった意味合いがある。

一方、イミュータブルなオブジェクトは`freeze`する必要がないことを押さえておくこと。数値やシンボル、true / false などはイミュータブルなオブジェクトなので破壊的に変更することはできない。
```ruby
class Product
  # 数値やシンボル、true/falseはfreeze不要（しても構わないが、意味がない）
  SOME_VALUE = 0
  SOME_TYPE = :foo
  SOME_FLAG = true
end
```
Ruby の定数は「**変更しようと思えばいくらでも変更できる値**」になっている。「ついうっかり」の事故を防ぐためには幾らかの工夫が必要になることを覚えておくこと。

##### 復習：ミュータブルとイミュータブル
- **ミュータブル（Mutable）**
  - 「変更可能」という意味。
  - オブジェクトの内容を後から変えることができることを指す。
  - プログラム中でデータを変更したい場合に使われる。

- **イミュータブル（Immutable）**
  - 「変更不可能」という意味。
  - オブジェクトの内容を後から変えることができないことを指す。
  - 一度作成したデータは、そのままの状態で保持される。

### 7.9 様々な種類の変数
Ruby ではローカル変数とインスタンス変数の2種類以外にも様々な種類の変数がある。
- **クラスインスタンス変数**
- **クラス変数**
- **グローバル変数**
- **Ruby標準の組み込み変数（特殊変数）**

いずれも使用頻度は少ないため「もし遭遇したらもう一度読み直す」ぐらいの気持ちでOK。

#### クラスインスタンス変数
```ruby
irb(main):001* class Product
irb(main):002*   @name = 'Product'

irb(main):003*   def self.name
irb(main):004*     @name
irb(main):005*   end

irb(main):006*   def initialize(name)
irb(main):007*     @name = name
irb(main):008*   end

# attr_reader :nameでもいいが、@nameの中身を意識するためにあえてメソッドを定義する
irb(main):009*   def name
irb(main):010*     @name
irb(main):011*   end
irb(main):012> end

irb(main):013> Product.name
=> "Product"

irb(main):014> product = Product.new('A great movie')
irb(main):015> product.name
=> "A great movie"
irb(main):016> Product.name
=> "Product
```
↑上記のコードには`@name`が4箇所登場しているが、実は2種類の`@name`に分かれる。1つはインスタンス変数の`@name`で、もうひとつはクラスインスタンス変数の`@name`。見た目は同じだが、全く別のデータ。
```ruby
class Product
# クラスインスタンス変数
  @name = 'Product'

  def self.name
# クラスインスタンス変数
    @name
  end

  def initialize(name)
# インスタンス変数
    @name = name
  end

  def name
# インスタンス変数
    @name
  end
end
```
インスタンス変数はクラスをインスタンス化（`クラス名.new`でオブジェクトを作成）した際に、オブジェクトごとに管理される変数。

一方、クラスインスタンス変数はインスタンスの作成とは無関係に、クラス自身が保持しているデータ（クラス自身のインスタンス変数）。クラス構文の直下や、クラスメソッドの内部で`@`で始まる変数を操作すると、クラスインスタンス変数にアクセスしていることになる。

ここに継承の考え方が入るとさらにややこしくなる。
```ruby
irb(main):001* class Product
irb(main):002*   @name = 'Product'

irb(main):003*   def self.name
irb(main):004*     @name
irb(main):005*   end

irb(main):006*   def initialize(name)
irb(main):007*     @name = name
irb(main):008*   end

irb(main):009*   def name
irb(main):010*     @name
irb(main):011*   end
irb(main):012> end
=> :name

irb(main):013* class DVD < Product
irb(main):014*   @name = 'DVD'

irb(main):015*   def self.name
# クラスインスタンス変数を参照
irb(main):016*     @name
irb(main):017*   end

irb(main):018*   def upcase_name
# インスタンス変数を参照
irb(main):019*     @name.upcase
irb(main):020*   end
irb(main):021> end
=> :upcase_name

irb(main):022> Product.name
=> "Product"
irb(main):023> DVD.name
=> "DVD"

irb(main):024> product = Product.new('A great movie')
irb(main):025> product.name
=> "A great movie"

irb(main):026> dvd = DVD.new('An awesome film')
irb(main):027> dvd.name
=> "An awesome film"
irb(main):028> dvd.upcase_name
=> "AN AWESOME FILM"

irb(main):029> Product.name
=> "Product"
irb(main):030> DVD.name
=> "DVD"
```
DVDクラスは Productクラスを継承している。インスタンス変数の`@name`はスーパークラス内で参照しても、サブクラス内で参照しても同じ値になる。上記のコードでいうと、`@name.upcase`の`@name`には文字列の`"An awesome film"`が入っている。

一方、クラスインスタンス変数では Productクラスと DVDクラスで別々に管理されている。上記のコードでいうと、Productクラスの`@name`には文字列の`"Product"`が、DVDクラスの`@name`には文字列の`"DVD"`が入っている。

インスタンス変数は同じ変数名であればスーパークラスでもサブクラスでも同一のインスタンス変数が参照されるが、クラスインスタンス変数は同名であってもスーパークラスとサブクラスで異なる変数として参照される。

**クラス自身もインスタンス変数を保持できる**こと、インスタンス変数とは異なり**スーパークラスとサブクラスでは同じ名前でも別の変数になる**ことを覚えておくこと。

#### クラス変数
Ruby では、同名であってもクラス構文の直下やクラスメソッドの内部ではスーパークラスとサブクラスで別々の変数として参照される状況でも、同一の変数として代入・参照可能な変数がある。それが**クラス変数**。クラス変数は`@@some_value`のように、変数名の最初に`@`を2つ重ねる。
```ruby
irb(main):001* class Product
irb(main):002*   @@name = 'Product'

irb(main):003*   def self.name
irb(main):004*     @@name
irb(main):005*   end

irb(main):006*   def initialize(name)
irb(main):007*     @@name = name
irb(main):008*   end

irb(main):009*   def name
irb(main):010*     @@name
irb(main):011*   end
irb(main):012> end
=> :name

irb(main):013* class DVD < Product
irb(main):014*   @@name = 'DVD'

irb(main):015*   def self.name
irb(main):016*     @@name
irb(main):017*   end

irb(main):018*   def upcase_name
irb(main):019*     @@name.upcase
irb(main):020*   end
irb(main):021> end

# DVDクラスを定義したタイミングで@@nameが"DVD"に変更される
irb(main):022> Product.name
=> "DVD"
irb(main):023> DVD.name
=> "DVD"

irb(main):024> product = Product.new('A great movie')
irb(main):025> product.name
=> "A great movie"

# Product.newのタイミングで@@nameが"A great movie"に変更される
irb(main):026> Product.name
=> "A great movie"
irb(main):027> DVD.name
=> "A great movie"

irb(main):028> dvd = DVD.new('An awesome film')
irb(main):029> dvd.name
=> "An awesome film"
irb(main):030> dvd.upcase_name
=> "AN AWESOME FILM

# DVD.newのタイミングで@@nameが"An awesome film"に変更される
irb(main):031> product.name
=> "An awesome film"
irb(main):032> Product.name
=> "An awesome film"
irb(main):033> DVD.name
=> "An awesome film"
```
クラス変数の`@@name`はクラスメソッド内でもインスタンスメソッド内でも参照できる。またスーパークラスとサブクラスのクラス構文の直下や、クラスメソッドの内部でも参照できる。

未定義のクラス変数を参照するとエラーになる。
```ruby
irb(main):001* class Product
# クラス変数@@nameの定義を削除する
# @@name = 'Product'

irb(main):002*   def self.name
irb(main):003*     @@name
irb(main):004*   end
irb(main):005> end

# 未定義のクラス変数を参照したのでエラーが発生する
irb(main):006> Product.name
(irb):3:in `name': uninitialized class variable @@name in Product (NameError)
```

#### グローバル変数と組み込み変数
グローバル変数は`$some_value`のように、`$`で変数名を始める。グローバル変数はクラスの内部、外部を問わず、プログラムのどこからでも代入、参照が可能。
```ruby
# グローバル変数の宣言と値の代入
irb(main):001> $program_name = 'Awesome program'
=> "Awesome program"

# グローバル変数に依存するクラス
irb(main):002* class Program
irb(main):003*   def initialize(name)
irb(main):004*     $program_name = name
irb(main):005*   end

irb(main):006*   def self.name
irb(main):007*     $program_name
irb(main):008*   end

irb(main):009*   def name
irb(main):010*     $program_name
irb(main):011*   end
irb(main):012> end

# $program_nameはすでに名前が代入されている
irb(main):013> Program.name
=> "Awesome program"

irb(main):014> program = Program.new('Super program')
irb(main):015> program.name
=> "Super program"

# Program.newのタイミングで$program_nameが"Super program"に変更される
irb(main):016> Program.name
=> "Super program"
irb(main):017> $program_name
=> "Super program"
```
インスタンス変数と同様、未定義のグローバル変数を参照した場合は`nil`が返る。
```ruby
# $foobarが未定義であれば（つまり、一度も代入されていなければ）nilが返る
irb(main):018> $foobar
=> nil
```
**グローバル変数の乱用は理解しづらいプログラムを生み出す原因**になる。何か特別な理由がない限り、グローバル変数の使用は避けるべき。

### 7.10 クラス定義や Ruby の言語使用に関する高度な話題
#### エイリアスメソッドの定義
紹介してきた Ruby の標準ライブラリのメソッドには、別の名前でも全く同じ動作をするエイリアスメソッドが多数存在していた。たとえば、Stringクラスの sizeメソッドは lengthメソッドのエイリアスメソッドである。
```ruby
irb(main):001> s = 'Hello'
irb(main):002> s.length
=> 5
irb(main):003> s.size
=> 5
```
独自に作成したクラスでもエイリアスメソッドを定義することができる。エイリアスメソッドを定義する場合は、以下のようにして`alias`キーワードを使う。
```ruby
alias 新しい名前 元の名前
```
エイリアスメソッドを定義する場合は aliasキーワードを呼び出すタイミングに注意。aliasキーワードを呼び出す場合は先に元のメソッドを定義しておかないとエラーになる。
```ruby
# helloメソッドのエイリアスメソッドとしてgreetメソッドを定義する例
irb(main):001* class User
irb(main):002*   def hello
irb(main):003*     'Hello!'
irb(main):004*   end

# helloメソッドのエイリアスメソッドとしてgreetを定義する
irb(main):005*   alias greet hello
irb(main):006> end
=> nil

irb(main):007> user = User.new
irb(main):008> user.hello
=> "Hello!"
irb(main):009> user.greet
=> "Hello!"
```

#### メソッドの削除
Ruby ではメソッドの定義をあとから削除することもできる。メソッドを削除する場合は`undef`キーワードを使う。
```ruby
undef 削除するメソッドの名前
```
以下はスーパークラス（Objectクラス）で定義されている freezeメソッドを削除するコード例。
```ruby
irb(main):001* class User
irb(main):002*   undef freeze
irb(main):003> end
=> nil
irb(main):004> user = User.new
irb(main):005> user.freeze
(irb):5:in `<main>': undefined method `freeze' for an instance of User (NoMethodError)
```

#### 入れ子になったクラスの定義
クラス定義する場合、クラスの内部に別のクラスを定義することもできる。
```ruby
class 外側のクラス
  class 内側のクラス
  end
end
```
クラスの内部に定義したクラスは`::`を使って参照できる。
```ruby
外側のクラス::内側のクラス
```
```ruby
# 入れ子になったクラスを定義する例
irb(main):001* class User
irb(main):002*   class BloodType
irb(main):003*     attr_reader :type

irb(main):004*     def initialize(type)
irb(main):005*       @type = type
irb(main):006*     end
irb(main):007*   end
irb(main):008> end
=> :initialize

irb(main):009> blood_type = User::BloodType.new('B')
irb(main):010> blood_type.type
=> "B"
```

#### 演算子の挙動を独自に再定義する
Ruby では`=`で終わるメソッドを定義することができる。`=`で終わるメソッドは変数に代入するような形式でそのメソッドを呼ぶことができる。
```ruby
irb(main):001* class User
# =で終わるメソッドを定義する
irb(main):002*   def name=(value)
irb(main):003*     @name = value
irb(main):004*   end
irb(main):005> end
=> :name=

irb(main):006> user = User.new
# 変数に代入するような形式でname=メソッドを呼び出せる
irb(main):007> user.name = 'Alice'
=> "Alice"
```

##### 再定義可能な演算子と再定義できない演算子
```
# 再定義可能な演算子
|  ^  &  <=>  ==  ===  =~  >  >=  <  <=  <<  >>
+  -  *  /  %  **  ~  +@  -@  []  []=  `  !  !=  !~

# 再定義できない演算子
=  ?:  ..  ...  not  &&  and  ||  or  ::
```

例として`==`を再定義してみる。たとえば次のような商品（Product）クラスがあったとする。
```ruby
class Product
  attr_reader :code, :name

  def initialize(code, name)
    @code = code
    @name = name
  end
end
```
code は商品コード、name は商品名。「商品コードは一意な値が割り振られ、同じ商品コードであれば同じ商品だと判断する」という要件があったとする。この場合、以下のようにコードが動くと理想的。
```ruby
# aとcが同じ商品コード
a = Product.new('A-0001', 'A great movie')
b = Product.new('B-0001', 'An awesome film')
c = Product.new('A-0001', 'A great movie')

# ==がこのように動作してほしい
a == b #=> false
a == c #=> ture
```
しかし最初のコードのままでは、どちらも結果は false になる。なぜなら「スーパークラスの Objectクラスでは、`==`は`object_id`が一致したときに true を返す」という仕様になっているため。
```ruby
# 何もしないと実際はこうなる
a == b #=> false
a == c #=> false

# デフォルトでは同じobject_id（全く同じインスタンス）の場合にtrueになる
a == a #=> true
```
Productクラスで`==`を再定義（オーバーライド）してみる。
```ruby
irb(main):001* class Product
irb(main):002*   attr_reader :code, :name
irb(main):003*   def initialize(code, name)
irb(main):004*     @code = code
irb(main):005*     @name = name
irb(main):006*   end

irb(main):007*   def ==(other)
# otherがProductかつ、商品コードが一致していれば同じProductと見なす
irb(main):008*     other.is_a?(Product) && code == other.code
irb(main):009*   end
irb(main):010> end

irb(main):011> a = Product.new('A-0001', 'A great movie')
=> 
#<Product:0x0000000124e590f0
...
irb(main):012> b = Product.new('B-0001', 'An awesome film')
=> 
#<Product:0x0000000124e5d268
...
irb(main):013> c = Product.new('A-0001', 'A great movie')
=> 
#<Product:0x0000000124ef79f8
...

# 商品コードが一致すればtrueになる
irb(main):014> a == b
=> false
irb(main):015> a == c
=> true

# Product以外の比較はfalse
irb(main):016> a == 1
=> false
irb(main):017> a == 'a'
=> false
```
`==`はメソッドなので、ドット（`.`）付きで呼び出しても正常に動作する。
```ruby
irb(main):018> a.==(b)
=> false
irb(main):019> a.==(c)
=> true
```
`==`が呼び出されるのは左辺のオブジェクトになる。次の場合は Productクラスの`==`は呼び出されない。
```ruby
# 左辺になるのが整数なので、Integerクラスの==が呼び出される
irb(main):020> 1 == a
=> false
```

#### 等値を判断するメソッドや演算子を理解する
if文などで同じ値かどうかを比較する場合は`==`を使うことが多いが、Ruby では等値を判断するためのメソッドや演算子が他にもある。具体的には以下の4つ。
- **equal?**
- **==**
- **eql?**
- **===**

##### equal?
equal?メソッドは object_id が等しい場合に true を返す。つまり全く同じインスタンスかどうかを判断する場合に使う。この挙動が変わるとプログラムの実行に悪影響を及ぼす恐れがあるため、equal?メソッドは再定義してはいけない。
```ruby
irb(main):001> a = 'abc'
=> "abc"
irb(main):002> b = 'abc'
irb(main):003> a.equal?(b)
=> false

irb(main):004> c = a
irb(main):005> a.equal?(c)
=> true
```

##### ==
`==`はオブジェクトの内容が等しいかどうかを判断する。`1 == 1.0`が true になるように、データ型が違っても人間の目で見て自然であれば true を返すように再定義することがある。
```ruby
irb(main):006> 1 == 1.0
=> true
```

##### eql?
eql?メソッドも`==`と同様に等値判定を行うが、クラスによっては`==`よりも厳格な等値判定を行う。たとえば、`1 == 1.0`は true だが、`1.eql?(1.0)`は false になる。
```ruby
# eql?メソッドで数値を比較すると、1と1.0は異なる値と判定される
irb(main):007> 1.eql?(1.0)
=> false

# eql?メソッドで数値を比較する場合は同じクラス（Integer同士、またはFloat同士）でなければtrueにならない
irb(main):008> 1.eql?(1)
=> true
irb(main):009> 1.0.eql?(1.0)
=> true
```
eql?メソッドの代表的な用途は、**2つのオブジェクトがハッシュのキーとして同じかどうかを判定**すること。同時のクラスを定義してハッシュのキーとして使いたい場合は、eql?メソッドを再定義する。ただし、eql?メソッドを再定義する場合は、hashメソッドも再定義したうえで、「`a.eql?(b)`が真ならば`a.hash == b.hash`も真」と言う関係を必ず満たす必要がある。hashメソッドはその**オブジェクトのハッシュ値を返す**メソッド。
```ruby
# 文字列（Stringオブジェクト）が返すハッシュ値の例
irb(main):010> 'JP'.hash
=> -1928373699899562898
irb(main):011> 'US'.hash
=> 1642543882715007800

# プログラムを再起動しない限り、同じ文字列からは同じハッシュ値が返る
irb(main):012> 'JP'.hash
=> -1928373699899562898
irb(main):013> 'US'.hash
=> 1642543882715007800
```
たとえば、世界の国のコードを表す CountryCodeクラスがあったとする。
```ruby
class CountryCode
  attr_reader :code

  def initialize(code)
    @code = code
  end
end
```
このクラスのインスタンスをハッシュのキーにして、同じ国コードであれば同じキーにしたいと思っても、そのままでは同一インスタンス以外は同じキーと見なされない。
```ruby
irb(main):007> japan = CountryCode.new('JP')
=> #<CountryCode:0x0000000127bf55e0 @code="JP">
irb(main):008> us = CountryCode.new('US')
=> #<CountryCode:0x0000000127b1ef68 @code="US">
irb(main):009> india = CountryCode.new('IN')
=> #<CountryCode:0x0000000127bf3920 @code="IN">

# CountryCodeクラスのインスタンスをキーにしてハッシュを作成する
irb(main):010> currencies = { japan => 'yen', us => 'dollar', i
ndia => 'rupee' }
=> 
{#<CountryCode:0x0000000127bf55e0 @code="JP">=>"yen",
...

# 同じ国コードなら同じキーとしたいが、そのままでは同一インスタンスだけが同じキーと見なされる
irb(main):011> key = CountryCode.new('JP')
irb(main):012> currencies[key]
=> nil
irb(main):013> currencies[japan]
=> "yen"
```
eql?メソッドとhashメソッドを再定義し、国コードがハッシュのキーとして扱われるようにしてみる。
```ruby
class CountryCode
  attr_reader :code

  def initialize(code)
    @code = code
  end

  def eql?(other)
# otherがCountryCodeかつ、同じ国コードなら同じキーと見なす
    other.instance_of?(CountryCode) && code.eql?(other.code)
  end

  def hash
# CountryCodeオブジェクトのハッシュ値として国コードのハッシュ値を返す
    code.hash
  end
end
```
新たに実装し直した CountryCodeクラスでハッシュを作り直すと、今度は国コードがハッシュのキーとして使われるようになる。
```ruby
# ハッシュを作り直す
currencies = { japan => 'yen', us => 'dollar', india => 'rupee' }

# 同じ国コードなら同じキーと見なされる
irb(main):027> key = CountryCode.new('JP')
irb(main):028> currencies[key]
=> "yen"
irb(main):029> currencies[japan]
=> "yen"
```


-------------


## ✍🏻 感想
### 🤔 クラスに絡む要素
Ruby のクラスには、定数、さまざまな種類の変数、エイリアスメソッドなど、多くの機能や概念が組み合わさっていることを学びました。いまだに難しく感じていますが、それぞれの要素を一つずつ理解していくことで、クラス設計やオブジェクト指向の考え方が明確になっていくと思いますので、引き続きコツコツとインプットしていきます。

------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 5 hours 00 min
- Total: 963 hours 00 min
