# 2025/02/24(月)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する   
    - 7.10 クラス定義や Ruby の言語使用に関する高度な話題 途中から
    - 7.11 この章のまとめ

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する
    - 8.1 イントロダクション


------------


## 💡 本日の学び・気付き
### 7.10 クラス定義や Ruby の言語使用に関する高度な話題
#### 等値を判断するメソッドや演算子を理解する
##### ===
`===`の代表的な用途は case文の when節。たとえば case文では正規表現を使い次のような条件が書ける。
```ruby
irb(main):001> text = '03-1234-5678'
=> "03-1234-5678"

irb(main):002* case text
irb(main):003* when /^\d{3}=\d{4}$/
irb(main):004*   puts '郵便番号です'
irb(main):005* when /^\d{4}\/\d{1,2}\/\d{1,2}$/
irb(main):006*   puts '日付です'
irb(main):007* when /^\d+-\d+-\d+$/
irb(main):008*   puts '電話番号です'
irb(main):009> end
電話番号です
```
このコードを実行すると内部的には
```ruby
/^\d{3}-\d{4}$/ === text
```
や
```ruby
/^\d{4}\/\d{1,2}\/\d{1,2}$/ === text
```
のように、`when節のオブジェクト === case節のオブジェクト`の結果を評価している。

case文では when節にクラス名を書いてオブジェクトのデータ型（所属するクラス）を判定することもできる。これは Stringクラスや Arrayクラスも Classクラスのインスタンスであり、Classクラスが`===`を再定義しているため。
```ruby
irb(main):001> value = [1, 2, 3]
=> [1, 2, 3]

# 内部的には String === value, Array === value, Hash === valueの結果が評価されている
irb(main):002* case value
irb(main):003* when String
irb(main):004*   puts '文字列です'
irb(main):005* when Array
irb(main):006*   puts '配列です'
irb(main):007* when Hash
irb(main):008*   puts 'ハッシュです'
irb(main):009> end
配列です
```

### オープンクラスとモンキーパッチ
Ruby は**クラスの継承に制限がない**。Stringクラスや Arrayクラスなど、組み込みライブラリのクラスであっても継承して独自のクラスを定義することができる。
```ruby
# Stringクラスを継承した独自クラスを定義する
class MyString < String
  # Stringクラスを拡張するためのコードを書く
end
s = Mystring.new('Hello')
s        #=> "Hello"
s.class  #=> MyString

# Arrayクラスを継承した独自クラスを定義する
class MyArray < Array
  # Arrayクラスを拡張するためのコードを書く
end
a = Myarray.new()
a << 1
a << 2
a        #=> [1, 2]
a.class  #=> MyArray
```
定義済みのクラスそのものにメソッドを追加したり、メソッドの定義を上書きしたりすることもできる。Ruby のクラスは変更に対してオープンなので、「**オープンクラス**」と呼ばれることもある。

Stringクラスに`shuffle`という独自のメソッドを追加する例。
```ruby
irb(main):001* class String
# 文字列をランダムにシャッフルする
irb(main):002*   def shuffle
irb(main):003*     chars.shuffle.join
irb(main):004*   end
irb(main):005> end
=> :shuffle

irb(main):006> s = 'Hello, I am Alice.'
irb(main):007> s.shuffle
=> "lcl .mIoleai, e AH"
irb(main):008> s.shuffle
=> "elo Ae lHc,amI. il"
```
たとえば、Ruby on Rails ではオープンクラスを積極的に活用し、さまざまな独自の便利メソッドを組み込みクラス（Stringクラスや Arrayクラスなど）に追加している。
```ruby
# 文字列をキャメルケースからスネークケースに変換する
'MyString'.underscore #=> "my_string"

# レシーバが引数の配列に含まれていればtrueを返す
numbers = [1, 2, 3]
2.in?(numbers) #=> true
5.in?(numbers) #=> false
```
新しいメソッドを追加するだけでなく、既存のメソッドを上書きすることもできる。既存の実装を上書きして自分が期待する挙動に変更することを「**モンキーパッチ**」と呼ぶ。以下はモンキーパッチをあてる例。
```ruby
# モンキーパッチを充てる前の挙動を確認する
user = User.new('Alice')
user.hello #=> "Hello, Alice!"

# helloメソッドにモンキーパッチをあてて独自の挙動を持たせる
class User
  def hello
    "#{@name}さん、こんにちは！"
  end
end

# メソッドの定義を上書きしたのでhelloメソッドの挙動が変わっている
user.hello #=> "Aliceさん、こんにちは！"
```
実際の開発では外部ライブラリ（gem）に軽微な不具合があったり、微妙に要件に合わない挙動があったりしたときに、モンキーパッチをあてて挙動を変えることがある。

#### 特異メソッド
Ruby はオープンクラスやモンキーパッチによって、既存クラスを拡張したり挙動をへんこうしたりできるが、さらにオブジェクト単位で挙動を変えることもできる。
```ruby
irb(main):001> alice = 'I am Alice.'
=> "I am Alice."
irb(main):002> bob = 'I am Bob.'
=> "I am Bob."

# aliceのオブジェクトにだけ、shuffleメソッドを定義する
irb(main):003* def alice.shuffle
irb(main):004*   chars.shuffle.join
irb(main):005> end

# aliceはshuffleメソッドを持つが、bobは持たない
irb(main):006> alice.shuffle
=> "a.lI cAem i"
irb(main):007> bob.shuffle
(irb):7:in `<main>': undefined method `shuffle' for an instance of String (NoMethodError)
```
上のコードのメソッド定義には、`def alice.shuffle`のように`オブジェクト.メソッド名`という形でメソッドを定義している。これは「alice というオブジェクトに shuffleメソッドを定義します」という意味。そのため、alice にだけ shuffleメソッドが追加され、bob には追加されない。

特定のオブジェクトにだけ紐付くメソッドのことを**特異メソッド**と呼ぶ（英語では singleton method と呼ばれる）。

ただし、数値（Integer と Float）やシンボルなど、特異メソッドを定義できないオブジェクトも存在する。
```ruby
irb(main):001> n = 1
=> 1
irb(main):002* def n.foo
irb(main):003*   'foo'
irb(main):004> end
(irb):2:in `<main>': can't define singleton (TypeError)

irb(main):005> sym = :alice
=> :alice
irb(main):006* def sym.bar
irb(main):007*   'bar'
irb(main):008> end
(irb):6:in `<main>': can't define singleton (TypeError)
```
なお、特異メソッドは次のような方法で定義することもできる。
```ruby
irb(main):001> alice = 'I am Alice.'
=> "I am Alice."
# aliceというオブジェクトに特異メソッドを追加するもう一つの方法
irb(main):002* class << alice
irb(main):003*   def shuffle
irb(main):004*     chars.shuffle.join
irb(main):005*   end
irb(main):006> end
irb(main):007> alice.shuffle
=> " miAlaI .ce"
```

#### クラスメソッドは特異メソッドの一種
クラスメソッドの定義方法と特異メソッドの定義方法を見比べてみる。
```ruby
# クラスメソッドを定義するコード例
class User
  def self.hello
    'Hello.'
  end

  class << self
    def hi
      'Hi.'
    end
  end
end

# 特異メソッドを定義するコード例
alice = 'I am alice.'

def alice.hello
  'Hello.'
end

class << alice
  def hi
    'Hi.'
  end
end
```
クラスメソッドも特異メソッドも定義方法が2つあるが、Ruby で便宜上クラスメソッドと呼んでいるものは、実際は特定のクラスの特異メソッドである。

ちなみに、クラスメソッドは以下のようなコードで定義することもできる。
```ruby
class User
end

# クラス構文の外部でクラスメソッドを定義する方法1
def User.hello
  'Hello.'
end

# クラス構文の外部でクラスメソッドを定義する方法2
class << User
  def hi
    'Hi.'
  end
end

User.hello #=> "Hello."
User.hi    #=> "Hi."
```

#### ダックタイピング
静的型付け言語では実行前にそのメソッドが 100％確実に呼び出せることを保証しようとする。そのため、コンパイル時にオブジェクトのデータ型をチェックし、特定のクラスを継承していたり、特定のインターフェースを実装していたりすればメソッドの呼び出しは可能、そうでなければ NG、と判断する。

一方、動的型付け言語では実行時にそのメソッドが呼び出せるかどうかを判断し、呼び出せないときにエラーが起きる。Ruby が気にするのは「コードを実行するその瞬間に、そのメソッドが呼び出せるか否か」であって、「そのオブジェクトのクラス（データ型）が何か」ではない。

たとえば次のようなメソッドがあったとする。
```ruby
def display_name(object)
  puts "Name is <<#{object.name}>>"
end
```
display_nameメソッドは引数で渡されたオブジェクトが nameメソッドを持っていること（object.name が呼び出せること）を期待している。それ以外のことは何も気にしない。なので以下のようにまったく別々のオブジェクトを渡すことができる。
```ruby
class User
  def name
    'Alice'
  end
end

class Product
  def name
    'A great movie'
  end
end
user = User.new
display_name(user)

# UserクラスとProductクラスはお互いに無関係なクラスだが、display_nameメソッドは何も気にしない
product = Product.new
display_name(product) #=> Name is <<Alice>>

product = Product.new
display_name(product) #=> Name is <<A great movie>>
```
このように、オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイルのことを「**ダックタイピング（duck typing）**」と呼ぶ。これは「もしもそれがアヒルのように歩き、アヒルのように鳴くのなら、それはアヒルである」という言葉に由来するプログラミング用語である。

この考え方に基づくと、静的型付け言語でよく見かける具象クラスと抽象クラスのような区別もなくなる。たとえば以下のようなクラスがあったとする。
```ruby
class Product
  def initialize(name, price)
    @name = name
    @price = price
  end

  def display_text
    # stock?メソッドはサブクラスで必ず実装してもらう想定
    stock = stock? ? 'あり' : 'なし'
    "商品名: #{@name} 価格: #{@price}円 在庫: #{stock}"
  end
end
```
display_textメソッドに注目してみると、このメソッドでは在庫（stock）のあり / なしを表示させる。ただし、在庫の確認は商品の種類によって確認方法が異なるため、サブクラスで必ず stock?メソッドを実装してもらうようにする。スーパークラスの Productクラスでは stock?メソッドを実装しない。以下は Productクラスを継承した DVDクラスを定義するコード例。
```ruby
class DVD < Product
  # 在庫があればtrueを返す
  def stock?
    # （本当はデータベースに問い合わせるなどの処理が必要だがここでは省略）
    true
  end
end
```
Productクラスと DVDクラスのそれぞれについて、実際に display_textメソッドを呼び出してみる。
```ruby
irb(main):016> product = Product.new('A great film', 1000)
# スーパークラスはstock?メソッドを持たないのでエラーが起きる
irb(main):017> product.display_text
(irb):7:in `display_text': undefined method `stock?' for an instance of Product (NoMethodError)

irb(main):018> dvd = DVD.new('An awesome film', 3000)
# サブクラスはstock?メソッドを持つのでエラーが起きない
irb(main):019> dvd.display_text
=> "商品名: An awesome film 価格: 3000円 在庫: あり"
```
Productクラスでは`display_text`の呼び出しに失敗し、DVDクラスでは成功した。とはいえ、表面上ではどちらも普通のクラス定義になっている。Productクラスが抽象クラスで、DVDクラスが具象クラスだと見分ける構文はないし、Productクラスのインスタンスかも普通に行える。Ruby が気にするのはあくまで stock?メソッドが呼び出せるかどうか。よって、stock?メソッドが呼び出せない Productクラスではエラーが発生し、呼び出せる DVDクラスでは正常にメソッドが実行できた。

ただ、何も知らない人が Productクラスを使ったり、継承したりしたときに突然エラーが出てびっくりしてしまうかもしれないので、Productクラス内でも stock?メソッドを定義し、わかりやすいエラーメッセージとともにエラーを発生させる、といった手法を取ることがある。
```ruby
irb(main):001* class Product
irb(main):002*   def initialize(name, price)
irb(main):003*     @name = name
irb(main):004*     @price = price
irb(main):005*   end

irb(main):006*   def display_text
irb(main):007*     stock = stock? ? 'あり' : 'なし'
irb(main):008*     "商品名: #{@name} 価格: #{@price}円 在庫: #{
stock}"
irb(main):009*   end

irb(main):010*   def stock?
# 「サブクラスでstock?メソッドを実装すること」というメッセージとともにエラーを発生させる
irb(main):011*     raise 'must implement stock? in subclass.'
irb(main):012*   end
irb(main):013> end
=> :stock?
irb(main):014> product = Product.new('A great film', 1000)
irb(main):015> product.display_text
(irb):11:in `stock?': must implement stock? in subclass. (RuntimeError)
```
エラーが発生する、という意味では結果は同じだが、エラーが起きた理由がより具体的に表示されるのでデバッグはしやすくなる。`raise`は明示的にエラーを発生させるためのメソッド。

動的型付け言語は事前に実行可能なコードかどうかを検証しないため、実行して初めてエラーに遭遇する、ということが起こり得る。一方でその特性を利点と見なし、ダックタイピングなどのテクニックを使って非常に柔軟で強力なプログラムを書くこともできる。


-------------


## ✍🏻 感想
### ✍🏻 次回はモジュールをインプット
オブジェクト指向言語の根幹となる「クラスの定義」学びましたが、とにかく内容が濃い印象でした。何度も読み返して、クラスを適切に使えるようになりたいですね。次回からモジュールを押さえていきます。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 2 hours 51 min
- Total: 966 hours 31 min
