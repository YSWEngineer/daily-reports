# 2025/02/25(火)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する   
    - 8.1 イントロダクション
    - 8.2 モジュールの概要
    - 8.3 モジュールを利用したメソッド定義（include と extend）
    - 8.4 例題：rainbowメソッドの作成 途中まで

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する
    - 8.4 例題：rainbowメソッドの作成 途中から


------------


## 💡 本日の学び・気付き
### 8.1 イントロダクション
Ruby にはクラスのようでクラスでない、モジュールと呼ばれる仕組みがある。大規模なプログラムでは多かれ少なかれモジュールを利用することになるはず。

####  この章の例題：rainbowメソッド
ターミナル上の文字色を変えるときは以下のような文字列（シングルクオートではなく、ダブルクオートで囲んだもの）を使う。
```ruby
"\e[31mABC\e[0m"
```
irb などで上の文字列を`puts`すると、`ABC`の文字列が赤色で出力される。
```ruby
irb(main):001> puts "\e[31mABC\e[0m"
ABC
```
この文字列は3つのパートに分かれる。各パートの意味は以下のとおり。
- **\e[31m** ＝ 文字色を赤（31）に変更する。
- **ABC** ＝ 出力する文字列（任意）。
- **\e[0m** ＝ 文字色をリセットし、元に戻す。

指定可能な文字色は以下の8色。
- 30 ＝ 黒
- 31 ＝ 赤
- 32 ＝ 緑
- 33 ＝ 黄
- 34 ＝ 青
- 35 ＝ マゼンタ（赤紫）
- 36 ＝ シアン（水色）
- 37 ＝ 白
- 0 ＝ デフォルトの色に戻す

なお、この出力形式のことを「ANSIエスケープシーケンス」と言う。ANSI は、「アンシ、アンシー」と呼ばれる。

#### この章で学ぶこと
この章では以下のような内容を学ぶ。
- **モジュールの概要**
- **モジュールを利用したメソッド定義（include と extend）**
- **モジュールを利用した名前空間の作成**
- **関数や定数を提供するモジュールの作成**
- **状態を保持するモジュールの作成**
- **モジュールに関する高度な話題**

この章でも、しんどくなったら頭の中にインデックスを作る読書スタイルに切り替えること。

### 8.2 モジュールの概要
#### モジュールの用途
モジュールはさまざまな用途で使われる。具体的には以下の用途。
- **継承を使わずにクラスにインスタンスメソッドを追加する、もしくは上書きする（ミックスイン）。**
- **複数のクラスに対して共通の特異メソッド（クラスメソッド）を追加する。**
- **クラス名や定数名の衝突を防ぐために名前空間を作る。**
- **関数的メソッドを定義する**
- **シングルトンオブジェクトのように扱って設定値などを保持する**

#### モジュールの定義
モジュールは以下のような構文で定義する。
```ruby
module モジュール名
  # モジュールの定義（メソッドや定数など）
end
```
たとえば、以下の感じ。
```ruby
# helloメソッドを持つGreetableモジュールを定義
module Greetable
  def hello
    'hello'
  end
end
```
モジュールはクラスと違う特徴がある。
- **モジュールからインスタンスを作成することはできない。**
- **ほかのモジュールやクラスを継承することはできない。**

実際、モジュールで上記のことをやろうとするとエラーが発生する。
```ruby
# モジュールのインスタンスは作成できない
irb(main):006> greetable = Greetable.new
(irb):6:in `<main>': undefined method `new' for module Greetable (NoMethodError)

# ほかのモジュールを継承して新しいモジュールを作ることはできない
irb(main):007* module AwesomeGreetable < greetable
irb(main):008> end
/Users/yoshiwo/.rbenv/versions/3.3.1/lib/ruby/3.3.0/irb/workspace.rb:117:in `eval': (irb):7: syntax error, unexpected '<' (SyntaxError)
```

### 8.3 モジュールを利用したメソッド定義（include と extend）
#### モジュールをクラスに include する
Ruby では**単一継承**を採用している。つまり1つのクラスは1つのスーパークラスしか持てない。しかし、is-a の関係にはなくても、複数のクラスにまたがって同じような機能が必要になるケースは存在する。以下は、メソッドが呼ばれたタイミングでログを残そうとする2つのクラス（製品クラスとユーザクラス）。
```ruby
irb(main):001* class Product
irb(main):002*   def title
irb(main):003*     log 'title is called.'
irb(main):004*     'A great movie'
irb(main):005*   end

irb(main):006*   private

irb(main):007*   def log(text)
# 本来であれば標準ライブラリのLoggerクラスなどを使うべきだが、簡易的にputsで済ませる
irb(main):008*     puts "[LOG] #{text}"
irb(main):009*   end
irb(main):010> end
=> :log

irb(main):011* class User
irb(main):012*   def name
irb(main):013*     log 'name is called'
irb(main):014*     'Alice'
irb(main):015*   end

irb(main):016*   private

# このメソッドの実装はProductクラスのlogメソッドとまったく同じ
irb(main):017*   def log(text)
irb(main):018*     puts "[LOG] #{text}"
irb(main):019*   end
irb(main):020> end
=> :log

irb(main):021> product = Product.new
irb(main):022> product.title
[LOG] title is called.
=> "A great movie"

irb(main):023> user = User.new
irb(main):024> user.name
[LOG] name is called
=> "Alice"
```
ここで大事なのは、コードが重複しているからといって安易に継承を使ったりしてはいけないこと。「製品はユーザである」または「ユーザは製品である」という関係（is-a の関係）が成り立たないのであれば、継承の使用は避けるべき。

継承は使えないが、「ログを出力する」という共通の機能は持たせたい、そんなときに選択肢として挙がるのがモジュール。モジュールにログ出力のメソッドを定義し、クラスでそのモジュールを`include`すると、モジュールで定義したメソッドがインスタンスメソッドとして呼び出せるようになる。
```ruby
# ログ出力用のメソッドを提供するモジュール
# 「ログ出力できる（log + able）」という意味でLoggableという名前を付けた
irb(main):001* module Loggable
irb(main):002*   def log(text)
irb(main):003*     puts "[LOG] #{text}"
irb(main):004*   end
irb(main):005> end
=> :log

irb(main):006* class Product
# 上で作ったモジュールをincludeする
irb(main):007*   include Loggable

irb(main):008*   def title
# logメソッドはLoggableモジュールで定義したメソッド
irb(main):009*     log 'title is called.'
irb(main):010*     'A great movie'
irb(main):011*   end
irb(main):012> end
=> :title

irb(main):013* class User
# こちらも同じようにincludeする
irb(main):014*   include Loggable

irb(main):015*   def name
# Loggableモジュールのメソッドが使える
irb(main):016*     log 'name is called.'
irb(main):017*     'Alice'
irb(main):018*   end
irb(main):019> end
=> :name

irb(main):020> product = Product.new
irb(main):021> product.title
[LOG] title is called.
=> "A great movie"

irb(main):022> user = User.new
irb(main):023> user.name
[LOG] name is called.
=> "Alice"
```
Loggableモジュールを`include`することで、モジュールに定義した logメソッドを Productクラスでも Userクラスでも呼び出すことができた。このモジュールがあれば、これら2つのクラスに限らず、ほかのクラスでも継承関係を気にすることなくログ出力の機能を持つことができる。

このようにモジュールをクラスに`include`して機能を追加することを**ミックスイン**と言う。ミックスイン先のクラスは基本的にどんなクラスでもOK。また1つのクラスに複数のモジュールをミックスインすることもできる。Ruby では、ミックスインを利用することで多重継承に似た仕組みを実現している。

ただ、先程のコードでは、logメソッドが publicメソッドになり、クラスの外から呼び出せてしまう。
```ruby
irb(main):024> product.log 'public?'
[LOG] public?
```
publicメソッドにする必要がなければ、モジュール側で privateメソッドとして定義しておく。こうすることで`include`したクラスでもそのメソッドが privateメソッドとして扱われる。
```ruby
irb(main):025* module Loggable
# logメソッドはprivateメソッドにする
irb(main):026*   private

irb(main):027*   def log(text)
irb(main):028*     puts "[LOG] #{text}"
irb(main):029*   end
irb(main):030> end
=> :log

irb(main):031* class Product
irb(main):032*   include Loggable

irb(main):033*   def title
irb(main):034*     log 'title is called.'
irb(main):035*     'A great movie'
irb(main):036*   end
irb(main):037> end
=> :title

irb(main):038* class User
irb(main):039*   include Loggable

irb(main):040*   def name
irb(main):041*     log 'name is called.'
irb(main):042*     'Alice'
irb(main):043*   end
irb(main):044> end
=> :name

irb(main):045> product = Product.new
# logメソッドはprivateメソッドなので外部から呼び出せない
irb(main):046> product.log 'public?'
(irb):46:in `<main>': private method `log' called for an instance of Product (NoMethodError)
```

#### include先のメソッドを使うモジュール
Ruby は動的型付け言語であるため「メソッドを実行する瞬間にそのメソッドが呼び出せれば良い」という考え方でプログラムが書ける。この考え方はモジュールにも適用できる。以下は`price`というメソッドが include先に定義されていることを前提としたモジュール（値札を返すモジュール）の定義。
```ruby
irb(main):001* module Taggable
irb(main):002*   def price_tag
# priceメソッドはinclude先で定義されているはず、という前提
irb(main):003*     "#{price}円"
irb(main):004*   end
irb(main):005> end
=> :price_tag

irb(main):006* class Product
irb(main):007*   include Taggable

irb(main):008*   def price
irb(main):009*     1000
irb(main):010*   end
irb(main):011> end
=> :price

irb(main):012> product = Product.new
irb(main):013> product.price_tag
=> "1000円"
```
Taggableモジュールの price_tagメソッドは、Productクラスの priceメソッドと連携して目的の処理を実行することができた。

#### モジュールを extend する
モジュールを利用したメソッド定義のもう一つの方法として`extend`がある。extend を使うと、モジュール内のメソッドをそのクラスの特異メソッド（つまりクラスメソッド）にすることができる。
```ruby
# モジュールの定義はincludeするときと同じ
irb(main):014* module Loggable
irb(main):015*   def log(text)
irb(main):016*     puts "[LOG] #{text}"
irb(main):017*   end
irb(main):018> end
=> :log

irb(main):019* class Product
# Loggableモジュールのメソッドを特異メソッド（クラスメソッド）として追加する
irb(main):020*   extend Loggable

irb(main):021*   def self.create_products(names)
# logメソッドをクラスメソッド内で呼び出す
# （つまりlogメソッド自体もクラスメソッドになっている）
irb(main):022*     log 'create_products is called.'
irb(main):023*   end
irb(main):024> end

# クラスメソッド経由でlogメソッドが呼び出される
irb(main):025> Product.create_products([])
[LOG] create_products is called.

# Productクラスのクラスメソッドとして直接呼び出すことも可能
irb(main):026> Product.log('Hello.')
[LOG] Hello.
```

### 8.4 例題：rainbowメソッドの作成
#### 実装の方針を検討する
今回は Rainbowable という名前のモジュールを作り、そこに rainbowメソッドを実装する。
```ruby
module Rainbow
  def rainbow
    # rainbowメソッドの実装
  end
end
```
このモジュールを Stringクラスや Arrayクラスに`include`すれば、どちらのクラスでも rainbowメソッドが使えるようになる。
```ruby
String.include Rainbowable
Array.include Rainbowable
```
上記のコード例では`クラス名.include`の形式でモジュールを`include`したが、以下のようにクラス構文の内部で`include`してもかまわない。
```ruby
class String
  include Rainbowable
end
```

#### テストコードを準備する
testディレクトリに rainbowable_test.rb を作成する。作成したらエディタで rainbowable_test.rbファイルを開き、次のコードを書く。
```ruby
require 'minitest/autorun'
require_relative '../lib/rainbowable'

class RainbowableTest < Minitest::Test
  def test_rainbow
    # とりあえずモジュールが参照できることを確認する
    assert Rainbowable
  end
end
```
libディレクトリに rainbowable.rb を作成する。作成したら rainbowable.rb を開き、Rainbowableモジュールを定義する。
```ruby
module Rainbowable
  def rainbow
    # 実装は後で
  end
end
```
テストを実行し、パスすることを確認する。
```shell
~/ruby-book % ruby test/rainbowable_test.rb
Run options: --seed 40162

# Running:

.

Finished in 0.000841s, 1189.0605 runs/s, 1189.0605 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
```


-------------


## ✍🏻 感想
### ✅ 「クラス」と「モジュール」について
- **クラス**
  - オブジェクトを作成するための設計図のようなもので、状態（属性）と動作（メソッド）を持つ。
   - インスタンス（オブジェクト）を生成できる。
- **モジュール**
  - 関連するメソッドや定数の集まりで、直接インスタンス化ができない。
  - 複数のクラスで共通の機能を再利用するために`include`して使う。

ざっと自分の中で「クラス（Class）」と「モジュール（Module）」についてざっとまとめました（もし認識が間違っていたらご指摘ください🙏🏻）。改めて、クラスは「何かを作る工場の設計図」、モジュールは「特定の機能をまとめたツールキット」のようなイメージだと思っています。

クラスとモジュールはそれぞれ異なる目的と使い方があると思いますが、両方を上手に使い分けることで、コードに幅をもたらせることができるのでは？と考えました🤔💭

------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 55 min
- Total: 970 hours 26 min
