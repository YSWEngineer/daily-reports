# 2025/02/08(土)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第6章  正規表現を理解する
    - 6.3 Ruby における正規表現オブジェクト
    - 6.4 例題：Ruby のハッシュ記法を変換する
    - 6.5 正規表現オブジェクトについてもっと詳しく
    - 6.6 この章のまとめ


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第7章  クラスの作成を理解する
   - 7.1 イントロダクション


------------


## 💡 本日の学び・気付き
### 6.3 Ruby における正規表現オブジェクト
正規表現オブジェクトはスラッシュでパターンを囲んで作成する（正規表現リテラル）
```
/正規表現/
```
正規表現オブジェクトを作成するコード例。正規表現は Regexp（レギュラー エクスプレッション）クラスのオブジェクトになる。
```ruby
r = /\d{3}-\d{4}/
irb(main):021> r.class
=> Regexp
```
文字列と正規表現のマッチ（正規表現で指定されたパターンに文字列の一部、または全体が合致すること）を試みる方法はいくつかあるが、その1つが`=~`。`=~`を使うと、正規表現がマッチした場合は文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなかった場合は nil が返る。
```ruby
# マッチした場合は最初にマッチした文字列の開始位置が返る（つまり真）
irb(main):022> '123-4567' =~ /\d{3}-\d{4}/
=> 0

# マッチしない場合は nil が返る（つまり偽）
irb(main):023> 'hello' =~ /\d{3}-\d{4}/
=> nil
```
`=~`の戻り値は、if文などの条件分岐でもよく使われる。
```ruby
# if文で=~を使うとマッチしたかどうかを判別できる
irb(main):026* if '123-4567' =~ /\d{3}-\d{4}/
irb(main):027*   puts 'マッチしました'
irb(main):028* else
irb(main):029*   puts 'マッチしませんでした'
irb(main):030> end
マッチしました
```
また、`=~`は文字列と正規表現を入れ替えても同じ結果になる（ただし、名前付きキャプチャを使うときは動作に違いが出る）。
```ruby
# 左辺に正規表現を置いても結果は同じ
irb(main):031> /\d{3}-\d{4}/ =~ '123-4567'
=> 0
irb(main):032> /\d{3}-\d{4}/ =~ 'hello'
=> nil
```
`!~`を使うとマッチしなかったときに true を、マッチしたときに false を返す。
```ruby
# マッチしなければtrue
irb(main):033> 'hello' !~ /\d{3}-\d{4}/
=> true

# ↑文字列と正規表現を入れ替えても同じ結果になる
irb(main):034> /\d{3}-\d{4}/ !~ 'hello'
=> true

# マッチしなければfalse
irb(main):035> '123-4567' !~ /\d{3}-\d{4}/
=> false
```

#### 復習：おもな正規表現のメタ文字
|メタ文字   |メタ文字の意味   |
|:---:|:---|
|**[ ]**   |いずれか1文字を表す文字クラスを作る   |
|**[^ ]**   |〜以外の任意の1文字を表す文字クラスを作る   |
|**-**   |[ ]内で使われると文字の範囲を表す   |
|**.**   |任意の1文字（ただし改行は除く）を表す   |
|**( )**   |グループ化やキャプチャで使用する   |
|**?**   |直前の文字やパターンが1回、もしくは0回現れる   |
|**\***   |直前の文字やパターンが0回以上連続する   |
|**+**   |直前の文字やパターンが1回以上連続する   |
|**{n,m}**   |直前の文字やパターンが1回以上連続する   |
|**\|**   |OR条件を作る   |
|**^**   |行頭を表す   |
|**$**   |行末を表す   |
|**\\**   |メタ文字をエスケープしたり、\n や \w といったほかのメタ文字の一部になったりする   |

#### Rubular で視覚的にマッチする文字列を確認する
正規表現をチェックしたい場合は Rubular というオンラインツールがある。Rubular を使うと検索対象の文字列や正規表現を次から次に変えながらマッチする文字列を確認できるため非常に便利。

ただし、検索対象の文字列が外部に送信されるので、実在するパスワードやクレジットカードの番号などは文字列に入力しないこと。

また、個人で運営されているオンラインツールであるため、突然閉鎖されたり仕様が大きく変わったりする可能性もある。

#### 正規表現のキャプチャを利用する
正規表現にはキャプチャと呼ばれる便利な機能がある。キャプチャは`()`を使い、抜き出したい部分を指定する。Ruby 上でもキャプチャを使って年月日の数字だけをそれぞれ抜き出すことができる。
```ruby
irb(main):036> text = '私の誕生日は1977年7月17日です。'
irb(main):037> m = /(\d+)年(\d+)月(\d+)日/.match(text)
=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
irb(main):038> m[1]
=> "1977"
irb(main):039> m[2]
=> "7"
irb(main):040> m[3]
=> "17"
```
キャプチャを活用する方法の1つは matchメソッドを使うこと。文字列が正規表現にマッチすると、MatchDataオブジェクトが返る。マッチしない場合は nil が返る。

この性質を使い、条件分岐の中で真偽値の判定とローカル変数への代入を同時にやってしまうコードがよく使われる。
```ruby
text = '私の誕生日は1977年7月17日です。'
# 真偽値の判定とローカル変数への代入を同時にやってしまう
if m = /(\d+)年(\d+)月(\d)日/.match(text)
  # マッチした場合の処理（ローカル変数のmを使う）
else
  # マッチしなかった場合の処理
end
```
MatchData は`[]`を使い、正規表現の処理結果を配列と同じような方法で取得できる。
```ruby
irb(main):041> text = '私の誕生日は1977年7月17日です。'
irb(main):042> m = /(\d+)年(\d+)月(\d+)日/.match(text)
=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
# マッチした部分全体を取得する
irb(main):043> m[0]
=> "1977年7月17日"

# キャプチャの1番目を取得する
irb(main):044> m[1]
=> "1977"

# キャプチャの2番目から2個取得する
irb(main):045> m[2, 2]
=> ["7", "17"]

# 最後のキャプチャを取得する
irb(main):046> m[-1]
=> "17"

# Rangeを使って取得する
irb(main):047> m[1..3]
=> ["1977", "7", "17"]
```
matchメソッドは Stringクラスと Regexpクラスの両方に定義されているため、文字列と正規表現オブジェクトを入れ替えても同じように動作する。
```ruby
irb(main):048> text = '私の誕生日は1977年7月17日です。'
irb(main):049> m = text.match(/(\d+)年(\d+)月(\d+)日/)
=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
```

#### キャプチャに名前を付ける
キャプチャでは、結果を連番で取得する必要があるため「何番目の何の値か」ということをプログラマが意識しなくてはならない。キャプチャには`(?<name>)`というメタ文字を使って名前を付けることができる。
```ruby
(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日
```
連番ではなく名前でキャプチャの結果を取得することができるため、「何番目が何の値か」を気にしなくてよい。
```ruby
irb(main):050> text = '私の誕生日は1977年7月17日です。'
irb(main):051> m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
=> #<MatchData "1977年7月17日" year:"1977" month:"7" day:"17">
# シンボルで名前を指定してキャプチャの結果を取得する
irb(main):052> m[:year]
=> "1977"
irb(main):053> m[:month]
=> "7"
irb(main):054> m[:day]
=> "17"

# 文字列で指定することもできる
irb(main):055> m['year']
=> "1977"

# 連番で指定することもできる
irb(main):056> m[2]
=> "7"
```
名前付きキャプチャを使った正規表現にはもう一つの機能がある。それは、左辺に正規表現リテラルを、右辺に文字列を置いて =~演算子を使うと、キャプチャの名前がそのままローカル変数に割り当てられる。
```ruby
irb(main):057> text = '私の誕生日は1977年7月17日です。'
=> "私の誕生日は1977年7月17日です。"
# キャプチャの名前がそのままローカル変数に割り当てられる
irb(main):058* if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
irb(main):059*   puts "#{year}/#{month}/#{day}"
irb(main):060> end
1977/7/17
```

#### 組み込み変数でマッチの結果を取得する
Ruby には`$`で始まる特殊な変数(組み込み変数）が存在する。=~演算子や matchメソッドを使うと、いくつかの組み込み変数にマッチした結果が代入される。組み込み変数でも MatchDataオブジェクトとほとんど同等の情報を得ることができる。
```ruby
text = '私の誕生日は1977年7月17日です。'

# =~やmatchメソッドを使うとマッチした結果が組み込み変数に代入される
text =~ /(\d+)年(\d+)月(\d+)日/

# MatchDateオブジェクトを取得する
irb(main):067> $~
=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

# マッチした部分全体を取得する
irb(main):068> $&
=> "1977年7月17日"

# 1番目〜3番目のキャプチャを取得する
irb(main):069> $1
=> "1977"
irb(main):070> $2
=> "7"
irb(main):071> $3
=> "17"

# 最後のキャプチャ文字列を取得する
irb(main):072> $+
=> "17"
```

#### 正規表現と組み合わせると便利な Stringクラスのメソッド
Stringクラスには正規表現と組み合わせると便利に使えるメソッドがいくつか用意されている。

##### scan
sancメソッドは引数で渡した正規表現にマッチする部分を配列に入れて返す。
```ruby
irb(main):073> '123 456 789'.scan(/\d+/)
=> ["123", "456", "789"]
```
正規表現に`()`があると、キャプチャされた部分が配列の配列になって返ってくる。
```ruby
irb(main):074> '1977年7月17日 2021年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
=> [["1977", "7", "17"], ["2021", "12", "31"]]
```
グループ化はしたいが、キャプチャはしたくない場合は`(?:)`というメタ文字を使う。
```ruby
irb(main):075> '1977年7月17日 2021年12月31日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)
=> ["1977年7月17日", "2021年12月31日"]
```
↑なお、`\d+年\d+月\d+日`と書いたほうが簡潔な正規表現になる。
```ruby
irb(main):076> '1977年7月17日 2021年12月31日'.scan(/\d+年\d+月\d+日/)
=> ["1977年7月17日", "2021年12月31日"]
```

##### [ ]、slice、slice!
`[ ]`に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出す。
```ruby
irb(main):077> text = '郵便番号は123-4567です'
irb(main):078> text[/\d{3}-\d{4}/]
=> "123-4567"
```
マッチする部分が複数ある場合は、最初にマッチした文字列が返る。
```ruby
irb(main):079> text = '123-4567 456-7890'
irb(main):080> text[/\d{3}-\d{4}/]
=> "123-4567"
```
キャプチャを使うと第2引数で何番目のキャプチャを取得するか指定できる。
```ruby
text = '誕生日は1977年7月17日です'

# 第2引数がないとマッチした部分全体が返る
irb(main):082> text[/(\d+)年(\d+)月(\d+)日/]
=> "1977年7月17日"

# 第2引数を指定して3番目のキャプチャを取得する
irb(main):083> text[/(\d+)年(\d+)月(\d+)日/, 3]
=> "17"
```
名前付きキャプチャであれば名前で指定することもできる。
```ruby
text = '誕生日は1977年7月17日です'

# シンボルでキャプチャの名前を指定する
irb(main):084> text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, :day]
=> "17"

# 文字列でキャプチャの名前を指定する
irb(main):085> text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, 'day']
=> "17"
```
sliceメソッドは`[ ]`のエイリアスメソッド。
```ruby
irb(main):086> text = '郵便番号は123-4567です'
irb(main):087> text.slice(/\d{3}-\d{4}/)
=> "123-4567"

irb(main):088> text = '誕生日は1977年7月17日です'
irb(main):089> text.slice(/(\d+)年(\d+)月(\d+)日/, 3)
=> "17"
```
slice! にするとマッチした部分が文字列から破壊的に取り除かれる。
```ruby
irb(main):093> text = '郵便番号は123-4567です'
=> "郵便番号は123-4567です"
irb(main):094> text.slice!(/\d{3}-\d{4}/)
irb(main):095> text
=> "郵便番号はです"
```

##### split
split に正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返す。
```ruby
text = '123,456-7890'

# 文字列で区切り文字を指定する
irb(main):091> text.split(',')
=> ["123", "456-7890"]

# 正規表現を使ってカンマまたはハイフンを区切り文字に指定する
irb(main):092> text.split(/,|-/)
=> ["123", "456", "7890"]
```

##### gsub、gsub!
gsubメソッドを使うと、第1引数の正規表現にマッチした文字列を第2引数の文字列で置き換える。
```ruby
text = '123,456-789'

# 第1引数に文字列を渡すと、完全一致する文字列を第2引数で置き換える
irb(main):097> text.gsub(',', ':')
=> "123:456-789"

# 正規表現を渡すと、マッチした部分を第2引数で置き換える
irb(main):098> text.gsub(/,|-/, ':')
=> "123:456:789"

# カンマはコロンに、ハイフンはスラッシュに置き換える
irb(main):099> hash = { ',' => ':', '-' => '/' }
irb(main):100> text.gsub(/,|-/, hash)
=> "123:456/789"
```
gsub!メソッドは文字列の内容を破壊的に置換する。
```ruby
text = '123,456-789'
irb(main):101> text.gsub!(/,|-/, ':')
irb(main):102> text
=> "123:456:789"
```

### 6.4 例題：Ruby のハッシュ記法を変換する
#### ハッシュ記法変換プログラムを実装する
- `\w`は`[a-z0-9_]`とほぼ同じ意味を持つメタ文字。
- `*`は「直前の文字が0個以上」を表すメタ文字。

### 6.5 正規表現オブジェクトについてもっと詳しく
#### 正規表現オブジェクトを作成する様々な方法
正規表現オブジェクトを作成する方法は`//`だけでなく、いくつか方法がある。1つは Regexp.new（エイリアスメソッドは Regexp.compile）の引数にパターンの文字列を渡す方法。
```ruby
# /\d{3}-\d{4}/と書いた場合と同じ
Regexp.new('\d{3}-\d{4}')
```
`%r`を使う方法。以下の3つの正規表現はどれも同じもの。
```ruby
# スラッシュで囲むと、スラッシュをエスケープする必要がある
/https:\/\/example\.com/

# %rを使うとスラッシュをエスケープしなくて良い
%r!https://example\.com!

# !ではなく{}を区切り文字にする
%r{https://example\.com}
```
`/ /`や`%r`の中で`#{}`を使うと式の値を埋め込むことができる。
```ruby
pattern = '\d{3}-\d{4}'
# 変数が展開されるので/\d{3}-\d{4}/と書いたことと同じになる
irb(main):002> '123-4567' =~ /#{pattern}/
=> 0
```

#### case文で正規表現を使う
正規表現は case文の when節で使うこともできる。case節で指定した文字列が when節で指定した正規表現にマッチすると when節の処理が実行される。
```ruby
text = '03-1234-5678'
irb(main):022* case text
irb(main):023* when /^\d{3}-\d{4}$/
irb(main):024*   puts '郵便番号です'
irb(main):025* when /^\d{4}\/\d{1,2}\/\d{1,2}$/
irb(main):026*   puts '日付です'
irb(main):027* when /^\d+-\d+-\d+$/
irb(main):028*   puts '電話番号です'
irb(main):029> end
電話番号です
```
case文の when節で正規表現を使った場合も、`$&`や`$~`でマッチした結果を参照できる。
```ruby
irb(main):030> $&
=> "03-1234-5678"
irb(main):031> $~
=> #<MatchData "03-1234-5678">
```

#### 正規表現オブジェクト作成時のオプション
正規表現オブジェクトの作成時にはいくつかのオプションを渡すことができる。
```
/正規表現/オプション
```
iオプション。アルファベットの大文字と小文字の違いを無視してマッチする。
```ruby
# iオプションを付けると大文字小文字を区別しない
irb(main):032> 'HELLO' =~ /hello/i
=> 0

# %rを使った場合も最後にオプションを付けられる
irb(main):033> 'HELLO' =~ %r{hello}i
=> 0
```
Regexp.new を使う場合は、Regexp::IGNORECASE という定数を渡す。
```ruby
irb(main):034> regexp = Regexp.new('hello', Regexp::IGNORECASE)
irb(main):035> 'HELLO' =~ regexp
=> 0
```
mオプションを使うと、任意の文字を表すドット（.）が改行文字にもマッチするようになる。
```ruby
# mオプションがないと.は改行文字にマッチしない
irb(main):036> "Hello\nBye" =~ /Hello.Bye/
=> nil

# mオプションを付けると.が改行文字にもマッチする
irb(main):037> "Hello\nBye" =~ /Hello.Bye/m
=> 0
```
Regexp.new を使う場合は、Regexp::MULTILINE という定数を渡す。
```ruby
irb(main):038> regexp = Regexp.new('Hello.Bye', Regexp::MULTILINE)
irb(main):039> "Hello\nBye" =~ regexp
=> 0
```
xオプションを使うと、空白文字（半角スペースや改行文字）が無視され、# を使って正規表現中にコメントが書けるようになる。
```ruby
# xオプションを付けたので改行やスペースが無視され、コメントも書ける
irb(main):046/ regexp = /
irb(main):047/   \d{3} # 郵便番号の先頭3桁
irb(main):048/   -     # 区切り文字のハイフン
irb(main):049/   \d{4} # 郵便番号の末尾4桁
irb(main):050> /x
irb(main):051> '123-4567' =~ regexp
=> 0
```

#### Regexp.last_match でマッチの結果を取得する
Regexp.last_matchメソッドを使うと、=~演算子などで最後にマッチした結果を MatchDateオブジェクトとして取得できる。
```ruby
text = '私の誕生日は1977年7月17日です。'

# =~演算子などを使うと、マッチした結果をRegexp.last_matchで取得できる
text =~ /(\d+)年(\d+)月(\d+)日/

# MatchDateオブジェクトを取得する
irb(main):060> Regexp.last_match
=> #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

# マッチした部分全体を取得する
irb(main):061> Regexp.last_match(0)
=> "1977年7月17日"

# 1番目〜3番目のキャプチャを取得する
irb(main):065> Regexp.last_match(1)
=> "1977"
irb(main):066> Regexp.last_match(2)
=> "7"
irb(main):067> Regexp.last_match(3)
=> "17"

# 最後のキャプチャ文字列を取得する
irb(main):068> Regexp.last_match(-1)
=> "17"
```
`$~`のような組み込み変数より可読性は上がるが、多用するのは避けた方が良い。

#### 組み込み変数を書き換えない match?メソッド
match?メソッドは文字列が正規表現にマッチすれば true、マッチしなければ false を返す。ただし、マッチした場合でも組み込み変数や Regexp.last_match の内容を書き換えない。そのため、=~演算子や matchメソッドよりも高速に動作する。
```ruby
# マッチすればtrueを返す
irb(main):001> /\d{3}-\d{4}/.match?('123-4567')
=> true

# マッチしても組み込み変数やRegexp.last_matchを書き換えない
irb(main):002> $~
=> nil
irb(main):003> Regexp.last_match
=> nil

# 文字列と正規表現を入れ替えてもOK
irb(main):004> '123-4567'.match?(/\d{3}-\d{4}/)
=> true
```


-------------


## ✍🏻 感想
### 🧙🏻‍♂️ 正規表現との付き合い方を知る
第6章では正規表現の奥深さを知ることができました。Ruby 以外の環境でも正規表現の基礎は活用できるので、さまざまな場面で役立つのでは？と感じています。その深さゆえに、正規表現とはのんびり付き合って、少しずつ慣れたり理解していきたいですね☺️


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 5 hours 57 min
- Total: 935 hours 23 min
