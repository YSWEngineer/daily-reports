# 2026/02/09(月)
## 📚 プラクティス『🛠️💻 lsコマンドを作る4』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外にも便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名・メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>

<details><summary>📌 要件 ※ 随時、追加・変更あり</summary>

- [ ] `-l`オプションが指定された場合は、各ファイルについて「詳細情報（long format）」を一行ずつ表示すること
- [ ] `-l`オプションが指定されていない場合は、これまで通りファイル名のみを表示すること
- [ ] 表示する詳細情報は、以下の内容を含ませること
  - [ ] ファイルタイプ
  - [ ] ファイルモード
  - [ ] リンク数
  - [ ] 所有者
  - [ ] 所有グループ
  - [ ] サイズ
  - [ ] タイムスタンプ（更新日時）
  - [ ] ファイル名もしくはディレクトリ名
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 完成したコードは GitHub の Pull Request として提出すること

</details>

<details><summary>📍 処理の流れ ※ 随時、追加・変更あり</summary>

1. コマンドライン引数から`-l`オプションの有無を判定する

2. 対象のディレクトリのファイル一覧を配列として取得する

3. `-l`オプションが指定されていない場合 → これまで通り、ファイル名の配列をそのまま表示する

4. `-l`オプションが指定されている場合 → ①配列の各要素（各ファイル）について詳細情報を取得する / ②取得した複数の属性を一行の文字列に整形する

5. 整形済みの各行を上から順に標準出力へ表示させる
</details>

<details><summary> 🧩 タスクばらし ※ 随時、追加・変更あり</summary>

- [ ] タスク1：コマンドライン引数を解析し、`-l`オプションの有無を取得する
- [ ] タスク2：対象のディレクトリのファイル一覧を配列として取得する
- [ ] タスク3：「一つのファイルについて、どんな情報が取れるのか」を調べる
  - [x] ファイルタイプ
  - [x] ファイルモード
  - [ ] リンク数
  - [ ] 所有者
  - [ ] 所有グループ
  - [ ] サイズ
  - [ ] タイムスタンプ（更新日時）
- [ ] タスク4：取得した「詳細情報（各属性）」を表示する
  - [ ] 先ずはバラバラに値を取り出せるようにする
- [ ] タスク5：複数の属性を整形して表示する
  - [ ] 横に並べて一行にする
- [ ] タスク6：タスク3〜5で行った処理を全てのファイルに対して適用する
  - [ ] 先ずは1ファイルで成功させる
  - [ ] 次に`each`で各ファイルに処理を適用させる
- [ ] タスク7：`-l`オプションが指定されていないときに、`ls`コマンドと同じ挙動になることを確認する
- [ ] タスク8：rubocop-fjord に通す
- [ ] タスク9：提出
  - [ ] 作成した lsコマンドを Pull Request として提出
  - [ ] 提出物に、`ls -l`コマンドの実行結果と、OS標準（macなど自分の使ってるOS）の`ls -l`コマンドの実行結果のスクリーンショットを併記して貼る
  - [ ] rubocop-fjord のチェックが全てパスした画面をスクショして添付
</details>


---


## 🧑🏻‍💻 本日の取り組み
### 📚 プラクティス『🛠️💻 lsコマンドを作る4』 
- ハードリンク（hard link）ついて調べる


---


## ⏭️ 次回
### 📚 プラクティス『lsコマンドを作る4』
- ハードリンクやディレクトリの`nlink`を実際に観察する
- 観察結果から「`nlink`とは何か」を理解する
- `ls -l`の`nlink`の表示を Ruby で実装する


---


### 💡 本日の学び・気付き
#### ① ハードリンク（hard link）とは？
ハードリンクとは、同じ**データ本体（inode）を指す複数の名前**のこと。
ファイルには次の2つがある。
- 中身（OS が保持する実体 = inode ）
- 名前（ファイル名。ディレクトリの中にある「ラベル」）

通常は、
```shell
report.txt（ファイル名） → データ（実体）
```
ハードリンクを作ると、
```shell
report.txt
backup.txt  # どちらも同じデータ（実体）を参照する別名
```
片方を削除しても、もう片方が残っていればデータ（実体）は消えない。

#### ② 何故「複数の名前」を持てるのか？
**理由1：UNIX が「名前」と「中身」を分離して設計しているため。**
- ディレクトリ内の名前（エントリ） = 実体への参照
- 実体（inode） = ファイル本体

名前はラベルなので、複数付けることが可能。

**理由2：古くからバックアップ・管理用途で使われていたため。**
- 同じ内容を別の場所にに見せたい
- 別名で管理したい
- 実態を簡単に消されないようにしたい

現代ではシンボリックリンクが主流になったが、UNIX の仕組みとしてハードリンクは今も残っている。

#### ③ ディレクトリのリンク数とは？
**結論：そのディレクトリを指す参照（リンク）の総数。**
ディレクトリには最低でも次の2つが存在する。
1. 自分自身を指す`.`
2. 親ディレクトリから自分を指すリンク（親の中の自分の名前）

これで最低でも**2つのリンク**になる。
さらに子ディレクトリがあると、それぞれの`..`が「親ディレクトリ」を指すため、その分リンク数が増える。

#### 🔗 参考リンク
1. [Hard link - Wikipedia](https://en.wikipedia.org/wiki/Hard_link?utm_source=chatgpt.com)

2. [What is a Hard Link? Explained | Lenovo US](https://www.lenovo.com/us/en/glossary/hard-link/?orgRef=https%253A%252F%252Fchatgpt.com%252F&utm_source=chatgpt.com)

3. [Difference between Hard Link and Soft Link - GeeksforGeeks](https://www.geeksforgeeks.org/operating-systems/difference-between-hard-link-and-soft-link/?utm_source=chatgpt.com)

4. [ハードリンクとシンボリックリンクを説明できるようになる](https://zenn.dev/levtech/articles/hard-symbolic-link?utm_source=chatgpt.com)

5. [Stack Overflow: Hard link vs Symbolic link](https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link/79764573#79764573)

---


## ✍🏻 感想
### 🫠 理解度4割5分
ハードリンクの概念を掴むために海外記事を中心に調べましたが、抽象度が高く、理解に時間がかかりました。ひとまず「こういうことかな？」という形で自分の言葉にまとめましたが、手応えは弱いです。

次は実際にファイル・ハードリンク・ディレクトリ・子ディレクトリを作成して、`nlink`の変化を観察しながら理解を深めます。実装までもう少しかかりそうですが、着実に前進していきます。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 hours 38 min
- Total: 1480 hours 00 min
