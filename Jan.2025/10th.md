# 2025/01/10(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [ ] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [ ] 2.12 そのほかの基礎知識
   - [ ] 2.13 この章のまとめ
- [ ] 第3章  テストを自動化する
   - [ ] 3.1 イントロダクション
   - [ ] 3.2 Minitest の基本
   - [ ] 3.3 FizzBuzzプログラムのテスト自動化
   - [ ] 3.4 この章のまとめ
- [ ] 第4章  配列や繰り返し処理を理解する
   - [ ] 4.1 イントロダクション
   - [ ] 4.2 配列
   - [ ] 4.3 ブロック
   - [ ] 4.4 ブロックを使う配列のメソッド
   - [ ] 4.5 範囲（Range）
   - [ ] 4.6 例題：RGB変換プログラムを作成する
   - [ ] 4.7 配列についてもっと詳しく
   - [ ] 4.8 ブロックについてもっと詳しく
   - [ ] 4.9 範囲（Range）についてもっと詳しく
   - [ ] 4.10 さまざまな繰り返し処理
   - [ ] 4.11 繰り返し処理用の制御構造
   - [ ] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [ ] 5.1 イントロダクション
   - [ ] 5.2 ハッシュ
   - [ ] 5.3 シンボル
   - [ ] 5.4 続・ハッシュについて
   - [ ] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第2章  Ruby の基礎を理解する
      - 2.10 真偽値と条件分岐についてもっと詳しく （途中から） 〜 2.11 メソッド定義についてもっと詳しく

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第2章  Ruby の基礎を理解する
      - 2.12 そのほかの基礎知識 〜


------------


## 💡 本日の学び・気付き
### 🍒 プロを目指す人のためのRuby入門 <改訂2版>
#### 2.10 真偽値と条件分岐についてもっと詳しく
##### 優先順位が低い and、or、not
`&&`、`||`、`!`に近い働きをする演算子として`and`、`or`、`not`がある。
```ruby
irb(main):001> t1 = true
=> true
irb(main):002> f1 = false
=> false
irb(main):003> t1 and f1
=> false
irb(main):004> t1 or f1
=> true
irb(main):005> not t1
=> false
```
`and`、`or`、`not`は演算子の優先順位が低いため、`&&`、`||`、`!`と同じように使うことはできない。
```
高い  !
      &&
      ||
      not
低い  and or
```
`&&`、`||`と異なり、`and`と`or`は優先順位に違いがない。そのため`( )`を使わない場合は左から右に順番に真偽値が評価されていく。
```ruby
irb(main):006> t1 = true
=> true
irb(main):007> t2 = true
=> true
irb(main):008> f1 = false
=> false
irb(main):009> t1 || t2 && f1
=> true
irb(main):010> t1 or t2 and f1
=> false

# ↑以下の式と同じになる
# &&は||よりも優先順位が高い
t1 || (t2 && f1)
# andとorの優先順位は同じなので、左から順に評価される
(t1 or t2) and f1
```
`and`や`or`は条件分岐で使うのではなく、制御フローを扱うのに向いている。

##### unless 文
Ruby には if と反対の意味を持つ unless がある。条件式が偽の場合だけ処理を実行する。if文で否定の条件を書いているときは、unless文に書き換えられる。
```ruby
irb(main):017> status = 'error'
=> "error"
irb(main):018* if status != 'ok'
irb(main):019*   '何か異常があります'
irb(main):020> end
=> "何か異常があります"
```
unless を使って書き換えることができる
```ruby
irb(main):021> status = 'error'
=> "error"
irb(main):022* unless status == 'ok'
irb(main):023*   '何か異常があります'
irb(main):024> end
=> "何か異常があります"
```
else を使って条件が偽でなかった場合（真だった場合）の処理も書くことができる。
```ruby
irb(main):025> status = 'ok'
=> "ok"
irb(main):026* unless status == 'ok'
irb(main):027*   '何か異常があります'
irb(main):028* else
irb(main):029*   '正常です'
irb(main):030> end
=> "正常です"
```
ただし、if文の elsif に相当するもの（elsunless のような条件分岐）は存在しない。unless は if と同様、unless の戻り値を直接変数に代入したり、修飾子として文の後ろに置いたりできる。
```ruby
status = 'error'

# unlessの結果を変数に代入する
message =
  unless status == 'ok'
    '何か異常があります'
  else
    '正常です'
  end

message #=> "何か異常があります"

# unlessを修飾子として使う
'何か異常があります' unless status == 'ok'
#=> "何か異常があります"
```
`if + 否定条件`は、`unless + 肯定条件`に書き直すことができるものの、必ず書き直さなければいけないわけではない。if文のほうが読みやすいと思った場合は、`if + 否定条件`のままにしておいても大丈夫。
```ruby
status = 'error'
# unlessを無理に使わなくても良い
if status != 'ok'
  '何か異常があります'
end
#=> "何か異常があります"
```

##### ==true や ==false は冗長なので書かない
if文の条件節で「真であること（もしくは偽であること）」を判断するために、`== true`や`== false`と書く人がいるが、これは冗長な書き方なのでやめること。

同じ考え方で、Ruby では nil を偽として扱うので`== nil`や`!= nil`をかくこともあまりない。ただし、「対象データが未存在である」ということを明示するために、`== nil`ではなく`nil?`メソッドが使われることはある。
- nil?メソッド：オブジェクトが nil だった場合に true を返すメソッド。

##### case文
1つのオブジェクトや式を複数の値と比較する場合は、elsif を重ねるよりも case文で書いたほうがシンプルになる。
```ruby
case 対象のオブジェクトや式
when 値1
  # 値1に一致する場合の処理
when 値2
  # （値1に一致せず）値2に一致する場合の処理
when 値3
  # （値1にも値2にも一致せず）値3に一致する場合の処理
else
  # どれにも一致しない場合の処理
end
```
```ruby
country = 'italy'

# if文を使う場合
if country == 'japan'
  'こんにちは'
elsif country == 'us'
  'Hello'
elsif country == 'italy'
  'Ciao'
else
  '???'
end
#=> "Ciao"


# case文を使う場合
case country
when 'japan'
  'こんにちは'
when 'us'
  'Hello'
when 'italy'
  'Ciao'
else
  '???'
end
#=> "Ciao"
```
Ruby の case文では when節に複数の値を指定し、どれかに一致すれば処理を実行する、という条件分岐を書くことができる。
```ruby
# when節に複数の値を指定する
country = 'アメリカ'
case country
when 'japan', '日本'
  'こんにちは'
when 'us', 'アメリカ'
  'Hello'
when 'italy', 'イタリア'
  'Ciao'
else
  '???'
end
#=> "Hello"
```
case節の式を省略すると、条件式が最初に真になる when節の処理が実行される。
```ruby
country = 'italy'

# case節の式を省略し、when節の条件式を順に評価するcase文
case
when country == 'Japan'
  'こんにちは'
when country == 'us'
  'Hello'
when country == 'italy'
  'Ciao'
else
  '???'
end
#=> "Ciao"
```
上記のような case文は if/elsif を使った条件分岐と大差がないため、わざわざ使うメリットは薄い。

if文と同様、case文も最後に評価された式を戻り値として返すため、case文の結果を変数に入れることが可能。
```ruby
country = 'italy'

message =
  case country
  when 'japan'
    'こんにちは'
  when 'us'
    'Hello'
  when 'italy'
    'Ciao'
  else
    '???'
  end

message #=> "Ciao"
```
when節の後ろには then を入れることができる。then を入れると when節とその条件が真だった場合の処理を1行で書くことができるが、使用頻度はそれほど高くない。
```ruby
country = 'italy'

case country
when 'japan' then 'こんにちは'
when 'us' then 'Hello'
when 'italy' then 'Ciao'
else "???"
end
#=> "Ciao"
```

##### 条件演算子（三項演算子）
Ruby では、`?``:`を使った条件分岐(三項演算子)を使うことができる。
```ruby
式 ? 真だった場合の処理 : 偽だった場合の処理
```
```
n = 11
if n > 10
  '10より大きい'
else
  '10以下'
end
#=> "10より大きい"

# 上記のコードは条件演算子を使うと以下のように書き直すことができる
n = 11
n > 10 ? '10より大きい' : '10以下'
#=> "10より大きい"

# 条件分岐した結果を変数に代入することも可能
n = 11
message = n > 10 ? '10より大きい' : '10以下'
message #=> "10より大きい"
```
シンプルな if/else文であれば、条件演算子を使ったほうがスッキリ書ける場合がある。逆に複雑な条件文だったりすると、かえって読みづらくなる場合もある。**コードの可読性を考慮**しながら利用するようにすること。

#### 2.11 メソッド定義についてもっと詳しく
##### デフォルト値付きの引数
Ruby ではメソッドを呼び出す際に引数の過不足があるとエラーになる。
```ruby
def greet(country)
  if country == 'japan'
    'こんにちは'
  else
    'hello'
  end
end

# 引数が少ない
greet
#=> wrong number of arguments (given 0, expected 1) (ArgumentError)

# 引数がちょうど
greet('us') #=> "hello"

# 引数が多い
greet('us', 'japan')
#=> wrong number of arguments (given 2, expected 1) (ArgumentError)
```
Ruby ではメソッドの引数の数を柔軟に変える方法がいくつかある。そのうちの1つがデフォルト値付きの引数。引数にデフォルト値を付ける場合は次のような構文を使う。
```ruby
def メソッド(引数1 = デフォルト値1, 引数2 = デフォルト値2)
  # 必要な処理
end
```
```ruby
# 引数なしの場合はcountryに'japan'を設定する
def greet(country = 'japan')
  if country == 'japan'
    'こんにちは'
  else
    'hello'
  end
end

greet       #=> "こんにちは"
greet('us') #=> "hello"
```
デフォルト値付きの引数を使う場合は、デフォルト値ありとデフォルト値なしの引数を混在させることも可能。
```ruby
irb(main):057* def default_args(a, b, c = 0, d = 0)
irb(main):058*   "a=#{a}, b=#{b}, c=#{c}, d=#{d}"
irb(main):059> end
irb(main):060> default_args(1, 2)
=> "a=1, b=2, c=0, d=0"
irb(main):061> default_args(1, 2, 3)
=> "a=1, b=2, c=3, d=0"
irb(main):062> default_args(1, 2, 3, 4)
=> "a=1, b=2, c=3, d=4"
```
デフォルト値は固定の値だけでなく、動的に変わる値や、他のメソッドの戻り値を指定したりすることもできる。
```ruby
irb(main):063* def foo(time = Time.now, message = bar)
irb(main):064*   puts "time: #{time}, message: #{message}"
irb(main):065> end
=> :foo
irb(main):066> 
irb(main):067* def bar
irb(main):068*   'BAR'
irb(main):069> end
=> :bar
irb(main):070> 
irb(main):071> foo
time: 2025-01-10 20:23:00 +0900, message: BAR
```
デフォルト値には左にある引数を指定することもできる。
```ruby
# yが指定されなければxの値をyに設定する
irb(main):072* def point(x, y = x)
irb(main):073*   puts "x=#{x}, y=#{y}"
irb(main):074> end
=> :point
irb(main):075> 
irb(main):076> point(3)
x=3, y=3
=> nil
irb(main):077> point(3, 10)
x=3, y=10
=> nil
```

##### ? で終わるメソッド
Ruby のメソッド名は`?`や`!`で終わらせることができる。`?`で終わるメソッドは慣習として**真偽値（true か false）を返すメソッド**になっている。このようなメソッドを**述語メソッド**と言う。
```ruby
# 空文字列であればtrue、そうでなければfalse
irb(main):078> ''.empty?
=> true
irb(main):079> 'abc'.empty?
=> false

# 引数の文字列が含まれていればtrue、そうでなければfalse
irb(main):080> 'watch'.include?('at')
=> true
irb(main):081> 'watch'.include?('in')
=> false

# 奇数ならtrue、偶数ならfalse
irb(main):082> 1.odd?
=> true
irb(main):083> 2.odd?
=> false

# 偶数ならtrue、奇数ならfalse
irb(main):084> 1.even?
=> false
irb(main):085> 2.even?
=> true

# オブジェクトがnilであればtrue、そうでなければfalse
irb(main):086> nil.nil?
=> true
irb(main):087> 'abc'.nil?
=> false
irb(main):088> 1.nil?
=> false
```
`?`で終わるメソッドは自分で定義することもできる。真偽値を返す目的のメソッドであれば、`?`で終わらせるようにしたほうが良い。
```ruby
# 3の倍数ならtrue、それ以外はfalseを返す
irb(main):089* def multiple_of_three?(n)
irb(main):090*   n % 3 == 0
irb(main):091> end
irb(main):092> multiple_of_three?(4)
=> false
irb(main):093> multiple_of_three?(5)
=> false
irb(main):094> multiple_of_three?(6)
=> true
```

##### ! で終わるメソッド
`!`で終わるメソッドは、`!`が付いていないメソッドよりも危険という意味を持つ。そのため、`!`で終わるメソッドを使うときは注意が必要。`upcase`メソッドと`upcase!`メソッドはどちらも文字列を大文字にするメソッドだが、`upcase`メソッドは大文字に変えた新しい文字列を返し、呼び出した文字列自身は変化しない。`upcase!`メソッドは呼び出した文字列自身を大文字に変更する。
```ruby
irb(main):095> a = 'ruby'
=> "ruby"

# upcaseだと変数aの値は変化しない
irb(main):096> a.upcase
=> "RUBY"
irb(main):097> a
=> "ruby"

# upcase!だと変数aの値も大文字に変わる
irb(main):098> a.upcase!
=> "RUBY"
irb(main):099> a
=> "RUBY"
```
`upcase!`メソッドのように、呼び出したオブジェクトの状態を変更してしまうメソッドのことを「**破壊的メソッド**」と呼ぶ。
`!`で終わるメソッドも自分で定義することができる。
```ruby
# 引数の内容を変更しない安全バージョン
def reverse_upcase(s)
  s.reverse_upcase
end

# 引数の内容を破壊的に変更してしまう危険バージョン
def reverse_upcase!(s)
  s.reverse!
  s.upcase!
  s
end

s = 'ruby'

# 安全バージョンは引数として渡した変数sの内容はそのまま
reverse_upcase(s) #=> "YBUR"
s #=> "ruby"

# 危険バージョンは引数として渡した変数sの内容が変更される
reverse_upcase!(s) #=> "YBUR"
s #=> "YBUR"
```

##### 「!で終わるメソッドは破壊的メソッドである」は間違い
- `!`がつくメソッドは、`!`が付かないメソッドよりも危険、という意味を持つ。
- 非破壊的メソッドと破壊的メソッドの2種類が存在する場合は後者に`!`が付く。
- 破壊的メソッドであっても非破壊的メソッドがない（つまり1種類しかない）場合は`!`が付かない。
- 破壊的かどうかに関係なく、安全なメソッドと危険なメソッドの2種類が存在する場合にも後者に`!`が付く。

##### エンドレスメソッド定義（1行メソッド定義）
Ruby 3.0から`end`を省略して1行でメソッドを定義できる、エンドレスメソッド定義構文が導入された。
```ruby
# 通常のメソッド定義
def greet
  'Hello'
end

# エンドレスメソッド定義（=に続けて処理や戻り値を書く）
def greet = 'Hello!'

# 呼び出し方はどちらも同じ
greet #=> "Hello!"
```

-------------


## ✍🏻 感想
### 🍒 手を動かして確かめる
大事な知識を理解するために、実際にコードを打ち込んで一つずつ挙動を確かめています。打ち込んだ内容がどのような形で画面に表示されるのかを楽しみながらインプットしています。今は地道な作業かもしれませんが、基礎を押さえるために必要なことです！


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 4 hours 28 min
- Total: 864 hours 45 min
