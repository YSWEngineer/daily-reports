# 2025/01/14(火)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [ ] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [ ] 4.3 ブロック
   - [ ] 4.4 ブロックを使う配列のメソッド
   - [ ] 4.5 範囲（Range）
   - [ ] 4.6 例題：RGB変換プログラムを作成する
   - [ ] 4.7 配列についてもっと詳しく
   - [ ] 4.8 ブロックについてもっと詳しく
   - [ ] 4.9 範囲（Range）についてもっと詳しく
   - [ ] 4.10 さまざまな繰り返し処理
   - [ ] 4.11 繰り返し処理用の制御構造
   - [ ] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [ ] 5.1 イントロダクション
   - [ ] 5.2 ハッシュ
   - [ ] 5.3 シンボル
   - [ ] 5.4 続・ハッシュについて
   - [ ] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.1 イントロダクション 〜 4.3 ブロック 途中まで

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.3 ブロック 途中 〜


------------


## 💡 本日の学び・気付き
### 🍒 プロを目指す人のためのRuby入門 <改訂2版>
#### 4.1 イントロダクション
配列は非常に利用頻度の高いオブジェクト。ブロックもやい列や繰り返し処理と切っても切れない関係にあるため、非常に重要。

##### この章の例題：RGBカラー変換プログラム
RGBカラーは、1つの色を表すためにRed（赤）、Green（緑）、Blue（青）の3色を数値化したもの。R=65, G=105, B=225のように**10進数の整数**で表現されたり、#4169elのように**2桁の16進数を3つ並べた文字列**で表現されることもある。

RGBカラー変換プログラムの仕様
- 10進数を16進数に変換する`to_hex`メソッドと、16進数を10進数に変換する`to_ints`メソッドの2つを定義する。
- `to_hex`メソッドは3つの整数を受け取り、それぞれを16新数に変換した文字列を返す。文字列の先頭には`#`を付ける。
- `to_ints`メソッドはRGBカラーを表す16進数の文字列を受け取り、R、G、Bのそれぞれを10進数の整数に変換した値を配列として返す。

##### RGBカラー変換プログラムの実行例
`to_hex`メソッドと`to_ints`メソッドの実行例。
```ruby
to_hex(0, 0, 0)        #=> "#000000"
to_hex(255, 255, 255)  #=> "#ffffff"
to_hex(4, 60, 120)     #=> "#043c78"
to_ints('#000000')     #=> [0, 0, 0]
to_ints('#ffffff')     #=> [255, 255, 255]
to_ints('#043c78')     #=> [4, 60, 120]
```

#### 4.2 配列
配列とは**複数のデータをまとめて格納できるオブジェクト**のこと。配列内のデータ（要素）は順番に並んでいて、添え字（インデックス）を指定することでそのデータを取り出すことができる。配列は`[]`と`,`を使って作成する（配列リテラル）。
- **配列リテラル**：複数の値を1つの変数にまとめて扱うための記法。一般的に角括弧`[]`を使って定義する。
```ruby
# 空の配列を作る
[]

# 3つの要素が格納された配列を作る
[要素1, 要素2, 要素3]
```
配列はArrayクラスのオブジェクトになっている。
```ruby
# 空の配列を作成し、そのクラス名を確認する
irb(main):002> [].class
=> Array
```
`a = [1, 2, 3]`は以下のような書き方でも可能。
```ruby
# 改行して書くこともできる
a = [
      1,
      2,
      3
]

# 最後の要素に`,`がついても文法上エラーにはならない
a = [
      1,
      2,
      3,
]
```
配列は数値に限らず、どんなオブジェクトでも格納できる。以下は配列の中に文字列を格納する例。
```ruby
a = ['apple', 'orange', 'melon']
```
数値と文字列を混在させた異なるデータ型を格納することもできる。
```ruby
a = [1, 'apple', 2, 'orange', 3, 'melon']
```
配列の中に配列を含めることもできる。
```ruby
a = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]
```
配列の各要素を取得する場合は、`[]`と`添え字（数値）`を使う。最初の要素の添え字は`0`。
```ruby
irb(main):003> a = [1, 2, 3]
=> [1, 2, 3]

# 1つ目の要素を取得
irb(main):004> a[0]
=> 1
# 2つ目の要素を取得
irb(main):005> a[1]
=> 2
# 3つ目の要素を取得
irb(main):006> a[2]
=> 3

# 存在しない要素を指定してもエラーにはならず、`nil`が返る。
irb(main):007> a[100]
=> nil
```
`size`メソッド（エイリアスメソッドは`length`）を使うと**配列の長さ**（**要素の個数**）を取得できる。
```ruby
# a = [1, 2, 3]のとき
irb(main):008> a.size
=> 3
irb(main):009> a.length
=> 3
```

##### 要素の変更、追加、削除
添字を指定して値を代入すると、指定した要素を変更することができる。
```ruby
配列[添え字] = 新しい値
```
**2番目の要素**を`20`に変更するコード例。
```ruby
# a = [1, 2, 3]のとき
irb(main):010> a[1] = 20
=> 20
irb(main):011> a
=> [1, 20, 3]
```
元の大きさよりも大きい添字を指定すると、間の値が`nil`で埋められる。以下は元の大きさが3の配列に対して、5番目の要素を設定した場合の実行結果。**4番目の要素**が`nil`になっている。
```ruby
# a = [1, 2, 3]のとき
irb(main):012> a[4] = 50
=> 50
irb(main):013> a
=> [1, 20, 3, nil, 50]
```
`<<`を使うと配列の最後に要素を追加することができる。
```ruby
irb(main):014> a = []
=> []
irb(main):015> a << 1
=> [1]
irb(main):016> a << 2
=> [1, 2]
irb(main):017> a << 3
=> [1, 2, 3]
irb(main):018> a
=> [1, 2, 3]
```
配列内の特定の位置にある要素を削除したい場合は`delete_at`メソッドを使う。
```ruby
irb(main):019> a = [1, 2, 3]
=> [1, 2, 3]
# 2番目の要素を削除する（削除した値が戻り値になる）
irb(main):020> a.delete_at(1)
=> 2
irb(main):021> a
=> [1, 3]

# 存在しない添字を指定するとnilが返る
irb(main):022> a.delete_at(100)
=> nil
irb(main):023> a
=> [1, 3]
```

# 配列を使った多重代入
おさらい：変数を多重代入する方法
```ruby
irb(main):024> a, b = 1, 2
=> [1, 2]
irb(main):025> a
=> 1
irb(main):026> b
=> 2
```
右辺に配列を置いた場合も同じように多重代入することができる。
```ruby
# 配列を使って多重代入する
irb(main):027> a, b = [1, 2]
=> [1, 2]
irb(main):028> a
=> 1
irb(main):029> b
=> 2

# 右辺の数が少ない場合はnilが入る
irb(main):030> c, d = [10]
=> [10]
irb(main):031> c
=> 10
irb(main):032> d
=> nil

# 右辺の数が多い場合ははみ出した値が切り捨てられる。
irb(main):033> e, f = [100, 200, 300]
=> [100, 200, 300]
irb(main):034> e
=> 100
irb(main):035> f
=> 200
```
配列の多重代入は便利に使える場合がある。たとえば、Ruby には割り算の商と余りを配列として返す`divmod`というメソッドがある。こういったメソッドの場合、配列で受け取るよりも多重代入を使って最初から別々の変数に入れたほうが、すっきりとしたコードが書ける。
```ruby
# divmodは商と余りを配列で返す
irb(main):036> 14.divmod(3)
=> [4, 2]

# 戻り値を配列のまま受け取る
irb(main):037> quo_rem = 14.divmod(3)
=> [4, 2]
irb(main):038> "商=#{quo_rem[0]}, 余り=#{quo_rem[1]}"
=> "商=4, 余り=2"

# 多重代入で別々の変数として受け取る
# quotientは商、remainderは余りを意味する
irb(main):039> quotient, remainder = 14.divmod(3)
=> [4, 2]
irb(main):040> "商=#{quotient}, 余り=#{remainder}"
=> "商=4, 余り=2"
```

#### 4.3 ブロック
ブロックはメソッドの引数として渡すことができる処理のかたまり。ブロック内で記述した処理は必要に応じてメソッドから呼び出される。
##### 参考：JavaScript の繰り返し処理
初期の JavaScript の for文を使った配列の中身を順番に処理する書き方
```javascript
var numbers = [1, 2, 3, 4]
var sum = 0
for (var i = 0; i < numbers.length; i++) {
  sum += numbers[i]
}
console.log(sum) //=> 10
```
- ①変数`i`を`0`で初期化しろ`(var i = 0)`
- ②ループが1回終わるごとに`i`の値を1増やせ`(i++)`。
- ③配列`numbers`に入っている`i`番目の値を取り出せ`(numbers[i])`。
- ④変数`sum`に取り出した値を加算しろ`(sum += numbers[i])`。
- ⑤`i`は配列`numbers`の長さよりも小さい間は②〜④の処理を繰り返せ`(i < numbers.length)`。

最近の JavaScript では次のように`forEach`メソッドで配列を繰り返し処理できる。
```javascript
var numbers = [1, 2, 3, 4]
var sum = 0
for (var i = 0; i < numbers.length; i++) {
  sum += numbers[i]
}
console.log(sum) //=> 10

const numbers = [1, 2, 3, 4]
let sum = 0
numbers.forEach(function(n) {
  sum += n
})
console.log(sum) //=> 10
```

##### Ruby の繰り返し処理
Ruby にも for文はあるが、ほとんどの Rubyプログラマは for文を使わない。Ruby の場合は for のような構文で繰り返し処理をさせるのではなく、**配列自身に対して「繰り返せ」という命令**を送る。ここで登場するのが`each`メソッド。
```ruby
irb(main):041> numbers = [1, 2, 3, 4]
=> [1, 2, 3, 4]
irb(main):042> sum = 0
=> 0
irb(main):043* numbers.each do |n|
irb(main):044*   sum += n
irb(main):045> end
irb(main):046> sum
=> 10
```
- `numbers.each`：配列の`each`メソッドを利用している。
  - Ruby では、コールバック関数ではなく**ブロック**を使うのが大きな特徴。
- `each`メソッドの役割は**配列の要素を最初から最後まで順番に取り出す**こと。その**要素をどう扱うかはブロックに記述**する。上記のコードでいうと、`do`から`end`までがブロック。
```ruby
# ブロックの範囲はdoからendまで
numbers.each do |n|
  sum += n
end
```
`|n|`の`n`は**ブロックパラメータ**と呼ばれるもので、`each`メソッドから渡された配列の要素が入る。具体的に言うと、`n`には`1, 2, 3, 4`が順番に渡される。

##### 配列の要素を削除する条件を自由に指定する
ブロックは非常によく使われる。`each`以外に、配列には指定した値に一致する要素を削除する`delete`というメソッドがある。
```ruby
irb(main):047> a = [1, 2, 3, 1, 2, 3]
=> [1, 2, 3, 1, 2, 3]
# 配列から値が2の要素を削除する
irb(main):048> a.delete(2)
=> 2
irb(main):049> a
=> [1, 3, 1, 3]
```
`delete`メソッドを使うと引数で渡した値に**完全一致する要素しか削除できない**。たとえば「奇数だけを削除する」という処理を実現できない。そんな場合は、`delete_if`メソッドを使う。
```ruby
irb(main):056> a = [1, 2, 3, 1, 2, 3]
=> [1, 2, 3, 1, 2, 3]
# 配列から値が奇数の要素を削除する
# oddは奇数を意味する
irb(main):057* a.delete_if do |n|
irb(main):058*   n.odd?
irb(main):059> end
irb(main):060> a
=> [2, 2]
```
`delete_if`メソッドも`each`メソッドと同じように配列の要素を順番に取り出す。そして、その要素をブロックに渡す。しかし、そこから後の処理は`each`メソッドとは異なる。`delete_if`メソッドはブロックの戻り値をチェックする。その**戻り値が真であれば、ブロックに渡した要素を配列から削除**する。**偽であれば配列に残したまま**にする。

ブロックの戻り値はメソッドと同様、最後に評価された式になる。上記のコードでは`n.odd?`の**結果がブロックの戻り値**。`odd?`メソッドは数値が奇数の場合に`ture`を返す。よって、実行すると配列から奇数の要素が削除される。

`delete_if`メソッドは、「**配列の要素を順番に取り出すこと**」と「**ブロックの戻り値が真であれば要素を削除すること**」という共通処理を提供する。

##### ブロックパラメータとブロック内の変数
もう一度、配列の要素を加算する処理を見てみる。
```ruby
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end
```
ブロックパラメータの`n`は別に`n`でなくてもよい。パラメータの名前はプログラマが自由に決めることができる。
```ruby
# ブロックパラメータの名前はなんでもよい
numbers.each do |i|
  sum += i
end

numbers.each do |number|
  sum += number
end

numbers.each do |element|
  sum += element
end
```
ブロックパラメータを使わない場合は、ブロックパラメータ自体を省略できる。
```ruby
numbers.each do
  sum += 1
end
```
ブロック内には Ruby のコードを自由に書くことができる。
```ruby
irb(main):061> numbers = [1, 2, 3, 4]
=> [1, 2, 3, 4]
irb(main):062> sum = 0
=> 0
irb(main):063* numbers.each do |n|
irb(main):064*   sum_value = n.even? ? n * 10 : n
irb(main):065*   sum += sum_value
irb(main):066> end
irb(main):067> sum
=> 64
```
`sum_value`はブロック内で初めて登場した変数。このような**変数のスコープ（有効範囲）はブロックの内部のみ**になる。もし、ブロックの外で`sum_value`を参照するとエラーが発生する。
```ruby
irb(main):068> numbers = [1, 2, 3, 4]
=> [1, 2, 3, 4]
irb(main):069> sum = 0
=> 0
irb(main):070* numbers.each do |n|
irb(main):071*   sum_value = n.even? ? n * 10 : n
irb(main):072*   sum += sum_value
irb(main):073> end
irb(main):074> sum_value
(irb):74:in `<main>': undefined local variable or method `sum_value' for main (NameError)
```
一方、変数`sum`のように、ブロックの外部で作成されたローカル変数はブロックの内部でも参照できる。
```ruby
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum_value = n.even? ? n * 10 : n
  # 変数sumはブロックの外で作成されたので、ブロックの内部でも参照可能
  sum += sum_value
end
```
ブロックパラメータの名前をブロックの外にある変数の名前と同じにすると、ブロック内ではブロックパラメータの値が優先して参照される（**名前の重複により、他の変数やメソッドが参照できなくなることをシャドーイング**という）。
```ruby
numbers = [1, 2, 3, 4]
sum = 0
sum_value = 100
# ブロックの外にもsum_valueはあるが、ブロック内ではブロックパラメータのsum_valueが優先される
numbers.each do |sum_value|
  sum += sum_value
end
sum #=> 10

# ブロックを抜けると3行目で定義したsum_valueを再び参照できる
sum_value #=> 100
```
↑しかし、このようなコードは**読み手を混乱させやすく、思わぬ不具合の原因になる**ため、**意図的に同じ名前を使うことは避ける**ようにすること。



-------------


## ✍🏻 感想
### 🍒 配列と仲良くなる
これまでのプラクティスの課題に欠かせなかった配列。コードを書く上で頻度の高いオブジェクトだと感じていました。配列の基礎を押さえながら学ぶことで、少しお近づきになれたような気がします。次回はもっと仲良くなれたらいいな！


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 4 hours 43 min
- Total: 874 hours 35 min
