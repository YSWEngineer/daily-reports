# 2025/01/17(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [ ] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [ ] 4.7 配列についてもっと詳しく
   - [ ] 4.8 ブロックについてもっと詳しく
   - [ ] 4.9 範囲（Range）についてもっと詳しく
   - [ ] 4.10 さまざまな繰り返し処理
   - [ ] 4.11 繰り返し処理用の制御構造
   - [ ] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [ ] 5.1 イントロダクション
   - [ ] 5.2 ハッシュ
   - [ ] 5.3 シンボル
   - [ ] 5.4 続・ハッシュについて
   - [ ] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.5 範囲（Range） 〜 4.7 配列についてもっと詳しく 途中まで

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.7 配列についてもっと詳しく 途中 〜 


------------


## 💡 本日の学び・気付き
### 🍒 プロを目指す人のためのRuby入門 <改訂2版>
#### 4.6 例題：RGB変換プログラムを作成する
RGB 変換プログラムの使用を確認。
- 10進数を16進数に変換する`to_hex`メソッドと、16進数を10進数に変換する`to_ints`メソッドの2つを定義する。
- `to_hex`メソッドは3つの整数を受け取り、それぞれを16真数に変換した文字列を返す。文字列の先頭には`#`を付ける。
- `to_ints`メソッドは RGBカラーを表す16進数の文字列を受け取り、R、G、Bのそれぞれを10進数の整数に変換した値を配列として返す。

`to_hex`メソッドと`to_ints`メソッドの実行例
```ruby
to_hex(0, 0, 0)        #=> "#000000"
to_hex(255, 255, 255)  #=> "#ffffff"
to_hex(4, 60, 120)     #=> "#043d78"
to_ints('#000000')     #=> [0, 0, 0]
to_ints('#ffffff')     #=> [255, 255, 255]
to_ints('#043d78')     #=> [4, 60, 120]
```

##### to_hexメソッドを作成する
開発において、「プログラムのインプットとアウトプットが明確である」「テストコードの書き方が最初からイメージできる」という2つの条件が揃っている場合は、**テスト駆動開発**（TDD、Test driven development）が向いている。

###### ターミナルから対象のファイルを VS Code で開く
```shell
# 対象のファイルをVSCodeで開く
code 対象のファイル

# rgb.rbファイルをVSCodeで開く
% code rgb.rb
```
rgb.rbファイルに書くコード
```ruby
def to_hex(r, g, b)
  '#000000'
end
```
`'#000000'`という固定の文字列返すのは、テストコードが機能しているか、ということをチェックするため。

このままでは`to_hex`メソッドはテストコードから参照できないので、`rgb_test.rb`で`../lib/rgb`を読み込む。
```ruby
require 'minitest/autorun'
# 以下の1行を書き加える
require_relative '../lib/rgb'

class RgbTest < Minitest::Test
  def test_to_hex
    assert_equal '#000000', to_hex(0, 0, 0)
  end
end
```
```shell
% ruby test/rgb_test.rb
Run options: --seed 47134

# Running:

.

Finished in 0.000664s, 1506.0240 runs/s, 1506.0240 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
```
テストコードにもう一つ検証コードを追加する。
```ruby
require 'minitest/autorun'
require_relative '../lib/rgb'

class RgbTest < Minitest::Test
  def test_to_hex
    assert_equal '#000000', to_hex(0, 0, 0)
    # 以下の1行を書き加える
    assert_equal '#ffffff', to_hex(255, 255, 255)
  end
end
```
```ruby
% ruby test/rgb_test.rb
Run options: --seed 25565

# Running:

F

Finished in 0.000999s, 1001.0010 runs/s, 2002.0019 assertions/s.

  1) Failure:
RgbTest#test_to_hex [test/rgb_test.rb:7]:
Expected: "#ffffff"
  Actual: "#000000"

1 runs, 2 assertions, 1 failures, 0 errors, 0 skips
```
rgb.rbファイルに以下のコードを書く
```ruby
def to_hex(r, g, b)
  '#' +
    r.to_s(16).rjust(2, '0') +
    g.to_s(16).rjust(2, '0') +
    b.to_s(16).rjust(2, '0')
end
```
```shell
% ruby test/rgb_test.rb
Run options: --seed 27263

# Running:

.

Finished in 0.000882s, 1133.7869 runs/s, 3401.3607 assertions/s.

1 runs, 3 assertions, 0 failures, 0 errors, 0 skips
```

##### to_hexメソッドをリファクタリングする
- **リファクタリング**：外から見た振る舞いは保ったまま、理解や修正が簡単になるように内部のコードを改善すること。
- **DRY原則**：Don't repeat yourself の略で、「繰り返しを避けること」という意味。

rgb.rbファイルの内容をリファクタリングする。
```ruby
def to_hex(r, g, b)
  hex = '#'
  [r, g, b].each do |n|
    hex += n.to_s(16).rjust(2, '0')
  end
  hex
end
```

rgb.rbファイルのコードをもっと短くシンプルにする。
```ruby
def to_hex(r, g, b)
  [r, g, b].sum('#') do |n|
    n.to_s(16).rjust(2, '0')
  end
end
```
↑上記のコードで押さえておくべき3つのポイント
- 初期値、つまり先頭の文字として`#`が入ること。
- ブロックの中の`n.to_s(16).rjust(2, '0')で作成された文字列は、順番に連結されて1つの文字列になること。
- 繰り返し処理が最後まで到達したら、連結された文字列が`sum`メソッド自身の戻り値になること。

##### to_intsメソッドを作成する
`to_hex`メソッドの時と同じようにテストコードを書く。
```ruby
require 'minitest/autorun'
require_relative '../lib/rgb'

class RgbTest < Minitest::Test
  def test_to_hex
    assert_equal '#000000', to_hex(0, 0, 0)
    assert_equal '#ffffff', to_hex(255, 255, 255)
    assert_equal '#043c78', to_hex(4, 60, 120)
  end

  def test_to_ints
    assert_equal [0, 0, 0], to_ints('#000000')
  end
end
```
rgb.rbファイルに`to_ints`メソッドの仮実装を書く。
```rubydef to_hex(r, g, b)
  [r, g, b].inject('#') do |hex, n|
    hex + n.to_s(16).rjust(2, '0')
  end
end

def to_ints(hex)
  [0, 0, 0]
end
```
```shell
% ruby test/rgb_test.rb
Run options: --seed 16680

# Running:

..

Finished in 0.001013s, 1974.3338 runs/s, 3948.6677 assertions/s.

2 runs, 4 assertions, 0 failures, 0 errors, 0 skips
```
rgb_test.rbファイルに2つ目の検証コードを追加する。
```ruby
require 'minitest/autorun'
require_relative '../lib/rgb'

class RgbTest < Minitest::Test
  def test_to_hex
    assert_equal '#000000', to_hex(0, 0, 0)
    assert_equal '#ffffff', to_hex(255, 255, 255)
    assert_equal '#043c78', to_hex(4, 60, 120)
  end

  def test_to_ints
    assert_equal [0, 0, 0], to_ints('#000000')
    assert_equal [255, 255, 255], to_ints('#ffffff')
  end
end
```
```shell
% ruby test/rgb_test.rb
Run options: --seed 17809

# Running:

F.

Finished in 0.000767s, 2607.5619 runs/s, 6518.9047 assertions/s.

  1) Failure:
RgbTest#test_to_ints [test/rgb_test.rb:13]:
Expected: [255, 255, 255]
  Actual: [0, 0, 0]

2 runs, 5 assertions, 1 failures, 0 errors, 0 skips
```

`to_ints`メソッドの実装で必要な手順は大きく分けて次の2つ。
- **①：文字列から16進数の文字列を2文字ずつ取り出す。**
- **②：2桁の16進数を10進数の整数に変換する。**

###### 文字列から16進数の文字列を2文字ずつ取り出す
`[]`と範囲オブジェクトを使う。たとえば、文字列の2文字目から4文字目までを足り出したいときは、次のようにして取り出すことができる。
```ruby
s = 'abcde'
s[1..3] #=> "bcd"

# 文字列からR（赤）、G（緑）、B（青）の各値を取り出す
hex = '#12abcd'
r = hex[1..2] #=> "12"
g = hex[3..4] #=> "ab"
b = hex[5..6] #=> "cd"
```

###### 16進数を10進数の整数に変換する
Stringクラスの`hex`というメソッドを使う。
```ruby
'00'.hex #=> 0
'ff'.hex #=> 255
'2a'.hex #=> 42
```

①と②を合わせてると、to_intsメソッドが次のように実装できる。
```ruby
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6] 
  ints = []
  [r, g, b].each do |s|
    ints << s.hex
  end
  ints
end
```
↑上記のコードの処理フロー（流れ）は以下のとおり。
- **引数の文字列から3つの16進数を抜き出す。**
- **3つの16進数を配列に入れ、ループを回しながら10進数の整数に変換した値を別の配列に詰め込む。**
- **10進数の整数が入った配列を返す。**

##### to_intsメソッドをリファクタリングする
「**からの配列を用意して、ほかの配列をループ処理した結果をからの配列に詰め込んでいくような処理の大半は、mapメソッドに置き換えることができるはずです**」
```ruby
# mapメソッドに置き換える
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6] 
  [r, g, b].map do |s|
    s.hex
  end
end
```
↑`map`メソッドはブロックの戻り値を配列の要素にして新しい配列を返すメソッドなので、`ints`のような変数を用意しなくても、`map`メソッドとブロックだけで処理が完結する。

##### to_intsメソッドをリファクタリングする（上級編）
###### 熟練者向けのリファクタリング方法
最初にr、g、bという変数を作って代入しているが、改行せずに多重代入を使って1行にする。
```ruby
def to_ints(hex)
  r, g, b = hex[1..2], hex[3..4], hex[5..6]
  [r, g, b].map do |s|
    s.hex
  end
end
```
さらに、範囲オブジェクトの代わりに正規表現と`scan`メソッドを使うと、一気に文字列を3つの16進数に分割できる。
```ruby
def to_ints(hex)
  r, g, b = hex.scan(/\w\w/)
  [r, g, b].map do |s|
    s.hex
  end
end
```
`scan`メソッドは正規表現にマッチした文字列を配列にして返す（r、g、bに対して多重代入できるのも`scan`メソッドが配列を返しているため）。
```ruby
'#12abcd'.scan(/\w\w/) #=> ["12", "ab", "cd"]
```
そのため、一度変数に入れて`[r, g, b]`のような配列を作らなくても、`scan`メソッドの戻り値に対して直接メソッドを呼ぶことができる。
```ruby
def to_ints(hex)
  hex.scan(/\w\w/).map do |s|
    s.hex
  end
end
```
おさらい：ブロックの代わりに`&: メソッド名`という引数を渡すことができるための条件
- **ブロックパラメータが1個だけである。**
- **ブロックの中で呼び出すメソッドには引数がない。**
- **ブロックの中では、ブロックパラメータに対してメソッドを1回呼び出す以外の処理がない。**

`to_ints`メソッドの中で書いているブロックの処理が該当するので、ブロックをなくし、代わりに`&:hex`を`map`メソッドの引数に渡す。
```ruby
def to_ints(hex)
  hex.scan(/\w\w/).map(&:hex)
end
```
さらに、Ruby 3.0 で導入されたエンドレスメソッド定義構文を使うとメソッド定義全体が1行になる。
```ruby
# エンドレスメソッド定義構文で書く
def to_ints(hex) = hex.scan(/\w\w/).map(&:hex)
```
Ruby 初心者は最初から簡潔なコードを書くのは難しいが、**自分の書いたコードにすぐに満足せずに、どこかリファクタリングできる部分はないか研究する**ことを心がけること。

#### 4.7 配列についてもっと詳しく
##### さまざまな要素の取得方法
添え字を2つ使うと、添え字の位置と取得する長さを指定することができる。この場合、配列が返ってくる。
```ruby
配列[位置, 取得する長さ]
```
2つ目の要素から3つ分の要素を取り出すコード。
```ruby
a = [1, 2, 3, 4, 5]
a[1, 3] #=> [2, 3, 4]
```
`values_at`メソッドを使うと、取得したい要素の添え字を複数指定できる。
```ruby
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) #=> [1, 3, 5]
```
「配列の長さ - 1」を指定すれば、最後の要素を取得できる。
```ruby
a = [1, 2, 3]
# 最後の要素を取得する
a[a.size - 1] #=> 3
```
Ruby では添え字に負の値が使える。`-1`は最後の要素、`-2`は最後から2番目の要素、と指定できる。
```ruby
a = [1, 2, 3]

# 最後の要素を取得する
a[-1] #=> 3

# 最後から2番目の要素を取得する
a[-2] #=> 2

# 最後から2番目の要素から2つの要素を取得する
a[-2, 2] #=> [2, 3]
```
配列には`last`というメソッドがある。これを呼ぶと配列の最後の要素を取得できる。引数に0以上の数値を渡すと、最後の n個の要素を取得できる。
```ruby
a = [1, 2, 3]
a.last    #=> 3
a.last(2) #=> [2, 3]
```
`first`は`last`の反対で、先頭の要素を取得するメソッド。
```ruby
a = [1, 2, 3]
a.first    #=> 1
a.first(2) #=> [1, 2]
```

##### さまざまな要素の変更方法
値を変更する場合も負の添え字が使える。ただし、性の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる。
```ruby
a = [1, 2, 3]
a[-3] = -10
a #=> [-10, 2, 3]

# 指定可能な負の値よりも小さくなるとエラーが発生する
irb(main):017> a[-4] = 0
(irb):17:in `<main>': index -4 too small for array; minimum: -3 (IndexError)
```
開始位置と長さを指定して要素を置き換えることもできる。
```ruby
a = [1, 2, 3, 4, 5]
# 2つ目から3要素分を100で置き換える
a[1, 3] = 100
irb(main):020> a
=> [1, 100, 5]
```
`<<`だけでなく、`push`メソッドを使っても要素を追加できる。`push`メソッドの場合は複数の値を追加することができる。
```ruby
irb(main):021> a = []
=> []
irb(main):022> a.push(1)
=> [1]
irb(main):023> a.push(2, 3)
=> [1, 2, 3]
irb(main):024> a
=> [1, 2, 3]
```
指定した値に一致する要素を削除したい場合は`delete`メソッドを使う。
```ruby
irb(main):025> a = [1, 2, 3, 1, 2, 3]
=> [1, 2, 3, 1, 2, 3]
# 値が2である要素を削除する（削除した値が戻り値になる）
irb(main):026> a.delete(2)
=> 2
irb(main):027> a
=> [1, 3, 1, 3]

# 存在しない値を指定するとnilが返る
irb(main):028> a.delete(5)
=> nil
irb(main):029> a
=> [1, 3, 1, 3]
```


-------------


## ✍🏻 感想
### 🍒 リファクタリングは経験値を稼げる
配列を用いたコードをリファクタリングして、より簡単で短いコードにしました。もちろん解説を読みながらですが、得られる経験値が多いです。チェリー本 p. 129 に大切にしたい文章がありました。

> Ruby が提供している便利なメソッドや言語機能を使うと、ここまで簡潔なコードを書くことができます。Ruby 初心者の方は最初からこんなに短いコードを書くのは難しいかもしれませんが、自分の書いたコードにすぐに満足せず、どこかリファクタリングできる部分はないか研究することを心がけてください。

引き続き、チェリー本を活用していろんなことを学んでいきます。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 5 hours 17 min
- Total: 884 hours 32 min
