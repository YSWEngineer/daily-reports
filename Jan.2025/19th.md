# 2025/01/19(日)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [ ] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [ ] 4.8 ブロックについてもっと詳しく
   - [ ] 4.9 範囲（Range）についてもっと詳しく
   - [ ] 4.10 さまざまな繰り返し処理
   - [ ] 4.11 繰り返し処理用の制御構造
   - [ ] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [ ] 5.1 イントロダクション
   - [ ] 5.2 ハッシュ
   - [ ] 5.3 シンボル
   - [ ] 5.4 続・ハッシュについて
   - [ ] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.7 配列についてもっと詳しく 途中 〜 4.8 ブロックについてもっと詳しく 途中まで

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第4章  配列や繰り返し処理を理解する
      - 4.8 ブロックについてもっと詳しく 途中 〜



------------


## 💡 本日の学び・気付き
### 🍒 プロを目指す人のためのRuby入門 <改訂2版>
#### 4.7 配列についてもっと詳しく
##### 配列の連結
2つの配列を連結したい場合は`concat`メソッドか、`+`演算子を使う。違いは元の配列を変更するかどうか（破壊的かどうか）。
`concat`メソッドを使い配列を連結すると、元の配列（メソッドを呼び出した側の配列）が変更される。
```ruby
irb(main):030> a = [1]
=> [1]
irb(main):031> b = [2, 3]
=> [2, 3]
irb(main):032> a.concat(b)
=> [1, 2, 3]

# aは変更される（破壊的）
irb(main):033> a
=> [1, 2, 3]

# bは変更されない
irb(main):034> b
=> [2, 3]
```
`+`を使うと元の配列を変更せず、新しい配列を作成する。
```ruby
irb(main):035> a = [1]
=> [1]
irb(main):036> b = [2, 3]
=> [2, 3]
irb(main):037> a + b
=> [1, 2, 3]

# aもbも変更されない（非破壊的）
irb(main):038> a
=> [1]
irb(main):039> b
=> [2, 3]
```
破壊的な変更は大きなプログラムやフレームワークの中では**思いがけないところに悪影響を与えてしまう**場合がある。特別なとき以外は`+`演算子を使うこと。

##### 配列の和集合、差集合、積集合
Ruby の配列は`|`、`-`、`&`を使い、和集合、差集合、積集合を求めることができる。
`|`は和集合を求める演算子で、2つの配列の要素をすべて集め、重複しないようにして返す。
```ruby
irb(main):040> a = [1, 2, 3]
=> [1, 2, 3]
irb(main):041> b = [3, 4, 5]
irb(main):042> a | b
=> [1, 2, 3, 4, 5]
```
`-`は差集合を求める演算子で、左の配列から右の配列に含まれる要素を取り除く。
```ruby
irb(main):043> a = [1, 2, 3]
=> [1, 2, 3]
irb(main):044> b = [3, 4, 5]
irb(main):045> a - b
=> [1, 2]
```
`&`は積集合を求める演算子で、2つの配列に共通する要素を返す。
```ruby
irb(main):046> a = [1, 2, 3]
=> [1, 2, 3]
irb(main):047> b = [3, 4, 5]
irb(main):048> a & b
=> [3]
```
`|`、`-`、`&`は、**元の配列は変更しない**（**非破壊的**）。

Ruby には配列よりも効率的に集合を扱える`Set`クラスもある。本格的な集合演算をする場合は、配列よりも`Set`クラスを使うほうが良い。
```ruby
require 'set'

a = Set[1, 2, 3]
b = Set[3, 4, 5]
a | b #=> #<Set: {1, 2, 3, 4, 5}>
a - b #=> #<Set: {1, 2}>
a & b #=> #<Set: {3}>
```

##### 多重代入で残りの全要素を配列として受け取る、または無視する
おさらい：多重代入では**左辺の変数よりも右辺の個数が多い場合**は、はみ出した値が切り捨てられる。
```ruby
irb(main):057> e, f = 100, 200, 300
=> [100, 200, 300]
irb(main):058> e
=> 100
irb(main):059> f
=> 200
```
しかし、左辺の変数に`*`を付けると、残りの全要素を配列として受け取ることができる。
```ruby
irb(main):060> e, *f = 100, 200, 300
=> [100, 200, 300]
irb(main):061> e
=> 100
irb(main):062> f
=> [200, 300]
```
逆に残りの要素をすべて無視したい場合は`*`の後ろの変数名を省略できる。
```ruby
# 100だけeに格納して、残りの要素は無視する
irb(main):063> e, * = 100, 200, 300
=> [100, 200, 300]
irb(main):064> e
=> 100

# *そのものを省略して、,で終わっても同じ結果になる
# ただし、残りの要素を無視するような多重代入を見かけることはあまりない
irb(main):066> e, = 100, 200, 300
=> [100, 200, 300]
irb(main):067> e
=> 100
```
`*`を使った多重代入の応用パターン
```ruby
irb(main):068> a, *b, c, d = 1, 2, 3, 4, 5
=> [1, 2, 3, 4, 5]
irb(main):069> a
=> 1
irb(main):070> b
=> [2, 3]
irb(main):071> c
=> 4
irb(main):072> d
=> 5
```
`*`は「左辺に対応する変数がない残りの要素」が代入されるため、残りの要素が1つもない場合は、b は**空の配列**になる。
```ruby
irb(main):079> a, *b, c, d = 1, 2, 3
=> [1, 2, 3]
irb(main):080> a
=> 1
irb(main):081> b
=> []
irb(main):082> c
=> 2
irb(main):083> d
=> 3
```

##### 1つの配列を複数の引数や when節の条件として展開する
おさらい：`push`メソッドの説明では`a.push(2, 3)`のようにして、複数の要素を一度に追加できる。
```ruby
irb(main):084> a = []
=> []
irb(main):085> a.push(1)
=> [1]
irb(main):086> a
=> [1]
# 複数の要素を一度に追加する
irb(main):087> a.push(2, 3)
=> [1, 2, 3]
irb(main):088> a
=> [1, 2, 3]
```
メソッドの引数に配列を渡すとき、「1つの配列」ではなく、配列を展開して「複数の引数」として渡したい場合は、配列の前に`*`（**splat演算子**）を置く。
```ruby
irb(main):094> a = []
=> []
irb(main):095> b = [2, 3]
=> [2, 3]
irb(main):096> a.push(1)
=> [1]
# 配列を*付きで追加する（a.push(2, 3)と同じ）
irb(main):097> a.push(*b)
=> [1, 2, 3]
irb(main):098> a
=> [1, 2, 3]
```
配列を引数に渡す場合は、「1つの配列」として渡したいのか、「複数の引数」として渡したいのか検討し、後者の場合は`*`を使って配列を展開できることを覚えておくこと。

また、case文の when節で`*`を使い配列を複数の条件として展開できる。
```ruby
jp = ['japan', '日本']
country = '日本'
case country
# *により配列が展開され、when 'japan', '日本'と書いたのと同じ意味になる
when *japan
  'こんにちは'
end
#=> "こんにちは"
```

##### メソッドの可変長引数
配列の`push`メソッドのように、個数に制限のない引数のことを可変超引数と言う。自分で定義するメソッドで可変超引数を使いたい場合は、引数名の手前に`*`を付ける。
```ruby
def メソッド名(引数1, 引数2, *可変長引数)
  # メソッドの処理
end
```
可変長引数は配列として受け取ることができる。
```ruby
def greet(*names)
  "#{names.join('と')}、こんにちは！"
end
greet('田中さん')                           #=> "田中さん、こんにちは！"
greet('田中さん', '鈴木さん')               #=> "田中さんと鈴木さん、こんにちは！"
greet('田中さん', '鈴木さん', '佐藤さん')   #=> "田中さんと鈴木さんと佐藤さん、こんにちは！"
```

##### * で配列同士を破壊的に連結する
`[]`の中に`*`付きで別の配列を置くと、その配列が展開されて別々の要素になる。
```ruby
irb(main):100> a = [1, 2, 3]
=> [1, 2, 3]
# []の中にそのまま配列を置くと、入れ子になった配列（ネストした配列）になる
irb(main):101> [a]
=> [[1, 2, 3]]
# *付きで配列を置くと、展開されて別々の要素になる
irb(main):102> [*a]
=> [1, 2, 3]
```
↑これを利用して、別の配列を要素の一部とする新しい配列を作る
```ruby
a = [1, 2, 3]
[-1, 0, *a, 4, 5]   #=> [-1, 0, 1, 2, 3, 4, 5]
```
`+`を使うこともできるが、`*`を使ったほうが簡潔なコードになる。
```ruby
a = [1, 2, 3]
[-1, 0] + a + [4, 5]   #=> [-1, 0, 1, 2, 3, 4, 5]
```

##### == で等しい配列かどうか判断する
`==`を使うと、左辺と右辺の配列が等しいかどうかをチェックできる。この場合、配列の全要素を`==`で比較し、すべて等しい場合に「2つの配列は等しい」と判断される。
```ruby
# 配列が等しい場合
[1, 2, 3] == [1, 2, 3]     #=> true

# 配列が等しくない場合
[1, 2, 3] == [1, 2, 4]     #=> false
[1, 2, 3] == [1, 2]        #=> false
[1, 2, 3] == [1, 2, 3, 4]  #=> false
```

##### %記法で文字列の配列を簡潔に作る
配列は`[]`を使って作成することが多いが、文字列については%記法の`%w`または`%W`を使って作成する方法が用意されている。%記法を使うと、カンマではなく空白文字（スペースや改行）が要素の区切り文字となる。また、文字列をシングルクオートやダブルクオートで囲む必要もないため、結果として`[]`を使う場合よりもコードが短くなる。
```ruby
# []で文字列の配列を作成する
['apple', 'melon', 'orange']   #=> ["apple", "melon", "orange"]

# %wで文字列の配列を作成する（!で囲む場合）
%w!apple melon orange!   #=> ["apple", "melon", "orange"]

# %wで文字列の配列を作成する（丸括弧で囲む場合）
%w(apple melon orange)   #=> ["apple", "melon", "orange"]

# 空白文字（スペースや改行）が連続した場合も1つの区切り文字とみなされる
%w(
  apple
  melon
  orange
)
#=> ["apple", "melon", "orange"]
```
値にスペースを含めたい場合は**バックスラッシュ**でエスケープする。
```ruby
irb(main):115> %w(big\ apple small\ melon orange)
=> ["big apple", "small melon", "orange"]
```
式展開や改行文字（`\n`）、タブ文字（`\t`）などを含めたい場合は、%W（大文字のW）を使う。
```ruby
irb(main):116> prefix = 'This is'
irb(main):117> %W(#{prefix}\ an\ apple small\nmelon orange)
=> ["This is an apple", "small\nmelon", "orange"]
```

##### 文字列を配列に変換する
文字列を分解して配列に変換することもできる。
`chars`メソッドは文字列中の1文字1文字を配列の要素に分解するメソッド。
```ruby
irb(main):118> 'Ruby'.chars
=> ["R", "u", "b", "y"]
```
`split`メソッドは引数で渡した区切り文字で文字列を配列に分割するメソッド。
```ruby
irb(main):119> 'Ruby,Java,Python'.split(',')
=> ["Ruby", "Java", "Python"]
```

##### 配列にデフォルト値を設定する
配列の作成には`[]`を使ったが、ほかにも`Array.new`を使う方法もある。
```ruby
# 以下のコードはa = []と同じ
irb(main):120> a = Array.new
=> []
```
`Array.new`に引数を渡すと、その個数分の要素が追加される。この時のデフォルト値は`nil`。
```ruby
irb(main):121> a = Array.new(5)
=> [nil, nil, nil, nil, nil]
irb(main):122> a
=> [nil, nil, nil, nil, nil]
```
さらに第2引数を指定すると、`nil`以外のデフォルト値を設定できる。
```ruby
# 要素が5つで0をデフォルト値とする配列を作成する
irb(main):123> a = Array.new(5, 0)
=> [0, 0, 0, 0, 0]
```
`Array.new`ではブロックを使ってデフォルト値を設定することもできる。ブロックは作成する要素の数だけ呼ばれ、ブロックパラメータには要素の添え字が渡される。配列にはブロックの戻り値がそれぞれデフォルト値として設定される。
```ruby
irb(main):124> a = Array.new(10) { |n| n % 3 + 1}
=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
# インデックスごとの処理
0 % 3 + 1 = 1
1 % 3 + 1 = 2
2 % 3 + 1 = 3
3 % 3 + 1 = 1
4 % 3 + 1 = 2
5 % 3 + 1 = 3
6 % 3 + 1 = 1
7 % 3 + 1 = 2
8 % 3 + 1 = 3
9 % 3 + 1 = 1
```

##### 配列にデフォルト値を設定する場合の注意点
第2引数を使いデフォルト値を指定する場合は注意が必要。
```ruby
# 要素が5つで'default'をデフォルト値とする配列を作成する
irb(main):125> a = Array.new(5, 'default')
=> ["default", "default", "default", "default", "default"]

# 1番目の要素を取得する
irb(main):126> str = a[0]
=> "default"

# 1番目の要素を大文字に変換する（破壊的変更）
irb(main):127> str.upcase!
=> "DEFAULT"

# 配列の要素全てが大文字に変わってしまう
irb(main):128> a
=> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT"]
```
↑このような問題を避けるために、引数ではなくブロックでデフォルト値を渡すようにする。
```ruby
# ブロックを使って、ブロックの戻り値をデフォルト値とする
# （ブロックパラメータには添え字が渡されるが、ここでは使わないのでブロックパラメータを省略）
irb(main):129> a = Array.new(5) { 'default' }
=> ["default", "default", "default", "default", "default"]

# 1番目の要素を取得する
irb(main):130> str = a[0]
=> "default"

# 1番目の要素を大文字に変換する（破壊的変更）
irb(main):131> str.upcase!
=> "DEFAULT"

# 1番目の要素だけが大文字になり、ほかは変わらない
irb(main):132> a
=> ["DEFAULT", "default", "default", "default", "default"]
```
ブロックを使うと、ブロックが呼ばれるたびに文字列の`default`が新しく作成されるので、結果として配列の各要素は別々の文字列を参照することになる。

##### ミュータブル？　イミュータブル？
プログラミングの世界では**ミュータブル（mutable）** と **イミュータブル（immutable）** という言葉が登場する。
###### ミュータブル
- 「変更可能な」という意味。
- オブジェクトには破壊的な変更が適用できる。そのため、配列の要素が同じオブジェクトを参照していると、破壊的な変更によって変わってほしくない値まで一緒に変わってしまう恐れがある。
###### イミュータブル
- 「変更できない、不変の」という意味。
- オブジェクトでは破壊的な変更が適用できない。そのため、ブロックを使わずにデフォルト値を設定しても、文字列で発生したような不具合は発生しない。

Ruby には常にイミュータブルなクラスや値がいくつかある。以下のデータ型はイミュータブルな値（クラス）の一例。
- **数値（IntegerクラスやFloatくらす）**
- **シンボル（Symbolクラス）**
- **true/false（TrueClassクラスとFalseClassクラス）**
- **nil（NilClassクラス）**
- **範囲（Rangeクラス）**

この考え方に従うと、以下のようなコードはブロックを使わなくてもほかの要素が一緒に変更される問題が起きない。
```ruby
# 要素が5つで0をデフォルト値とする配列を作成する
irb(main):134> a = Array.new(5, 0)
=> [0, 0, 0, 0, 0]

# 1番目の要素を取得する
irb(main):135> n = a[0]
=> 0
```

#### 4.8 ブロックについてもっと詳しく
##### 添え字付きの繰り返し処理
Ruby では`each`メソッドを使うのが繰り返し処理の基本。しかし、`each`メソッドでは何番目の要素を処理しているのか、ブロック内では判別できない。繰り返し処理をしつつ、処理している要素の添え字も取得したいときは、`each_with_index`メソッドを使う。このメソッドを使うと、ブロックパラメータの第2パラメータに添え字を渡してくれる。
```ruby
irb(main):137> fruits = ['apple', 'orange', 'melon']
=> ["apple", "orange", "melon"]
# ブロックパラメータのiには0, 1, 2...と要素の添え字が入る
irb(main):138> fruits.each_with_index { |fruit, i| puts "#{i}: 
#{fruit}" }
0: apple
1: orange
2: melon
=> ["apple", "orange", "melon"]
```

##### with_indexメソッドを使った添え字付きの繰り返し処理
`each_with_index`メソッドは`each`メソッドの代わりにしか使えない。たとえば`map`メソッドで繰り返し処理をしつつ、添え字も同時に取得したいときは、`with_index`メソッドを組み合わせて使う。
```ruby
fruits = ['apple', 'orange', 'melon']
# mapとして処理しつつ、添え字も受け取る
irb(main):139> fruits.map.with_index { |fruit, i| "#{i}: #{fruit}" }
=> ["0: apple", "1: orange", "2: melon"]
```
`with_index`メソッドは`map`以外のメソッドとも組み合わせることができる。
```ruby
fruits = ['apple', 'orange', 'melon']
# 名前に"a"を含み、なおかつ添え字が奇数である要素を削除する
irb(main):140> fruits.delete_if.with_index { |fruit, i| fruit.i
nclude?('a') && i.odd? }
=> ["apple", "melon"]
```
`with_index`メソッドは、`Enumerator`クラスのインスタンスメソッド。`each`メソッド、`map`メソッド、`delete_if`メソッドなど繰り返し処理を行うメソッドの大半はブロックを省略して呼び出すと、`Enumerator`オブジェクトを返すようになっている。
```ruby
fruits = ['apple', 'orange', 'melon']
# ブロックなしでメソッドを呼ぶとEnumeratorオブジェクトが返る。よってwith_indexメソッドが呼び出せる
irb(main):143> p fruits.each
#<Enumerator: ["apple", "orange", "melon"]:each>
=> #<Enumerator: ...>
irb(main):144> p fruits.map
#<Enumerator: ["apple", "orange", "melon"]:map>
=> #<Enumerator: ...>
irb(main):145> p fruits.delete_if
#<Enumerator: ["apple", "orange", "melon"]:delete_if>
=> #<Enumerator: ...>
```
##### 添え字を0以外の数値から開始させる
添え字はいつも0から始まるが、これを0以外の数値から始めたい場合は、`with_index`メソッドに引数を渡す。
```ruby
fruits = ['apple', 'orange', 'melon']

# eachで繰り返しつつ、1から始まる添え字を取得する
irb(main):147> fruits.each.with_index(1) { |fruit, i| puts "#{i}: #{fruit}" }
1: apple
2: orange
3: melon
=> ["apple", "orange", "melon"]

# mapで処理しつつ、10から始まる添え字を取得する
irb(main):148> fruits.map.with_index(10) { |fruit, i| "#{i}: #{
fruit}" }
=> ["10: apple", "11: orange", "12: melon"]
```

##### 配列がブロックパラメータに渡される場合
配列の配列に対して繰り返し処理を実行すると、ブロックパラメータに配列が渡ってくる。たとえば、縦の長さと横の長さを配列に格納し、それを複数用意した配列があったとする。
```ruby
dimensions = [
  # [縦, 横]
  [10, 20],
  [30, 40],
  [50, 60],
]
```
これを`each`メソッドなどで繰り返し処理すると、配列がブロックパラメータに渡ってくる。
```ruby
irb(main):149* dimensions = [
irb(main):150*   [10, 20],
irb(main):151*   [30, 40],
irb(main):152*   [50, 60],
irb(main):153> ]
=> [[10, 20], [30, 40], [50, 60]]
irb(main):154> areas = []
=> []
irb(main):155* dimensions.each do |dimension|
irb(main):156*   length = dimension[0]
irb(main):157*   width = dimension[1]
irb(main):158*   areas << length * width
irb(main):159> end
=> [[10, 20], [30, 40], [50, 60]]
irb(main):160> areas
=> [200, 1200, 3000]
```
ブロックパラメータの数を2個にすると、縦と横の値を別々に受け取ることができ、シンプルに書くことができる。
```ruby
dimensions = [
  # [縦, 横]
  [10, 20],
  [30, 40],
  [50, 60],
]
# 面積の計算結果を格納する配列
areas = []
# 配列の要素分だけブロックパラメータを用意すると、各要素の値が別々の変数に格納される
irb(main):169* dimensions.each do |length, width|
irb(main):170*   areas << length * width
irb(main):171> end
=> [[10, 20], [30, 40], [50, 60]]
irb(main):172> areas
=> [200, 1200, 3000, 200, 1200, 3000]
```
ブロックパラメータが多すぎる場合は、はみ出しているブロックパラメータは`nil`になる。
```ruby
# lengthとwidthには値が渡されるが、fooとbarはnilになる
irb(main):173* dimensions.each do |length, width, foo, bar|
irb(main):174*   p [length, width, foo, bar]
irb(main):175> end
[10, 20, nil, nil]
[30, 40, nil, nil]
[50, 60, nil, nil]
=> [[10, 20], [30, 40], [50, 60]]
```
配列の要素が3個あるのに、ブロックパラメータが2個しかない場合は3つ目の値が捨てられる。このようなコードを書くことは避けること。
```ruby
dimensions = [
  [10, 20, 100],
  [30, 40, 200],
  [50, 60, 300],
]

# 3つの値をブロックパラメータに渡そうとするが、2つしかないので3つ目の値は捨てられる
irb(main):188* dimensions.each do |length, width|
irb(main):189*   p [length, width]
irb(main):190> end
[10, 20]
[30, 40]
[50, 60]
=> [[10, 20, 100], [30, 40, 200], [50, 60, 300]]
```
`each_with_index`のように、もとからブロックパラメータを2つ受け取る場合は、配列の要素を受け取るブロックパラメータを`()`で囲むと、配列の要素を別々のパラメータとして受け取ることができる。
```ruby
dimensions = [
  [10, 20],
  [30, 40],
  [50, 60],
]
# ブロックパラメータを()で囲んで、配列の要素を別々のパラメータとして受け取る
irb(main):196* dimensions.each_with_index do |(length, width), i|
irb(main):197*   puts "length: #{length}, width: #{width}, i: #{i}"
irb(main):198> end
length: 10, width: 20, i: 0
length: 30, width: 40, i: 1
length: 50, width: 60, i: 2
=> [[10, 20], [30, 40], [50, 60]]
```
`()`を使った配列の分解はブロックパラメータだけでなく、入れ子になった配列を変数に多重代入する場合にも適用できる。
```ruby
# ()を使わない場合はdimensionに配列の[10, 20]が代入される
irb(main):202> dimension, i = [[10, 20], 0]
=> [[10, 20], 0]
irb(main):203> dimension
=> [10, 20]
irb(main):204> i
=> 0

# ()を使うと内側の配列の要素（10と20）を別々の変数（lengthとwidth）に代入できる
irb(main):205> (length, width), i = [[10, 20], 0]
=> [[10, 20], 0]
irb(main):206> length
=> 10
irb(main):207> width
=> 20
irb(main):208> i
=> 0
```

-------------


## ✍🏻 感想
### 🍒 記憶ではなく理解すること
理解に時間がかかり、難しくなってきました。配列は知っておかなければならないことがたくさんあります。記憶するのではなく、**仕組みを理解する**という意識を持って、次回も学んでいきます。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 6 hours 25 min
- Total: 890 hours 57 min
