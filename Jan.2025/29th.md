# 2025/01/29(水)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第5章  ハッシュやシンボルを理解する
    - 5.6 ハッシュとキーワード引数についてもっと詳しく
      - 5.6.8 ハッシュから配列へ、配列からハッシュへ
      - 5.6.9 ハッシュのデフォルト値を理解する


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第5章  ハッシュやシンボルを理解する
    - 5.6 ハッシュとキーワード引数についてもっと詳しく
      - 5.6.10 その他、キーワード引数に関する高度な話題


------------


## 💡 本日の学び・気付き
### 5.6 ハッシュとキーワード引数についてもっと詳しく
#### ハッシュから配列へ、配列からハッシュへ
ハッシュは to_aメソッドを使い、配列に変換することができる。to_aメソッドを使うと**キーと値が1つの配列に入り、さらにそれが複数並んだ配列**になって返る。
```ruby
currencies = { japan: 'yen', us: 'dollar', india: 'rupee' }
irb(main):065> currencies.to_a
=> [[:japan, "yen"], [:us, "dollar"], [:india, "rupee"]]
```
配列に対して to_hメソッドを呼ぶと、配列をハッシュに変換することができる。**ハッシュに変換する配列はキーと値の組み合わせごとに1つの配列に入り、それが要素の分だけ配列として並んでいる必要がある**。
```ruby
array = [[:japan, "yen"], [:us, "dollar"], [:india, "rupee"]]
irb(main):067> array.to_h
=> {:japan=>"yen", :us=>"dollar", :india=>"rupee"}
```
ハッシュとして解析不能な配列に対して to_hメソッドを呼ぶとエラーになる。
```ruby
array = [1, 2, 3, 4]
irb(main):069> array.to_h
wrong element type Integer at 0 (expected array) (TypeError)
```
キーが重複した場合は最後に登場した配列の要素がハッシュの値に採用される。しかし、不具合を生む原因になるため、特別な理由がない限りキーは必ず一意な値にしておくこと。
```ruby
array = [[:japan, "yen"], [:japan, "円"]]
# 最後に登場した配列の要素がハッシュの値に採用される
irb(main):071> array.to_h
=> {:japan=>"円"}
```
Ruby 2.1 より前の時代はキーと値のペアの配列を Hash[] に対して渡すことで配列をハッシュに変換していた。
```ruby
# キーと値のペアの配列をHash[]に渡す
array = [[:japan, "yen"], [:us, "dollar"], [:india, "rupee"]]
irb(main):073> Hash[array]
=> {:japan=>"yen", :us=>"dollar", :india=>"rupee"}

# キーと値が交互に並ぶフラットな配列を*月で渡しても良い
array = [:japan, "yen", :us, "dollar", :india, "rupee"]
irb(main):075> Hash[*array]
=> {:japan=>"yen", :us=>"dollar", :india=>"rupee"}
```
##### おさらい：splat演算子とは？
メソッドの引数に配列を渡すとき、「1つの配列」ではなく、「複数の引数」として渡したい場合に、配列の前に\*を置く。このときの「\*」を splat演算子と言う。

#### ハッシュのデフォルト値を理解する
ハッシュに対して存在しないキーを指定すると nil が返る。
```ruby
h = {}
irb(main):079> h[:foo]
=> nil
```
nil 以外の値を返したいときは、Hash.new でハッシュを作成し、引数にデフォルト値となる値を指定する。
```ruby
# キーがなければ'hello'を返す
h = Hash.new('hello')
irb(main):081> h[:foo]
=> "hello"
```
new の引数としてデフォルト値を指定した場合は、デフォルト値として毎回同じオブジェクトが返る。そのため、デフォルト値に対して破壊的な変更を適用すると、他の変数の値も一緒に変わってしまう。
```ruby
h = Hash.new('hello')
irb(main):083> a = h[:foo]
=> "hello"
irb(main):084> b = h[:bar]
=> "hello"

# 変数aと変数bは同一オブジェクト
irb(main):085> a.equal?(b)
=> true

# 変数aに破壊的な変更を適用すると、変数bの値も一緒に変わってしまう
irb(main):086> a.upcase!
=> "HELLO"
irb(main):087> a
=> "HELLO"
irb(main):088> b
=> "HELLO"

# ハッシュ自身は空のままになっている
irb(main):089> h
=> {}
```
文字列や配列など、ミュータブルなオブジェクトをデフォルト値として返す場合は Hash.new とブロックを組み合わせてデフォルト値を返すことで、このような問題を避けることができる。
```ruby
# キーが見つからないとブロックがその都度実行され、ブロックの戻り値がデフォルト値になる
h = Hash.new { 'hello' }
irb(main):091> a = h[:foo]
=> "hello"
irb(main):092> b = h[:bar]
=> "hello"

# 変数aと変数bは異なるオブジェクト（ブロックの実行時に毎回新しい文字列が作成される）
irb(main):093> a.equal?(b)
=> false

# 変数aに破壊的な変更を適用しても、変数bの値は変わらない
a.upcase!
irb(main):095> a
=> "HELLO"
irb(main):096> b
=> "hello"

# ハッシュは空のまま
irb(main):097> h
=> {}
```
Hash.new にブロックを与えると、ブロックパラメータとしてハッシュ自身と見つからなかったキーが渡される。そこでこのブロックパラメータを使い、ハッシュにキーとデフォルト値も同時に設定するコードもよく使われる。
```ruby
# デフォルト値を返すだけでなく、ハッシュに指定されたキーとデフォルト値を同時に設定する
h = Hash.new { |hash, key| hash[key] = 'hello' }
irb(main):099> h[:foo]
=> "hello"
irb(main):100> h[:bar]
=> "hello"

# ハッシュにキーと値が追加されている
irb(main):101> h
=> {:foo=>"hello", :bar=>"hello"}
```


-------------


## ✍🏻 感想
### 🍒 ミュータブルとイミュータブル、破壊的と非破壊的ってめっちゃ大事！
今日の学習で「面白いなぁ！」と感じたのが、文字列や配列などでミュータブルなオブジェクトをデフォルト値として返す場合の書き方です。`()`と`{}`、記号一つでオブジェクトの状態が変わることが面白かったです。

『ゼロからわかるRuby超入門』では、破壊的と非破壊的を知り、『プロを目指す人のためのRuby入門』ではさらにミュータブルとイミュータブルについて学びました。これらの概念はコードの可読性に大きく影響される大事な要素だと感じました。まずは、これらの概念を理解し、いざコードを書くときには適切に使い分けられるようになりたいですね。

### 🗣️ コミュニケーション、めっちゃ大事！
Discord の雑談部屋で :@naomik92:なおさん、:@tadaaki:ただあきさん、:@unikounio:うにおさん（※Discordの表示順）に、心の中で絡まっていた問題を解きほぐしていただきました。朝から家事で疲れていたのですがお声を聴いてたくさん元気をもらいました。皆さんの素敵なお人柄と、素敵な FBC のコミュニティに感謝です！ありがとうございました😊🙏🏻また、お話しましょうね👋🏻


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 02 min
- Total: 912 hours 20 min
