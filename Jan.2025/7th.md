# 2025/01/07(火)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [ ] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [ ] 2.6 メソッドの定義
   - [ ] 2.7 例題：FizzBuzzプログラムを作成する
   - [ ] 2.8 文字列についてもっと詳しく
   - [ ] 2.9 数値についてもっと詳しく
   - [ ] 2.10 真偽値と条件分岐についてもっと詳しく
   - [ ] 2.11 メソッド定義についてもっと詳しく
   - [ ] 2.12 そのほかの基礎知識
   - [ ] 2.13 この章のまとめ
- [ ] 第3章  テストを自動化する
   - [ ] 3.1 イントロダクション
   - [ ] 3.2 Minitest の基本
   - [ ] 3.3 FizzBuzzプログラムのテスト自動化
   - [ ] 3.4 この章のまとめ
- [ ] 第4章  配列や繰り返し処理を理解する
   - [ ] 4.1 イントロダクション
   - [ ] 4.2 配列
   - [ ] 4.3 ブロック
   - [ ] 4.4 ブロックを使う配列のメソッド
   - [ ] 4.5 範囲（Range）
   - [ ] 4.6 例題：RGB変換プログラムを作成する
   - [ ] 4.7 配列についてもっと詳しく
   - [ ] 4.8 ブロックについてもっと詳しく
   - [ ] 4.9 範囲（Range）についてもっと詳しく
   - [ ] 4.10 さまざまな繰り返し処理
   - [ ] 4.11 繰り返し処理用の制御構造
   - [ ] 4.12 この章のまとめ
- [ ] 第5章  ハッシュやシンボルを理解する
   - [ ] 5.1 イントロダクション
   - [ ] 5.2 ハッシュ
   - [ ] 5.3 シンボル
   - [ ] 5.4 続・ハッシュについて
   - [ ] 5.5 例題：長さの単位交換プログラムを作成する
   - [ ] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [ ] 5.7 シンボルについてもっと詳しく
   - [ ] 5.8 この章のまとめ
- [ ] 第6章  正規表現を理解する
   - [ ] 6.1 イントロダクション
   - [ ] 6.2 正規表現って何？
   - [ ] 6.3 Ruby における正規表現オブジェクト
   - [ ] 6.4 例題：Ruby のハッシュ記法を変換する
   - [ ] 6.5 正規表現オブジェクトについてもっと詳しく
   - [ ] 6.6 この章のまとめ
- [ ] 第7章  クラスの作成を理解する
   - [ ] 7.1 イントロダクション
   - [ ] 7.2 オブジェクト指向プログラミングの基礎知識
   - [ ] 7.3 クラスの定義
   - [ ] 7.4 例題：改札機プログラムの作成
   - [ ] 7.5 selfキーワード
   - [ ] 7.6 クラスの継承
   - [ ] 7.7 メソッドの可視性
   - [ ] 7.8 定数についてもっと詳しく
   - [ ] 7.9 さまざまな種類の変数
   - [ ] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [ ] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [ ] 8.1 イントロダクション
   - [ ] 8.2 モジュールの概要
   - [ ] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [ ] 8.4 例題：rainbowメソッドの作成
   - [ ] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [ ] 8.6 モジュールを利用した名前空間の作成
   - [ ] 8.7 関数や定数を提供するモジュールの作成
   - [ ] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


------------


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第2章  Ruby の基礎を理解する
      - 2.3 文字列 〜 2.5 真偽値と条件分岐 まで

## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
   - 第2章  Ruby の基礎を理解する
      - 2.6 メソッドの定義 〜


------------


## 💡 本日の学び・気付き
### 🍒 プロを目指す人のためのRuby入門 <改訂2版>
#### 2.3 文字列
##### シングルクオートとダブルクオート
Ruby では文字列を作る方法で、最も一般的なのはシングルクオート（`'`）、またはダブルクオート（`"`）で囲む方法。文字列としての違いはないが、シングルクオートとダブルクオートでは挙動が異なる点がある。たとえば、文字列中に改行文字（`\n`）を埋め込みたい場合は、ダブルクオートで囲む必要がある。
```ruby
# ダブルクオートで囲むと\nが改行文字として機能するして機能する
puts "こんにちは\nさようなら"
#=> こんにちは
#   さようなら

# シングルクオートで囲むと\nはただの文字列になる
puts 'こんにちは\nさようなら'
#=> こんにちは\nさようなら
```
`\n`の他にも、`\r`（キャリッジリターン）や`\t`（タブ文字）がある（バックスラッシュ記法）。
また、ダブルクオートを使うと**式展開**が使える。式展開を使う場合は`#{ }`の中に変数や式を書く。こうすると、変数の値や式の結果が文字列の中に埋め込まれる。
```ruby
name = 'Alice'
puts "Hello, #{name}!" #=> Hello, Alice!

i = 10
puts "#{i}は16進数にすると#{i.to_s(16)}です" #=> 10は16進数にするとaです
```
シングルクオートを使う場合は式展開されない。`#{ }`はただの文字列とみなされる。
```ruby
name = 'Alice'
puts 'Hello, #{name}!' #=> Hello, #{name}!
```
式展開を使わず、+演算子で文字列を連結することもできるが、**式展開を使った方が読み書きしやすいケースが多い**。
```ruby
name = 'Alice'
puts 'Hello, ' + name + '!' #=> Hello, Alice!
```
ダブルクオートを使う文字列で、**改行文字や式展開の機能を打ち消したい**場合は**手前にバックスラッシュ**を付ける。
```ruby
puts "こんにちは\\nさようなら" #=> こんにちは\nさようなら

name = 'Alice'
puts "Hello, \#{name}!" #=> Hello, Alice!
```
シングルクオート文字列の中にシングルクオート、ダブルクオート文字列の中でダブルクオートを含めたい場合も手前にバッグスラッシュを付ける。
```ruby
puts 'He said, "Don\'t speak."' #=> He said, "Don't speak."

puts "He said, \"Don't speak.\"" #=> He said, "Don't speak."
```
特別な意味を持つ文字の機能を打ち消し、ただの文字として扱えるようにすることを**エスケープ処理**と言う。

##### 文字列の比較
文字列が同じ値かどうか調べる場合は`==`を、異なる値かどうかを調べる場合は`!=`を使う。
```ruby
'ruby' == 'ruby' #=> true
'ruby' == 'Ruby' #=> false
'ruby' != 'perl' #=> true
'ruby' != 'ruby' #=> false
```
`<`、`<=`、`>`、`>=`を使って、大小関係を比較することも可能。この場合、文字列を構成するバイト値が大小比較の基準になる。
```ruby
'a' < 'b' #=> true
'a' < 'A' #=> false
'a' > 'b' #=> true
'abc' < 'def' #=> true
'abc' < 'ab' #=> false
'abc' < 'abcd' #=> true
'あいうえお' < 'かきくけこ' #=> true
```
文字列を構成するバイト値の具体的な値は**bytesメソッド**で確認できる。
```ruby
irb(main):013> 'a'.bytes
=> [97]
irb(main):014> 'b'.bytes
=> [98]
irb(main):015> 'A'.bytes
=> [65]
irb(main):016> 'abc'.bytes
=> [97, 98, 99]
irb(main):017> 'あ'.bytes
=> [227, 129, 130]
```

#### 2.4 数値
数値には`_`を含めることができる。`_`は無視されるので、大きな数の区切り文字として使うと便利。
```ruby
irb(main):018> 1_000_000_000
=> 1000000000
```
変数の手前に`-`を付けると、数値の正と負を反転できる。
```ruby
irb(main):019> n = 1
=> 1
irb(main):020> -n
=> -1
```
整数同士の割り算は整数になる。小数点以下は切り捨てられる。
```ruby
irb(main):021> 1 / 2
=> 0
```
小数点以下の値が必要な場合は、どちらかの値に小数点の`.0`を付ける。
```ruby
irb(main):022> 1.0 / 2
=> 0.5
irb(main):023> 1 / 2.0
=> 0.5
```
変数に整数が入っている場合は、**to_fメソッド**を呼ぶことで整数から小数に変更することができる。
```ruby
irb(main):024> n = 1
=> 1
irb(main):025> n.to_f
=> 1.0
irb(main):026> n.to_f / 2
=> 0.5
```
`%`は割り算の余りを求める演算子。
```ruby
irb(main):027> 8 % 3
=> 2
```
`**`は冪乗を求める演算子。
```ruby
irb(main):028> 2 ** 3
=> 8
```

##### 演算子の優先順位
```
高い  ::
      []
      + （単項）  !  ~
      **
      - （単項）
      * / %
      + -
      << >>
      &
      | ^
      > >= < <=
      <=> == === != =- !~
      &&
      ||
      .. ...
      ?: （条件演算子）
      = （+=、-= ・・・）
      not
低い  and or
```

##### 変数に格納された数値の増減
Ruby には変数の値を増幅させる ++ や -- のような演算子がない。これに近い演算子として、`+=`と`-=`が用意されている。
```ruby
irb(main):029> n = 1
=> 1
irb(main):030> n += 1
=> 2
irb(main):031> n -= 1
=> 1
```
同様に、`*=`、`/=`、`**=`も使える。
```ruby
irb(main):040> n = 2
=> 2
irb(main):041> n *= 3
=> 6
irb(main):042> n /= 2
=> 3
irb(main):043> n **= 2
=> 9
```

##### 数値と文字列は暗黙的に変換されない
Ruby では**to_iメソッド**や**to_fメソッド**を使って明示的に文字列を数値に変換する必要がある。
```ruby
# 数値と文字列を+演算子で加算することはできない
irb(main):044> 1 + '10'
(irb):44:in `+': String can't be coerced into Integer (TypeError)

# 文字列は数値に変換する必要がある
# 整数に変換
irb(main):045> 1 + '10'.to_i
=> 11

# 小数に変換
# fは「float」を意味し、文字列を浮動小数点数（小数点を含む数値）に変換する
irb(main):046> 1 + '10.5'.to_f
=> 11.5
```
反対に文字列に数値を直接連結することもできない。**to_sメソッド**を使って数値を文字列に変換する必要がある。
```ruby
irb(main):047> number = 3
=> 3

# 文字列に数値を+演算子で連結することはできない
irb(main):048> 'Number is' + number
(irb):48:in `+': no implicit conversion of Integer into String (TypeError)

# 数値を文字列に変換する必要がある
irb(main):049> 'Number is ' + number.to_s
=> "Number is 3"
```
式展開`#{}`を使った場合は、自動的に**to_sメソッド**が呼ばれるため、文字列に変換する必要はない。
```ruby
irb(main):051> "Number is #{number}"
=> "Number is 3"
```

##### 小数を使う場合は丸め誤差に注意
コンピュータの内部では10新数ではなく進数で計算しているため、**丸め誤差**が発生してしまう。丸め誤差が発生すると、数値の大小を比較したりする際に思わぬバグを引き起こしてしまう。たとえば、0.1 * 0.3 のようなコードでは**Rational（有理数）クラス**を使うと期待通りの結果が得られる。Ruby では`0.1r`のように**r**を付けると、Rationalクラスの数値になる。
```ruby
# Rationalクラスを使うと少数ではなく「10分の3」という計算結果が返る
irb(main):053> 0.1r * 3.0r
=> (3/10)

# Rationalクラスであれば期待したとおりに値の比較ができる
irb(main):054> 0.1r * 3r == 0.3
=> true

irb(main):055> 0.1r * 3r <= 0.3
=> true
```
変数に値が入っている場合は、**rationalizeメソッド**を呼ぶことでRationalクラスの数値に変換できる。
```ruby
irb(main):056> a = 0.1
=> 0.1
irb(main):057> b = 3.0
=> 3.0
irb(main):058> a.rationalize * b.rationalize
=> (3/10)
```

#### 2.5 真偽値と条件分岐
##### Ruby の真偽値
Ruby の真偽値は次のようなルールを持っている。
- false または nil であれば偽。
- それ以外はすべて真。
```ruby
# trueそのもの
true

# すべての数値
1
0
-1

# すべての文字列
'true'
'false'
''
```

##### 論理演算子
`&&`や `||`のような論理演算子を使うと、複数の条件を1つにまとめることができる。`条件1 && 条件2`は「条件1かつ条件2」の意味で、**条件1も条件2も真であれば真になる**。
```ruby
# 条件1も条件2も真であれば真、それ以外は偽
条件1 && 条件2
```
```ruby
irb(main):061> t1 = true
=> true
irb(main):062> t2 = true
=> true
irb(main):063> f1 = false
=> false
irb(main):064> t1 && t2
=> true
irb(main):065> t1 && f1
=> false
```
`条件1 || 条件2`は「条件1または条件2」の意味で、**条件1か条件2のいずれかが真であれば真になる**。
```ruby
# 条件1か条件2のいずれかが真であれば真、両方偽であれば偽
条件1 || 条件2
```
```ruby
irb(main):066> t1 = true
=> true
irb(main):067> f1 = false
=> false
irb(main):068> f2 = false
=> false
irb(main):069> t1 || f1
=> true
irb(main):070> f1 || f2
=> false
```
`&&`と`||`を組み合わせて使うこともできる。
```ruby
条件1 && 条件2 || 条件3 && 条件4
```
&& の優先順位は || より高いため、上の式は「条件1かつ条件2が真、または条件3かつ条件4が真なら真」という意味になる。
```ruby
# &&は||よりも優先順位が高いので、次のように解釈される
(条件1 && 条件2) || (条件3 && 条件4)
```
```ruby
irb(main):071> t1 = true
=> true
irb(main):072> t2 = true
=> true
irb(main):073> f1 = false
=> false
irb(main):074> f2 = false
=> false
irb(main):075> t1 && t2 || f1 && f2
=> true
#上の式と下の式は同じ意味
irb(main):076> (t1 && t2) || (f1 && f2)
=> true
```
優先順位を変えたい場合は`()`を使う。次のように書くと「条件1が真かつ、条件2または条件3が真かつ、条件4が真なら真」という意味になる。
```ruby
条件1 && (条件2 || 条件3) && 条件4
```
```ruby
irb(main):077> t1 = true
=> true
irb(main):078> t2 = true
=> true
irb(main):079> f1 = false
=> false
irb(main):080> f2 = false
=> false
irb(main):081> t1 && (t2 || f1) && f2
=> false
```
!演算子を使うと真偽値を反転することができる。真が偽に、偽が真になる。
```ruby
irb(main):082> t1 = true
=> true
irb(main):083> f1 = false
=> false
irb(main):084> !t1
=> true
irb(main):085> !f1
```
`( )`と組み合わせると、`( )`の中の真偽値を反転させることができる。
```ruby
irb(main):086> t1 = true
=> true
irb(main):087> f1 = false
=> false
irb(main):088> t1 && f1
=> false
irb(main):089> !(t1 && f1)
=> true
```

##### if 文
Ruby の if 文は次のように書く。
```ruby
if 条件A
  # 条件Aが真だった場合の処理
elsif 条件B
  # (条件Aが偽で)条件Bが真だった場合の処理
elsif 条件C
  # (条件AもBも偽で)条件Cが真だった場合の処理
else
  # それ以外の条件の処理
end
```
条件を複数指定する場合は**elsif**である点に注意すること。また、elsif や else が不要なら省略可能。
```ruby
if 条件A
  # 条件Aが真だった場合の処理
end
```
たとえば、与えられた数値が10より大きいかどうかで処理を変える場合は次のように書く。
```ruby
irb(main):090> n = 11
=> 11
irb(main):091* if n > 10
irb(main):092*   puts '10より大きい'
irb(main):093* else
irb(main):094*   puts '10以下'
irb(main):095> end
10より大きい
```
国によってあいさつを変えたい場合は次のように書く。
```ruby
irb(main):106> country = 'italy'
=> "italy"
irb(main):107* if country == 'japan'
irb(main):108*   puts 'こんにちは'
irb(main):109* elsif country == 'us'
irb(main):110*   puts 'Hello'
irb(main):111* elsif country == 'italy'
irb(main):112*   puts 'Ciao'
irb(main):113* else
irb(main):114*   puts '???'
irb(main):115> end
Ciao
```
irb などで実行する場合は puts を使わなくても if 文の戻り値を見ることで、どの条件が実行されたのか確認できる。
```ruby
irb(main):116> country = 'italy'
=> "italy"
irb(main):117* if country == 'japan'
irb(main):118*   'こんにちは'
irb(main):119* elsif country == 'us'
irb(main):120*   'Hello'
irb(main):121* elsif country == 'italy'
irb(main):122*   'Ciao'
irb(main):123* else
irb(main):124*   '???'
irb(main):125> end
=> "Ciao"
```
「if 文が戻り値を返す」という性質を利用して、if 文の戻り値を変数に代入することもできる。
```ruby
irb(main):140* greeting =
irb(main):141*   if country == 'japan'
irb(main):142*     'こんにちは'
irb(main):143*   elsif country == 'us'
irb(main):144*     'Hello'
irb(main):145*   elsif country == 'italy'
irb(main):146*     'Ciao'
irb(main):147*   else
irb(main):148*     '???'
irb(main):149>   end
irb(main):150> greeting
=> "Ciao"
```
else節がなく、なおかつどの条件にも合致しなかった場合は nil が返る（falseではない）。
```ruby
irb(main):152* greeting =
irb(main):153*   if country == 'japan'
irb(main):154*     'こんにちは'
irb(main):155*   elsif country == 'us'
irb(main):156*     'Hello'
irb(main):157>   end
irb(main):158> greeting
=> nil
```
Ruby の if 文は修飾子として文の後ろに置くことができる。if 修飾子は、後置 if と呼ばれることもある。
```ruby
point = 7
day = 1
if day == 1
  point *= 5
end
point

# 上のコードはif文を修飾子として使うことで以下のように書くことができる
point = 7
day = 1
point *= 5 if day == 1
point
```
if と elsif の後ろには**then**を入れることもできる。
```ruby
if 条件A then
  # 条件Aが真だった場合の処理
elsif 条件B then
  # （条件Aが偽で）条件Bが真だった場合の処理
else
  # それ以外の条件の処理
end
```
**then**を入れると、条件式とその条件が真だった場合の処理を1行に押し込めることができるが、使用頻度はあまり高くない。
```ruby
irb(main):170* if country == 'japan' then 'こんにちは'
irb(main):171* elsif country == 'us' then 'Hello'
irb(main):172* elsif country == 'italy' then 'Ciao'
irb(main):173* else '???'
irb(main):174> end
=> "Ciao"
```


### 🥘 Rubyコードレシピ集
#### 001 Rubyスクリプトを実行したい
**コマンドラインからRubyスクリプトを実行**
```shell
% ruby ファイル名
```
コマンドラインからRubyスクリプトを実行するにはrubyコマンドを使う。
- **Rubyスクリプト**：Rubyのプログラムが書かれたテキストファイルのこと。
- Rubyスクリプトのファイルの拡張子は一般的に**.rb**を使う。
Rubyスクリプトを実行するには、引数にそのファイル名を指定してrubyコマンドを実行する。
たとえば、test.rbという名前のファイルがあり、その中身には`puts 'hello, world'`とあったとする。このとき、次のコマンドを実行するとスクリプトに書かれたRubyのプログラムを実行できる。
```shell
% ruby test.rb
hello, world
```

#### 002 標準出力に文字列を出力したい
**文字列を標準出力に出力**
```ruby
puts 文字列
```
**オブジェクトを文字列として標準出力に出力**
```ruby
puts オブジェクト
```
Ruby で標準出力に文字列を出力したいときは**puts**を使う。
**puts**に引数として文字列を渡すと、その文字列が標準出力される。また、**puts**には引数として文字列だけでなくどんなオブジェクトでも渡せる。
**puts**には、カンマ区切りで0個以上の引数を渡すことができる。引数が0個のときは改行文字だけを出力する。複数の引数を渡すと、それらの引数を改行区切りで出力する。
```ruby
# 複数の引数をそれぞれ出力
irb(main):180> puts '1', '2 3', '4 5 6'
1
2 3
4 5 6

# 改行だけ出力
irb(main):181> puts

# 配列を渡す。1は文字列の'1'に変換して出力
irb(main):182> puts [1, 'あ']
1
あ
```

#### 003 コメントを書きたい
**コメントの記述**
```ruby
# コメント
```
Ruby のプログラムにコメントを書きたいときは、ナンバーサイン**#**を使う。
ただし、文字列内での式展開で使う`#{...}`のように、特別な役割を持つ**#**はコメントの開始と見なされない。

#### 004 ローカル変数を使いたい
**ローカル変数への値の代入**
```ruby
変数名 = 値
```
変数の有効範囲が、その変数が定義されたクラス、モジュール、メソッド、ブロックの終わりまでに限られる変数のことを**ローカル変数**と呼ぶ。

##### ローカル変数の名前
Ruby では、アルファベットの小文字かアンダースコアで始まる名前をローカル変数名として利用できる。

##### ドップレベルでのローカル変数
トップレベル（Rubyスクリプトの直下、あらゆるクラスやメソッドの外側の位置）でローカル変数とみなされる名前の変数を定義すると、そのスクリプトの中で有効なローカル変数となる。

##### ローカル変数に値を代入する
特定のスコープで初めて現れる変数名に値が代入された場合、新たなローカル変数とみなされる。
```ruby
# 変数greetingを定義して利用する
irb(main):183> greeting = 'hello, world'
irb(main):184> puts greeting
hello, world
```

#### 005 整数を使いたい
**変数に整数を代入**
```ruby 
変数名 = `
```
整数は**1**や**-2**のようにリテラルで書くことができる。整数リテラルは符号とその後に続く数字からなる。これらの整数は**Integer**クラスのオブジェクトである。
- **リテラル**：値を直接表現するコードのこと。

#### 006 算術演算をしたい
**算術演算子**
|記法   |意味   |
|:---|:---|
|x + y |加算|
|x - y|減算|
|x * y|乗算|
|x / y|整数の商を得る除算|
|x.fdiv(y)|浮動小数点数の商を得る除算|
|x % y|剰余|
|x ** y|冪乗|

#### 007 比較演算をしたい
**比較演算子**
|記法|意味|
|---|---|
|x == y|xとyは等しい|
|x != y|xとyは等しくない|
|x >= y|xはy以上|
|x > y|xはyより大きい|
|x <= y|xはy以下|
|x < y|xはyより小さい|

比較演算は2つの値の間の等価性や大小関係を調べる演算。演算式の関係が成り立つとき**true**、成り立たないとき**false**を指揮の返り値として取得できる。

#### 008 配列を使いたい
**配列をリテラルで作成**
```ruby
[要素0, 要素1, ...]
```
**配列の中の要素を取得**
```ruby
a[インデックス]
```
Ruby では、複数の値を順番に並べた状態でまとめて保持するためのデータ構造として、配列がよく使われる。配列を作成するときはリテラルを使うのが一般的。カンマ区切りの要素の列を**角括弧[]**で囲んだものが配列のリテラルとなる。
配列を**puts**に渡すと、各要素を改行区切りで標準出力に出力する。
```ruby
irb(main):185> primes = [2, 3, 5, 7, 11]
irb(main):186> puts primes
2
3
5
7
11
```

##### 配列の要素を取得する
配列は**Array**クラスのオブジェクト。**Array**クラスには、要素の取得や操作のために様々なメソッドが定義されている。
配列中の要素を取得するには、欲しい要素の位置をインデックスとして整数で指定する。配列のインデックスは**0**から始まる。なお、存在しない位置の要素を取得しようとすると、値がそん座しないことを表す**nil**が返る。

------------


## ✍🏻 感想
### 🍒 ボウリングのスコア計算プログラムについての感想
本日、メンターさんからOKをもらったボウリングのスコア計算プログラムについて振り返ります。このプログラムを通じて、多くのことを学びました。

最初はスコア計算のロジックを理解するのに苦労しました。コードを書き始めるまで何をどうすれば分からず、MacBook の前で2日間フリーズしたこともありました。

カレンダーのプログラムやプログラムの修正もそうなのですが、私が最も学びになる瞬間はメンターさんとのキャッチボールです。苦心して作ったコードが、徐々に削られて読みやすくなっていく様子を楽しみながら学んでいる自分がいます。

今回の課題では、リファクタリングを通じて、シンプルで可読性の高いコードを書くことの重要性を再認識しました。メンターさんとのやり取りから学んだことを次の課題にも活かしていきたいと思います。

まだコードが読めない悔しさはありますが、あまり思い詰めずに、読めるようになるための努力を続けていきます。


------------


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 5 hours 50 min
- Total: 855 hours 40 min
