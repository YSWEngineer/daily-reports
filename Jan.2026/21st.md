# 2026/01/21(水)
## 📚 プラクティス『🛠️💻 lsコマンドを作る4』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外にも便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名・メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>

<details><summary>📌 要件 ※ 随時、追加・変更あり</summary>

- [ ] `-l`オプションが指定された場合は、各ファイルについて「詳細情報（long format）」を一行ずつ表示すること
- [ ] `-l`オプションが指定されていない場合は、これまで通りファイル名のみを表示すること
- [ ] 表示する詳細情報は、以下の内容を含ませること
  - [ ] ファイルタイプ
  - [ ] ファイルモード
  - [ ] リンク数
  - [ ] 所有者
  - [ ] 所有グループ
  - [ ] サイズ
  - [ ] タイムスタンプ（更新日時）
  - [ ] ファイル名もしくはディレクトリ名
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 完成したコードは GitHub の Pull Request として提出すること

</details>

<details><summary>📍 処理の流れ ※ 随時、追加・変更あり</summary>

1. コマンドライン引数から`-l`オプションの有無を判定する

2. 対象のディレクトリのファイル一覧を配列として取得する

3. `-l`オプションが指定されていない場合 → これまで通り、ファイル名の配列をそのまま表示する

4. `-l`オプションが指定されている場合 → ①配列の各要素（各ファイル）について詳細情報を取得する / ②取得した複数の属性を一行の文字列に整形する

5. 整形済みの各行を上から順に標準出力へ表示させる
</details>

<details><summary> 🧩 タスクばらし ※ 随時、追加・変更あり</summary>

- [ ] タスク1：コマンドライン引数を解析し、`-l`オプションの有無を取得する
- [ ] タスク2：対象のディレクトリのファイル一覧を配列として取得する
- [ ] タスク3：「一つのファイルについて、どんな情報が取れるのか」を調べる
  - [x] ファイルタイプ
  - [ ] ファイルモード
  - [ ] リンク数
  - [ ] 所有者
  - [ ] 所有グループ
  - [ ] サイズ
  - [ ] タイムスタンプ（更新日時）
- [ ] タスク4：取得した「詳細情報（各属性）」を表示する
  - [ ] 先ずはバラバラに値を取り出せるようにする
- [ ] タスク5：複数の属性を整形して表示する
  - [ ] 横に並べて一行にする
- [ ] タスク6：タスク3〜5で行った処理を全てのファイルに対して適用する
  - [ ] 先ずは1ファイルで成功させる
  - [ ] 次に`each`で各ファイルに処理を適用させる
- [ ] タスク7：`-l`オプションが指定されていないときに、`ls`コマンドと同じ挙動になることを確認する
- [ ] タスク8：rubocop-fjord に通す
- [ ] タスク9：提出
  - [ ] 作成した lsコマンドを Pull Request として提出
  - [ ] 提出物に、`ls -l`コマンドの実行結果と、OS標準（macなど自分の使ってるOS）の`ls -l`コマンドの実行結果のスクリーンショットを併記して貼る
  - [ ] rubocop-fjord のチェックが全てパスした画面をスクショして添付
</details>


---


## 🧑🏻‍💻 本日の取り組み
### 📚 プラクティス『🛠️💻 lsコマンドを作る4』 
- ファイルタイプについて調べる
- ファイルタイプを調べるコードを作成
- 専門用語の理解
- タスクばらしの見直し


---


## ⏭️ 次回
### 📚 プラクティス『lsコマンドを作る4』
- 作成したファイルタイプを動かして確認
- ファイルモードについて調べる
- ファイルモードを調べるコードを作成


---


### 💡 本日の学び・気付き
#### ファイルタイプについて調べる
- `-l`オプションで表示される先頭の1文字はファイルタイプである。
`-`は通常ファイル、`d`はディレクトリ、`l`はシンボリックリンクを表す。
- 通常ファイル（`-`）を調べるインスタンスメソッドは`file?`
- ディレクトリ（`d`）を調べるインスタンスメソッドは`directory?`
- シンボリックリンク（`l`）を調べるインスタンスメソッドは`symlink?`
- `ls -l`コマンドでは、各属性を横に連結して一行の文字列にしてから`puts`させればよい。そのため属性を構成するための部品はすぐに`puts`せず、
```ruby
type = 'd'
```
のように一旦変数に入れて、
```ruby
# 各属性を横に連結して一行の文字列にするコード（推測）
line = "#{type} #{nlink} ..."
puts line
```
という形で組み立てればいいのでは？と考えた。

#### ファイルタイプの順序は？
条件分岐でファイルタイプを選別する際、通常ファイル、ディレクトリ、シンボリックリンクの順序について気になった。
##### シンボリックリンクとは？
シンボリックリンク（symbolic link）とは、ファイルやディレクトリへのポインタを表す特別なファイル。簡単に言うと、OS上のショートカットのようなものをイメージするとよい。
- 元のファイル・ディレクトリは別に存在する別名。
- 元の位置とは違う場所でも参照できる。
- 元のファイルが削除されるとリンクは「壊れる」ことがある。

参考URL：[\[ディレクトリ構成\] シンボリックリンクとハードリンクの違い](https://lamp-hiroba.sakura.ne.jp/linux/article/018.html?utm_source=chatgpt.com)

つまり、見た目はファイルやディレクトリでも実態は「シンボリックリンク」であるというケースがある。そのため以下のように書いてしまうとシンボリックリンクなのにシンボリックリンクではない扱いになってしまう。
```ruby
if stat.directory?
  # ディレクトリだと思ってしまう
elsif stat.symlink?
  # 本当はシンボリックリンクだった！
end
```
↑これだと「シンボリックリンクなのにディレクトリとして判定」される可能性が発生してしまう。

#### ファイルタイプを調べるコード
上記の内容を踏まえて作成したファイルタイプを調べるコード
```ruby
if stat.symlink?
  type = 'l'
elsif stat.directory?
  type = 'd'
else
  type = '-'
end
```
つまり、
1. 先ず「シンボリックリンクかどうか」を確認
2. その次に「ディレクトリかどうか」を確認
3. それ以外は「通常ファイル」として認識

という順番（構造）にした。


---


## ✍🏻 感想
### 🤔 ファイルタイプを理解する
各属性を一つずつ`File::Stat`に対応させる作業に入り、今日はファイルタイプについて調べました。

自分なりにいろいろと調べる中で、シンボリックリンクの仕組みは特に難しく、理解が曖昧な部分が残ってしまいましたが、何とかファイルタイプを判定するコードを組み立てるところまで辿り着くことができました。

次回は、別のファイルを作成して組み立てたコードを実際に動かして確認し、その上でファイルモードを取得する処理の実装に進んでいきたいです。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 02 min
- Total: 1474 hours 11 min
