# 2023/07/14(金) 日報

## 取り組んだ課題
### 『Linuxの基礎コマンドを理解する』
- 『Linux標準教科書』
  - 第9章 シェルスクリプト - 9.1 シェルとシェルスクリプト ~ 9.4 条件分岐 まで修了


## 分かったこと・気付き
### シェルとシェルスクリプト
- シェル
  - 貝殻（＝Shell）という意味。
  - シェルはOSの、カーネル部分を包み込んでいることからその名があり、`対話機能`を提供するものである。
  - シェルはコマンドの入力を受け付けそのコマンドを実行し、入力したユーザに対しその結果を返す役割がある。
- シェルスクリプト
  - 繰り返し行う処理を自動化するための手段。

### プログラミング
- `コンピュータに対して、指示を与え順番に実行させる機能`を`プログラム`という。
- そのプログラムを作成することを`プログラミング`という。
- 今まで学習した`コマンドを条件分岐や繰り返しなど制御機能を加え実行すること`を`シェルスクリプト`という。

#### プログラムの例
- `何かが順序立てて進むもの`を、`プログラム`という。
- 例1）テレビ番組の録画予約：開始時刻から終了時刻とチャンネルを指定し、画質を指定したりする。
- 例2）エアコンの設定：「〇〇度に達したら冷房を入れて、〇〇度を下回ったら冷房を止める」。

#### プログラムの要素
- プログラミングには、どの種類のプログラムでもいくつかの重要な構成要素がある。
- プログラムの要素は主に以下の4つ。
1. `順次実行`
2. `条件分岐`
3. `繰り返し`
4. `サブルーチン`

### シェルスクリプトの作成
#### シェルスクリプトの作成
- シェルスクリプトは、テキストで記述する。
```
yoshiwo@YSWs-MBP ~ % vi lsdate.sh

# (Vimでの操作)以下の内容を記述して保存終了する
#!/bin/bash
ls
date
```

##### シェルの指定
- 1 行目に`#!/bin/bash`と記述。ファイルの 1 行目には、利用するシェルの種類とそのコマンド位置を記述。今回は`bash`を使用。 1行目に利用するシェルを指定、2行目以降に実行するコマンドを1行ずつ入力していく。

##### パーミッションの変更
- 作成したシェルスクリプトの実行には、パーミッションを変更してファイルの実行権限をつける必要がある。
- `パーミッション`：ファイルやディレクトリへのアクセス制御を管理するための仕組み。「w-r--r--」←これ。第8章参照。
```
# lsコマンドでファイルのアクセス権限を確認する
yoshiwo@YSWs-MBP ~ % ls -l lsdate.sh
-rw-r--r--  1 yoshiwo  staff  20  7 14 08:14 lsdate.sh

# 実行権限を付与するためにchmodコマンドを使う
yoshiwo@YSWs-MBP ~ % chmod u+x lsdate.sh # lsdate.shファイルにおいて、userにexecute(実行)権限を付与する
yoshiwo@YSWs-MBP ~ % ls -l lsdate.sh
-rwxr--r--  1 yoshiwo  staff  20  7 14 08:14 lsdate.sh # userにexecuteが付与されたことを確認

# ./はパス指定。「カレントディレクトリにある(ladate.shを実行せよ)」という意味。パスが通っているため、Vimで書いたlsコマンドやdateコマンドが順に実行される
yoshiwo@YSWs-MBP ~ % ./lsdate.sh
Applications		cat-output		mysql			umask022
Desktop			chownfile		ruby-book		uniq-sample
Documents		codes			score			update
Downloads		editfile.txt		study			vicopypaste.txt
Library			exit			test.txt		vicutlinepaste.txt
Movies			file1			test1			vicutpaste.txt
Music			file2			translate		vicutpasteundo.txt
Pictures		ichiyasa		translate2		viinsert.txt
Public			idbitfile		umask0022		vimove.txt
TEST			lsdate.sh		umask0070		vireplace.txt
TwitterHeader		manual-less		umask0072		work # ここまでがlsの実行結果
2023年 7月14日 金曜日 08時27分01秒 JST # dateの実行結果
```
#### コメント
- コメントは、`プログラム上に書く注釈`のこと。
- シェルの場合は「`#`」で始まる行がコメントとして認識され、`プログラムの実行時はコメントは無視`される。
- コメントは、`プログラマーが記述したプログラムがどういった処理をするのかを記述`したり、`一時的に特定の処理を無効化（コメントアウト）する場合に利用`する。
```
yoshiwo@YSWs-MBP ~ % vi lsdate.sh

#!/bin/bash
ls
#date # dateコマンドをコメントアウトする

# シェルスクリプトを実行
yoshiwo@YSWs-MBP ~ % ./lsdate.sh
Applications		cat-output		mysql			umask022
Desktop			chownfile		ruby-book		uniq-sample
Documents		codes			score			update
Downloads		editfile.txt		study			vicopypaste.txt
Library			exit			test.txt		vicutlinepaste.txt
Movies			file1			test1			vicutpaste.txt
Music			file2			translate		vicutpasteundo.txt
Pictures		ichiyasa		translate2		viinsert.txt
Public			idbitfile		umask0022		vimove.txt
TEST			lsdate.sh		umask0070		vireplace.txt
TwitterHeader		manual-less		umask0072		work # lsの実行結果
```

##### echoコマンド
- echoコマンドは`引数で与えた文字列を標準出力に出力する`コマンド。
```
yoshiwo@YSWs-MBP ~ % echo Message test
Message test # echoコマンドで指定された文字列を表示する
```

#### 変数
- プログラミングをする上で、非常に重要な考え方が、変数。
- 簡単にいうと「`箱`」で、`中に数値や文字列が入る`。
- `シェルスクリプトプログラミングでは、変数に数値や文字列を代入`し、それを利用することができる。
- 変数の`代入`は「`=`」を使い、`参照`は「`$`」を付けて行う。

##### 実習：シェル変数の作成
- シェル関数abcに値を設定し、echoコマンドで内容を確認。
```
yoshiwo@YSWs-MBP ~ % abc=123 
yoshiwo@YSWs-MBP ~ % echo $abc
123
```

```
YSWs-MBP:~ yoshiwo$ abc[0]=123
YSWs-MBP:~ yoshiwo$ abc[1]=456
YSWs-MBP:~ yoshiwo$ echo ${abc[0]}
123
YSWs-MBP:~ yoshiwo$ index=1
YSWs-MBP:~ yoshiwo$ echo ${abc[$index]}
456
```

##### シェル変数と環境変数
- シェルにはシェル変数と環境変数の2種類の変数がある。
  - シェル変数：実行しているシェルの内部でのみ有効。
  - 環境変数：そこから実行されたコマンド内でも有効になる
    - 環境変数はシェル変数から作成できる。

##### 実習：環境変数の作成
- exportコマンドを使って、環境変数を作成する。
```
YSWs-MBP:~ yoshiwo$ export abc # シェル変数abcを環境変数abcにする
YSWs-MBP:~ yoshiwo$ export xyz=234 # 環境変数xyzを作成し234を代入する

YSWs-MBP:~ yoshiwo$ cat BBB.sh
#!/bin/bash
xxx=123
export yyy=234
echo xxx=$xxx in BBB.sh
echo yyy=$yyy in BBB.sh
./CCC.sh
YSWs-MBP:~ yoshiwo$ cat CCC.sh
#!/bin/bash
echo xxx=$xxx in CCC.sh
echo yyy=$yyy in CCC.sh

# 作成したBBB.shファイルとCCC.shファイルそれぞれにオーナーに実行権限を付与する
YSWs-MBP:~ yoshiwo$ chmod u+x BBB.sh
YSWs-MBP:~ yoshiwo$ chmod u+x CCC.sh

# 実行権限をシェルスクリプトに付けたので実行
YSWs-MBP:~ yoshiwo$ ./BBB.sh
xxx=123 in BBB.sh
yyy=234 in BBB.sh
xxx= in CCC.sh # xxxはシェル変数なので値が引き継がれない
yyy=234 in CCC.sh # yyyは環境変数なのでCCC.shまで値が引き継がれている
```

#### readコマンド
- readコマンドは、`標準入力からデータを読み込む`。
- 既に`変数にデータが入っていた場合、新しいデータに上書きされる`。
- 書式
  - `read 変数名`

##### 実習：readコマンドの実行
- readコマンドを使ってシェル変数の内容を変更してみる。
```
YSWs-MBP:~ yoshiwo$ echo $abc # シェル変数abcの中身を表示
123
YSWs-MBP:~ yoshiwo$ read abc # 以下に入力した内容を読み込む
aaabbbccc
YSWs-MBP:~ yoshiwo$ echo $abc
aaabbbccc
```

#### シェル変数
- `シェル変数の一覧を表示`する場合は、`setコマンド`を利用する。
- 削除する場合は、`unset`を利用する。

##### 実習：シェル変数一覧の表示と削除
- シェル変数の一覧表示と削除を行う
```
YSWs-MBP:~ yoshiwo$ set
BASH=/bin/bash
BASH_ARGC=()
.
.
.
abc=([0]="aaabbbccc" [1]="456")
YSWs-MBP:~ yoshiwo$ set | grep ^abc # シェル変数一覧からabcで始まるシェル変数を出力させる
abc=([0]="aaabbbccc" [1]="456") # abcで始まるシェル変数を確認
YSWs-MBP:~ yoshiwo$ unset abc # シェル変数abcを削除
YSWs-MBP:~ yoshiwo$ set | grep ^abc # シェル変数一覧からabcで始まるシェル変数を出力させる
YSWs-MBP:~ yoshiwo$　# 表示されないので削除されたことがわかる
```

#### 環境変数
- 現在の`環境変数の一覧を表示する場合`は、`envコマンド`を利用する。
- 登録済みの`環境変数を削除する時`は、`unsetコマンド`を利用する。

##### 実習：環境変数の一覧の表示と削除
- 環境変数の一覧表示・削除を行う
```
YSWs-MBP:~ yoshiwo$ env
TERM_PROGRAM=Apple_Terminal
SHELL=/bin/bash
.
.
.
xyz=234
YSWs-MBP:~ yoshiwo$ env | grep ^xyz # 環境変数一覧からxyzで始まる環境変数を出力する
xyz=234
YSWs-MBP:~ yoshiwo$ unset xyz # 環境変数xyzを削除
YSWs-MBP:~ yoshiwo$ env | grep ^xyz
YSWs-MBP:~ yoshiwo$ # 表示されないので削除されたことがわかる
```

#### 引用符
- シェルスクリプトにおいて、文字列を引用符で囲むことができる。
- 利用できる引用符には「’（シングルクォート）」「“（ダブルクォート）」「`（バッククォート）」があり、引用符によって囲まれた文字列の処理が異なる。
  - シングルクォートで囲まれた文字列の中に、参照用の「$」付きの変数がある場合、「$」も文字列として認識されるため、変数は展開されない。
  - ダブルクォートの場合、引用符内の「$」付き変数は展開された文字列になる。
  - バッククォートで囲まれた文字列はコマンドとして解釈され、このとき「$」付きの変数があれば、それを展開した上でコマンドが実行される。
- 引用符は入れ子が可能。

##### 実習：引用符の動作確認
- 引用符の違いについて確認する。
```
YSWs-MBP:~ yoshiwo$ ABC=123
YSWs-MBP:~ yoshiwo$ echo 'Value of ABC is $ABC.'
Value of ABC is $ABC. # シングルクォートの場合$も文字列として認識される

YSWs-MBP:~ yoshiwo$ echo "Value of ABC is $ABC."
Value of ABC is 123. # ダブルクォートの場合$も変数として認識されるので中身の123が展開される

YSWs-MBP:~ yoshiwo$ XYZ=`date`; # バッククォートで囲まれたdateはdateコマンドとして解釈される
YSWs-MBP:~ yoshiwo$ echo "It is $XYZ now." # 変数$XYZにdateコマンドが紐付いている
It is 2023年 7月14日 金曜日 12時04分45秒 JST now.
YSWs-MBP:~ yoshiwo$ echo "It is `date` now." # ダブルクォートで囲まれた部分は文字列として認識され、バッククォートで囲まれたdateはdateコマンドとして展開される
It is 2023年 7月14日 金曜日 12時06分31秒 JST now.
```

#### 引数
- シェルスクリプトは、実行時にオプションを引数として参照することができる。
- その引数は、$1, $2……など、$の後に引数の番号を指定することで参照できる。

##### 実習：引数出力の確認
- args.shを作成し、引数呼び出しの動作を確認。
```
YSWs-MBP:~ yoshiwo$ cat args.sh 
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
echo '$0:' $0;
echo '$#:' $#;
YSWs-MBP:~ yoshiwo$ ./args.sh aaa bbb ccc
$1: aaa
$2: bbb
$3: ccc
$0: ./args.sh
$#: 3
# $1~$3は引数、$0は実行コマンド名、$#は引数の数を示す
```

#### Shift文
- shiftコマンドは`引数の順序をずらす`。
- shiftを実行すると、`$2が$1`に、`$3が$2`に……となる。

##### 実習：shiftコマンドの確認
- 実際にスクリプトを作成してshiftコマンドの動作を確認してみる。
```
YSWs-MBP:~ yoshiwo$ cat argsshift.sh 
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
shift
echo '$1:' $1;
echo '$2:' $2;

YSWs-MBP:~ yoshiwo$ ./argsshift.sh aaa bbb ccc
$1: aaa
$2: bbb
$3: ccc
$1: bbb
$2: ccc
```

#### エスケープシーケンス
- プログラミング言語には特別な扱いを受ける文字がある。
- 例）echoコマンドで、「Value of ABC is “123".」のように「“（ダブルクォート）」を出力する方法を考える。
```
YSWs-MBP:~ yoshiwo$ ABC=123
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is "$ABC"."
Value of ABC is 123.
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥"$ABC¥"."
Value of ABC is ¥?.
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥"$ABC"¥."
Value of ABC is ¥123¥.
YSWs-MBP:~ yoshiwo$ echo 'Value of ABC is "$ABC".'
Value of ABC is "$ABC".
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥$ABC."
Value of ABC is ¥123.
```
**※↑私の場合はテキストのようにはならなかった。**
- シェルスクリプトでは、¥（バックスラッシュ）はエスケープ文字と呼ばれ、特別な文字で直後の1文字の扱いを変更する。
- ¥（バックスラッシュ）は改行コードにも有効。¥（バックスラッシュ）を行末に付与することで、文字列の途中で折り返すことができる。適切に改行を入れることで、コマンドの視認性を向上できる。

#### sourceコマンド
- sourceコマンドは、bashなどのシェルの内部コマンドで、指定されたファイルを読み込んでシェル環境を設定する。ファイル内容はシェルコマンドと解釈して実行する。
- 一般的な用途は、シェルの環境設定ファイルである“.bashrc”や“.bash_profile”などを設定変更後、ログインし直さずに設定を現在のシェル上で有効にする場合に使われる。

#####実行例
```
YSWs-MBP:~ yoshiwo$ echo $abc
                               # $abcには何も格納されていないため、何も表示されない
YSWs-MBP:~ yoshiwo$ ./set.sh
xyz # スクリプト内で設定された変数abcの値がechoで出力された
YSWs-MBP:~ yoshiwo$ echo $abc
                               # 変数abcへの値の設定はスクリプト内でしか有効でないので、何も表示されない
YSWs-MBP:~ yoshiwo$ source set.sh
xyz # スクリプト内で設定された変数abcの値がechoで出力される
YSWs-MBP:~ yoshiwo$ echo $abc
xyz # sourceコマンドで読み込んだため、set.shが終わっても変数abcの値が格納されたまま
```

### 条件分岐
- プログラミングでは、条件にそって挙動を切り替える「条件分岐」を多用する。
- 条件分岐はすべてのプログラミング言語に存在する機能。

##### ファイル種別の r, w, x の意味
| 項目 | 内容 |
| :---: | :--- |
| r | 読み込み |
| w | 書き込み |
| x | 実行またはディレクトリの移動 |
- rが表示されればファイルの読み込みが可能。
- wが表示されればファイルの書き込みが可能。
- xが表示されればファイルをプログラムとして実行できるか、または、ディレクトリであればディレクトリへ移動できる。

#### アクセス権の変更
- ファイルのアクセス権を変更するにはchmodコマンドを使う。
- 書式
  - `chmod モード [, モード]… ディレクトリ`
  - `chmod モード [, モード]… ファイル`
  - `chmod 8進数表記のモード ディレクトリ`
  - `chmod 8進数表記のモード ファイル`
- ファイルのモードを所有ユーザと所有グループとそれ以外のユーザについて設定する。モード指定の書き方で以下の2通りの記述方法がある。
1. モードの書式を複数書き、カンマで区切って指定。
2. 8進数3桁で各ユーザのレベルを指定。

- モードの指定に`setuidビット`、`setgidビット`、`stickyビット`という、特殊な属性がある。
- setuidビットあるいはsetgidビットが付いたプログラムを実行すると、ファイル所有者あるいは所有グループの権限で実行される。
- rootユーザ所有で setuid ビットが セットされたプログラムは、一般ユーザが実行した場合でもrootユーザが実行した場合と同じ動作をする。
- stickyビットが付いたディレクトリ内のファイルは所有者以外が削除できなくなる（Linux では、ファイルについてのスティッキービットは無視される）。
- Linux では一般的に /tmp ディレ クトリにスティッキービットが付与されている。

#### ファイル作成のモード
- ファイルを新規に作成すると、ユーザごとに規定されたパーミッションである 644、若しくは 664 といったパーミッションが設定されてファイルが作成される。
- `umaskコマンド`を使うことで、指定したパーミッションでファイルを作成するように制限できる。
- 書式
  - `umask [8進数のモードのマスク値]`
- 現在のマスク値を表示
  - umask コマンドに続けてマスク値を指定しなかった場合、現在のマスク値を表示できる。
- マスク値を変更
  - umask コマンドに続けてマスク値を指定すると、コマンドを実行後に作成されるファイルが指定したパーミッションで作成できる。umask コマンドは許可しないビットを指定する。umask コ マンドで指定するマスク値は、すべてのユーザが読み書きできるパーミッション 666 から、設定したいパーミッションを引き算することでマスク値を求めることができる。
 

## 次の目標
- 『Linux標準教科書』 第10章まで修了


## 感じたこと
- いつもハンズオンでコマンドの挙動を確かめているお陰でmacOSにはないコマンド(useraddコマンド、userdelコマンド、groupaddコマンド、groupdelコマンド)を把握することができました。
- 先日立てた学習計画よりも進みが遅いのでスピードを意識してインプット学習を行いたいと思います。


## 学習時間
- Today:&nbsp;&nbsp; 5 hours 04 min
- Total: 339 hours 18 min
