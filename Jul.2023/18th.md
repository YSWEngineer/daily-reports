# 2023/07/14(金) 日報

## 取り組んだ課題
### 『Linuxの基礎コマンドを理解する』
- 『Linux標準教科書』
  - 第9章 シェルスクリプト - 9.5 繰り返し ~ 第10章 ネットワークの設定と管理 まで修了


## 分かったこと・気付き
### シェルとシェルスクリプト
#### 繰り返し
- 繰り返しは条件分岐と同じくらい重要な機構。
- 同じ処理を繰り返し行い、ある条件が成立した時に終了する、という形式が用いられている。
- シェルスクリプトで用いられている繰り返しは、以下の3通り。
##### for文
- for文は値を列挙し、それを対象に処理を繰り返す。
- 書式
```
for 変数 in 値のリスト
do
       処理
done
```
- 実行例
```
YSWs-MBP:~ yoshiwo$ for i in a b c d
> do
>  echo $i
> done
a
b
c
d
```
1. 値のリストとして「a, b, c, d」が渡される。
2. 先ず、i = a を行い、echo $i
3. 次に、i = b を行い、echo $i
4. 次に、i = c ……
5. 次に、i = d ……

##### while/until 文
- while文は、条件が成立している間ループを繰り返す（条件が成立しなくなったら終了）という処理で利用される。
- until文は、while文の反対。条件が成立していない間ループを繰り返す(条件が成立したら処理を終了)という用途に用いられる。
- 書式
```
while 条件式
do
        処理
done
until 条件式
do
        処理
done
```
- 実行例
```
YSWs-MBP:~ yoshiwo$ cat loop.sh
#!/bin/bash

count=1
while [ $count -le 10 ]
do
        echo "この処理は $count 回実行されました"
        count=`expr $count + 1`
done
YSWs-MBP:~ yoshiwo$ ./loop.sh 
この処理は 1 回実行されました
この処理は 2 回実行されました
この処理は 3 回実行されました
この処理は 4 回実行されました
この処理は 5 回実行されました
この処理は 6 回実行されました
この処理は 7 回実行されました
この処理は 8 回実行されました
この処理は 9 回実行されました
この処理は 10 回実行されました
```

##### select 文
- select文は、ユーザに対し数値による入力を促す。
- 書式
```
select 変数 in リスト
do
        処理
done
```
- 動作例
```
YSWs-MBP:~ yoshiwo$ cat select.sh 
#!/bin/bash

select name in "apple" "banana" "orange"
do
        echo "You selected $name";
done
YSWs-MBP:~ yoshiwo$ ./select.sh
1) apple
2) banana
3) orange
#? 1 # 1 ~ 3をいずれかを入力・実行
You selected apple # その数字に該当する文字列が出力される
#? ^C # control + C で中止できる
```
- 1 ~ 3を入力すると、`doからdoneの内部が実行`される。

#### 繰り返しの制御
- breakやcontinueを用いることで繰り返しを制御することができる。
- `breakは繰り返しを終了`し、`continueは繰り返しの先頭に戻る`役割がある。
- 実行例
```
YSWs-MBP:~ yoshiwo$ cat ./sample.sh 
while true
do
  echo "Continue? (y/n)"
  read input
  case $input in
    n) break # nはbreakが処理される
       ;;
    y) continue # yはcontinueが処理される
       ;;
    *) echo "Please input y or n." # yとn以外の入力は「Please input y or n.」が表示される
       ;;
    esac
done
YSWs-MBP:~ yoshiwo$ ./sample.sh
Continue? (y/n)
y
Continue? (y/n) # yを選択することで繰り返しの先頭に戻った
a # y、n以外を入力
Please input y or n. # 「yまたはnを入力してください」と表示
Continue? (y/n)
n # nを選択することで繰り返しを終了した
```

#### サブルーチン
- プログラミングをする上で、`一連の処理をまとめて、再利用できるようにしたものを、サブルーチン`という。
- サブルーチンは言語体系により様々な呼ばれ方をしている。`シェルスクリプトでは関数と呼ばれている`。

##### 関数
- 関数は、引数と呼ばれるデータを与え、処理をして結果を返すという機能の集まり。
- 書式
```
function 関数名
{
        処理
}
```
```
関数名 ()
{
        処理
}
```
- ↑両者とも働きは同じ。引数は、実行時に関数名に続けて記述する。
- 引数は、関数の内部で$1、$2で参照することができる。

##### return 文
- シェルスクリプトの関数で、結果を返す時はreturn文を実行する。
- 書式
```
return 変数名
```
- return文を実行すると、関数内での処理はそこで終了し、変数が関数の呼び出し元に返される。

#### 実際のシェルスクリプト ※ここではCentOS 7の起動スクリプトを例に行われているので注意！！
- 
```
コマンド1 && コマンド2
     コマンド1が正常終了した場合、コマンド2を実行

コマンド1 || コマンド2
     コマンド1が異常終了した場合、コマンド2を実行

コマンド1 && コマンド2 && ... && コマンドN || コマンドY
     コマンド1から実行し、正常終了する限り && の右に進み、異常終了した段階でコマンドYを実行
```
- ちなみにLinuxは、国際化されたOSで、言語設定(locale)によって、出力メッセージの言語を切り替えることができる。

#### 関数のシェルスクリプト
- `関数の利用は、呼ばれているプログラムの機能を一括で更新できる、という利点がある`ことを理解すること。

#### デバッグ
- `デバッグ`とは、`作成したプログラムが思ったように動作しない時に、どこに問題があるのか調べること`。
- プログラムの所々に、変数を表示させるコードや、プログラムの走行ルートを表示させるコードを埋め込む必要があり、非常に労力が掛かる。
  - そのため、`プログラム言語には、デバッグを支援するツールが用意されている`。
  - `シェルスクリプトにも、スクリプトをデバッグモードで動かすためのコマンドが用意されている`。

##### shコマンド
- `sh自身はシェルを起動するコマンド`だが、`-xオプションをつけて引数にシェルスクリプトを指定すると、コマンドや変数の中身を表示しながらスクリプトを実行する`。
- 実行例
```
YSWs-MBP:~ yoshiwo$ cat ./sample.sh
while true
do
  echo "Continue? (y/n)"
  read input
  case $input in
    n) break
       ;;
    y) continue
       ;;
    *) echo "Please input y or n."
       ;;
    esac
done
YSWs-MBP:~ yoshiwo$ sh -x ./sample.sh
+ true
+ echo 'Continue? (y/n)'
Continue? (y/n)
+ read input
y
+ case $input in
+ continue
+ true
+ echo 'Continue? (y/n)'
Continue? (y/n)
+ read input
n
+ case $input in
+ break
```

### ネットワークの設定と管理
#### TCP/IP とは
- コンピュータ間をケーブルや無線機能で接続したシステムをネットワークと呼ぶ。
- LinuxをOSに利用したコンピュータのほとんどはネットワークに接続して利用する。
- 物理的なネットワークはコンピュータ間をツイストペアケーブルで繋ぐ。
- 最近は、有線のネットワークに加えて無線機能を使って接続したり、有線と無線の混在したネットワークもある。

##### ローカルエリアネットワークとワイドエリアネットワーク
- 学校や自宅などの閉じられた複数のコンピュータを相互接続したネットワークをローカルエリアネットワーク（LAN）と呼ぶ。
- 離れた場所にあるLANとLANを結んだネットワークのことをワイドエリアネットワーク（WAN）と呼ぶ。
- LANはコンピュータ同士をLANケーブルで結び、WANはLAN同士を通信回線で結ぶ。

##### IPとは
- ネットワークで繋がったコンピュータ同士の間では、決まった手順（プロトコル）に従ってデータを送受信している。
- 一般的に使われているイーサネット規格のネットワークはプロトコルとしてTCP/IPと利用している。
- TCP/IPのIP（Internet Protocol）は手順の基本。
- IPは送り先とデータからなるパケットを送るだけの簡単な仕組み。
- pingコマンドでデータが送信され、データを受けた機器（サーバやルータなど）から確認メッセージが返ってくるかを確認できる。
- 書式
```
ping ターゲット
ターゲット（ホスト名やIPアドレス）にデータを送り、返答が戻るまでの時間を表示する。
-cオプションをつけて、pingを発行する回数を指定することもできる。
```
- 実習：ローカルなマシンのIPアドレスの確認
```
YSWs-MBP:~ yoshiwo$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1): 56 data bytes
64 bytes from 192.168.1.1: icmp_seq=0 ttl=64 time=1.888 ms
64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.832 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=1.992 ms
^C # control + C でpingコマンドを中止
--- 192.168.1.1 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.832/1.904/1.992/0.066 ms
```
- 実習：インターネットにつながるマシンで確認
- pingコマンドに対してlpiのサーバからの返答があるか（返答時間も）確認してください。pingを3回実施するため、-cオプションを付けてコマンドを実行する。
```
YSWs-MBP:~ yoshiwo$ ping lpi.jp -c 3
PING lpi.jp (3.112.116.66): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1

--- lpi.jp ping statistics ---
3 packets transmitted, 0 packets received, 100.0% packet loss
```
- pingコマンドは`control + C`を押すと止まる。
- コンピュータによってはセキュリティ対策のため、pingコマンドに対応しない場合がある。

##### TCPとUDPとは
- `TCP（Transmission Control Protocol）`は`IP（Internet Protocol）`の仕組みを使ってデータを送る手順のこと。
- IPはインターネットにおいて情報の伝達を行う手順（プロトコル）のこと。
- TCPでは、データのまとまりを1つ受け取ると、直ぐにデータの破損などのエラーを確認し、間違っている場合はデータの再送を依頼する。
- `UDP（User Datagram Protocol）`は、エラー確認やデータの再送制御は行わない分、データを高速に送ることができて、恣意さなデータや映像のような多少欠損しても問題なく、信頼性よりも速度を求められる通信に適している。

#### IPアドレス
- TCP/IPでデータを送受信するには発送元と発送先の場所を表すアドレスが必要。
- インターネットではIPv4（Internet Protocol version 4）とIPv6の2つのプロトコルが使われている。
- IPv4は4バイト（16進数で8桁）で表せるアドレスで、4バイトのアドレスは1バイト（16進数で2桁）ごとで10進数に変換して繋いで表記する。
- プライベートなIPアドレスを除いたIPアドレスをグローバルなIPアドレスと呼ぶ。
- グローバルなIPアドレスはNIC（日本ではJPNIC）に管理されており、許可なく利用できない。
```
16新数  C0          A8          01          64
 ↓
 2進数  11000000    10101000    00000001    01100100
 ↓
10進数  192         168         1           100
```

##### IPアドレスのクラス
- IPv4で使われるIPアドレスはネットワークアドレスとホストアドレスを繋げた形となる。
- ネットワークアドレスはビットが立っている（255の様な）部分。
- ホストアドレスはビットが立っていない（0）の部分。
- IPアドレスは学校や会社などの組織に対して割り当てられるので、割り当てられた組織で使われる範囲は連続したアドレスである。
- ネットワークアドレスの長さにより、AからCのクラスがあり、クラスDやクラスEなどの特殊なクラスも予約されている。
- ホストアドレスにおいて、ホスト部のすべてのビットが0のアドレスはそのネットワーク自身のアドレスを示す。
- ホスト部の全てのビットが1のアドレスは、そのネットワーク内のすべてのホストに届くブロードキャストアドレスという特殊なアドレスをします。
- これらのアドレスは実際にコンピュータに割り当てることはできない。

##### プライベートIPアドレス
- ローカルなネットワークで自由に利用可能なIPアドレスが用意されており、プライベートIPアドレスと呼ぶ。

##### サブネットマスク
- IPアドレスのうち、ネットワークアドレスとホストアドレスを識別するための数値をサブネットマスクという。
- サブネットマスクは通信先ホストが同一ネットワークにいるかいないかの判断に使われる。
- ネットワーク（IPアドレスの集まり）はサブネットマスクを変えることで、複数のネットワークに分けて、効率的にIPアドレスを利用できる。

##### CIDR（サイダー）表記
- CIDR（Classless Inter-Domain Routing）表記とはIPアドレスのネットワーク部とホスト部の境目を/（スラッシュ）の後に続くビット数で指定する方法。
- 例）
	- 127.0.0.1/8
		- IP アドレスの先頭から８ビットをネットワーク部として、残りの２４ビットをホスト部 とした設定。クラスＡと同じ扱いで、それぞれ下記となる。
		-	∗ IP アドレス : 127.0.0.1
		-	∗ ネットマスク : 255.0.0.0
		-	∗ ネットワーク : 127.0.0.0
		-	∗ ブロードキャスト: 127.255.255.255
		-	∗ アドレスの数 : 16,777,216 個

	- 192.168.0.1/24
		-	IP アドレスの先頭から２４ビットをネットワーク部として、残りの８ビットをホスト部 とした設定。クラスＣと同じ扱いで、それぞれ下記となる。
		-	∗ IP アドレス : 192.168.0.1
		-	∗ ネットマスク : 255.255.255.0
		-	∗ ネットワーク : 192.168.0.0
		-	∗ ブロードキャスト: 192.168.0.255
		-	∗ アドレスの数 : 256 個

	- 192.168.0.1/28
		- IP アドレスの先頭から２８ビットをネットワーク部として、残りの４ビットをホスト部 とした設定。クラスＣのサブセットの扱いで、それぞれ下記となる。
		-	∗ IP アドレス : 192.168.0.1
		-	∗ ネットマスク : 255.255.255.240
		-	∗ ネットワーク : 192.168.0.0
		-	∗ ブロードキャスト: 192.168.0.15
		-	∗ アドレスの数 : 16 個


# ./はパス指定。「カレントディレクトリにある(ladate.shを実行せよ)」という意味。パスが通っているため、Vimで書いたlsコマンドやdateコマンドが順に実行される
yoshiwo@YSWs-MBP ~ % ./lsdate.sh
Applications		cat-output		mysql			umask022
Desktop			chownfile		ruby-book		uniq-sample
Documents		codes			score			update
Downloads		editfile.txt		study			vicopypaste.txt
Library			exit			test.txt		vicutlinepaste.txt
Movies			file1			test1			vicutpaste.txt
Music			file2			translate		vicutpasteundo.txt
Pictures		ichiyasa		translate2		viinsert.txt
Public			idbitfile		umask0022		vimove.txt
TEST			lsdate.sh		umask0070		vireplace.txt
TwitterHeader		manual-less		umask0072		work # ここまでがlsの実行結果
2023年 7月14日 金曜日 08時27分01秒 JST # dateの実行結果
```
#### コメント
- コメントは、`プログラム上に書く注釈`のこと。
- シェルの場合は「`#`」で始まる行がコメントとして認識され、`プログラムの実行時はコメントは無視`される。
- コメントは、`プログラマーが記述したプログラムがどういった処理をするのかを記述`したり、`一時的に特定の処理を無効化（コメントアウト）する場合に利用`する。
```
yoshiwo@YSWs-MBP ~ % vi lsdate.sh

#!/bin/bash
ls
#date # dateコマンドをコメントアウトする

# シェルスクリプトを実行
yoshiwo@YSWs-MBP ~ % ./lsdate.sh
Applications		cat-output		mysql			umask022
Desktop			chownfile		ruby-book		uniq-sample
Documents		codes			score			update
Downloads		editfile.txt		study			vicopypaste.txt
Library			exit			test.txt		vicutlinepaste.txt
Movies			file1			test1			vicutpaste.txt
Music			file2			translate		vicutpasteundo.txt
Pictures		ichiyasa		translate2		viinsert.txt
Public			idbitfile		umask0022		vimove.txt
TEST			lsdate.sh		umask0070		vireplace.txt
TwitterHeader		manual-less		umask0072		work # lsの実行結果
```

##### echoコマンド
- echoコマンドは`引数で与えた文字列を標準出力に出力する`コマンド。
```
yoshiwo@YSWs-MBP ~ % echo Message test
Message test # echoコマンドで指定された文字列を表示する
```

#### 変数
- プログラミングをする上で、非常に重要な考え方が、変数。
- 簡単にいうと「`箱`」で、`中に数値や文字列が入る`。
- `シェルスクリプトプログラミングでは、変数に数値や文字列を代入`し、それを利用することができる。
- 変数の`代入`は「`=`」を使い、`参照`は「`$`」を付けて行う。

##### 実習：シェル変数の作成
- シェル関数abcに値を設定し、echoコマンドで内容を確認。
```
yoshiwo@YSWs-MBP ~ % abc=123 
yoshiwo@YSWs-MBP ~ % echo $abc
123
```

```
YSWs-MBP:~ yoshiwo$ abc[0]=123
YSWs-MBP:~ yoshiwo$ abc[1]=456
YSWs-MBP:~ yoshiwo$ echo ${abc[0]}
123
YSWs-MBP:~ yoshiwo$ index=1
YSWs-MBP:~ yoshiwo$ echo ${abc[$index]}
456
```

##### シェル変数と環境変数
- シェルにはシェル変数と環境変数の2種類の変数がある。
  - シェル変数：実行しているシェルの内部でのみ有効。
  - 環境変数：そこから実行されたコマンド内でも有効になる
    - 環境変数はシェル変数から作成できる。

##### 実習：環境変数の作成
- exportコマンドを使って、環境変数を作成する。
```
YSWs-MBP:~ yoshiwo$ export abc # シェル変数abcを環境変数abcにする
YSWs-MBP:~ yoshiwo$ export xyz=234 # 環境変数xyzを作成し234を代入する

YSWs-MBP:~ yoshiwo$ cat BBB.sh
#!/bin/bash
xxx=123
export yyy=234
echo xxx=$xxx in BBB.sh
echo yyy=$yyy in BBB.sh
./CCC.sh
YSWs-MBP:~ yoshiwo$ cat CCC.sh
#!/bin/bash
echo xxx=$xxx in CCC.sh
echo yyy=$yyy in CCC.sh

# 作成したBBB.shファイルとCCC.shファイルそれぞれにオーナーに実行権限を付与する
YSWs-MBP:~ yoshiwo$ chmod u+x BBB.sh
YSWs-MBP:~ yoshiwo$ chmod u+x CCC.sh

# 実行権限をシェルスクリプトに付けたので実行
YSWs-MBP:~ yoshiwo$ ./BBB.sh
xxx=123 in BBB.sh
yyy=234 in BBB.sh
xxx= in CCC.sh # xxxはシェル変数なので値が引き継がれない
yyy=234 in CCC.sh # yyyは環境変数なのでCCC.shまで値が引き継がれている
```

#### readコマンド
- readコマンドは、`標準入力からデータを読み込む`。
- 既に`変数にデータが入っていた場合、新しいデータに上書きされる`。
- 書式
  - `read 変数名`

##### 実習：readコマンドの実行
- readコマンドを使ってシェル変数の内容を変更してみる。
```
YSWs-MBP:~ yoshiwo$ echo $abc # シェル変数abcの中身を表示
123
YSWs-MBP:~ yoshiwo$ read abc # 以下に入力した内容を読み込む
aaabbbccc
YSWs-MBP:~ yoshiwo$ echo $abc
aaabbbccc
```

#### シェル変数
- `シェル変数の一覧を表示`する場合は、`setコマンド`を利用する。
- 削除する場合は、`unset`を利用する。

##### 実習：シェル変数一覧の表示と削除
- シェル変数の一覧表示と削除を行う
```
YSWs-MBP:~ yoshiwo$ set
BASH=/bin/bash
BASH_ARGC=()
.
.
.
abc=([0]="aaabbbccc" [1]="456")
YSWs-MBP:~ yoshiwo$ set | grep ^abc # シェル変数一覧からabcで始まるシェル変数を出力させる
abc=([0]="aaabbbccc" [1]="456") # abcで始まるシェル変数を確認
YSWs-MBP:~ yoshiwo$ unset abc # シェル変数abcを削除
YSWs-MBP:~ yoshiwo$ set | grep ^abc # シェル変数一覧からabcで始まるシェル変数を出力させる
YSWs-MBP:~ yoshiwo$　# 表示されないので削除されたことがわかる
```

#### 環境変数
- 現在の`環境変数の一覧を表示する場合`は、`envコマンド`を利用する。
- 登録済みの`環境変数を削除する時`は、`unsetコマンド`を利用する。

##### 実習：環境変数の一覧の表示と削除
- 環境変数の一覧表示・削除を行う
```
YSWs-MBP:~ yoshiwo$ env
TERM_PROGRAM=Apple_Terminal
SHELL=/bin/bash
.
.
.
xyz=234
YSWs-MBP:~ yoshiwo$ env | grep ^xyz # 環境変数一覧からxyzで始まる環境変数を出力する
xyz=234
YSWs-MBP:~ yoshiwo$ unset xyz # 環境変数xyzを削除
YSWs-MBP:~ yoshiwo$ env | grep ^xyz
YSWs-MBP:~ yoshiwo$ # 表示されないので削除されたことがわかる
```

#### 引用符
- シェルスクリプトにおいて、文字列を引用符で囲むことができる。
- 利用できる引用符には「’（シングルクォート）」「“（ダブルクォート）」「`（バッククォート）」があり、引用符によって囲まれた文字列の処理が異なる。
  - シングルクォートで囲まれた文字列の中に、参照用の「$」付きの変数がある場合、「$」も文字列として認識されるため、変数は展開されない。
  - ダブルクォートの場合、引用符内の「$」付き変数は展開された文字列になる。
  - バッククォートで囲まれた文字列はコマンドとして解釈され、このとき「$」付きの変数があれば、それを展開した上でコマンドが実行される。
- 引用符は入れ子が可能。

##### 実習：引用符の動作確認
- 引用符の違いについて確認する。
```
YSWs-MBP:~ yoshiwo$ ABC=123
YSWs-MBP:~ yoshiwo$ echo 'Value of ABC is $ABC.'
Value of ABC is $ABC. # シングルクォートの場合$も文字列として認識される

YSWs-MBP:~ yoshiwo$ echo "Value of ABC is $ABC."
Value of ABC is 123. # ダブルクォートの場合$も変数として認識されるので中身の123が展開される

YSWs-MBP:~ yoshiwo$ XYZ=`date`; # バッククォートで囲まれたdateはdateコマンドとして解釈される
YSWs-MBP:~ yoshiwo$ echo "It is $XYZ now." # 変数$XYZにdateコマンドが紐付いている
It is 2023年 7月14日 金曜日 12時04分45秒 JST now.
YSWs-MBP:~ yoshiwo$ echo "It is `date` now." # ダブルクォートで囲まれた部分は文字列として認識され、バッククォートで囲まれたdateはdateコマンドとして展開される
It is 2023年 7月14日 金曜日 12時06分31秒 JST now.
```

#### 引数
- シェルスクリプトは、実行時にオプションを引数として参照することができる。
- その引数は、$1, $2……など、$の後に引数の番号を指定することで参照できる。

##### 実習：引数出力の確認
- args.shを作成し、引数呼び出しの動作を確認。
```
YSWs-MBP:~ yoshiwo$ cat args.sh 
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
echo '$0:' $0;
echo '$#:' $#;
YSWs-MBP:~ yoshiwo$ ./args.sh aaa bbb ccc
$1: aaa
$2: bbb
$3: ccc
$0: ./args.sh
$#: 3
# $1~$3は引数、$0は実行コマンド名、$#は引数の数を示す
```

#### Shift文
- shiftコマンドは`引数の順序をずらす`。
- shiftを実行すると、`$2が$1`に、`$3が$2`に……となる。

##### 実習：shiftコマンドの確認
- 実際にスクリプトを作成してshiftコマンドの動作を確認してみる。
```
YSWs-MBP:~ yoshiwo$ cat argsshift.sh 
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
shift
echo '$1:' $1;
echo '$2:' $2;

YSWs-MBP:~ yoshiwo$ ./argsshift.sh aaa bbb ccc
$1: aaa
$2: bbb
$3: ccc
$1: bbb
$2: ccc
```

#### エスケープシーケンス
- プログラミング言語には特別な扱いを受ける文字がある。
- 例）echoコマンドで、「Value of ABC is “123".」のように「“（ダブルクォート）」を出力する方法を考える。
```
YSWs-MBP:~ yoshiwo$ ABC=123
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is "$ABC"."
Value of ABC is 123.
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥"$ABC¥"."
Value of ABC is ¥?.
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥"$ABC"¥."
Value of ABC is ¥123¥.
YSWs-MBP:~ yoshiwo$ echo 'Value of ABC is "$ABC".'
Value of ABC is "$ABC".
YSWs-MBP:~ yoshiwo$ echo "Value of ABC is ¥$ABC."
Value of ABC is ¥123.
```
**※↑私の場合はテキストのようにはならなかった。**
- シェルスクリプトでは、¥（バックスラッシュ）はエスケープ文字と呼ばれ、特別な文字で直後の1文字の扱いを変更する。
- ¥（バックスラッシュ）は改行コードにも有効。¥（バックスラッシュ）を行末に付与することで、文字列の途中で折り返すことができる。適切に改行を入れることで、コマンドの視認性を向上できる。

#### sourceコマンド
- sourceコマンドは、bashなどのシェルの内部コマンドで、指定されたファイルを読み込んでシェル環境を設定する。ファイル内容はシェルコマンドと解釈して実行する。
- 一般的な用途は、シェルの環境設定ファイルである“.bashrc”や“.bash_profile”などを設定変更後、ログインし直さずに設定を現在のシェル上で有効にする場合に使われる。

#####実行例
```
YSWs-MBP:~ yoshiwo$ echo $abc
                               # $abcには何も格納されていないため、何も表示されない
YSWs-MBP:~ yoshiwo$ ./set.sh
xyz # スクリプト内で設定された変数abcの値がechoで出力された
YSWs-MBP:~ yoshiwo$ echo $abc
                               # 変数abcへの値の設定はスクリプト内でしか有効でないので、何も表示されない
YSWs-MBP:~ yoshiwo$ source set.sh
xyz # スクリプト内で設定された変数abcの値がechoで出力される
YSWs-MBP:~ yoshiwo$ echo $abc
xyz # sourceコマンドで読み込んだため、set.shが終わっても変数abcの値が格納されたまま
```

### 条件分岐
- プログラミングでは、条件にそって挙動を切り替える「条件分岐」を多用する。
- 条件分岐はすべてのプログラミング言語に存在する機能。

#### if文
- 比較などによる条件分岐を行う場合は`if文`を利用する。
- 書式
  - `if 条件式1 then … elif 条件式2 … else … fi`
    - elif… と else… の部分は省略可能。
    - elifは別の条件（条件式2）で判断したい場合に利用する。
    - elseは条件が全て当てはまらなかった場合、実行される。
    - if文はfiで終了する。
##### 文字列比較を行なう演算子
| 演算子 | 比較内容 |
| :---: | :--- |
| a == b | a と b が等しければ真 |
| a != b | a と b が等しくなければ真 

##### 数値比較を行なう演算子
| 演算子 | 比較内容 |
| :---: | :--- |
| a -eq b | a と b が等しい（equal to）ければ真 |
| a -ne b | a と b が等しくなければ（not equal to）真 |
| a -ge b | a が b 以上（greater than or equal to）であれば真 |
| a -le b | a が b 以下（less than or equal to）であれば真 |
| a -gt b | a が b より大きい（greater than）値であれば真 |
| a -lt b | a が b 未満（less than）であれば真 |

#### ファイル属性の確認
- 書式
  - `if test -d パス ; then……`
    - -dがファイル属性確認の演算子にあたる。
    - -dはディレクトリであるかの判定を行うため、if文全体で、「パスがディレクトリであれば真の値を返す」という条件式になる。

##### ファイル属性の確認を行なう演算子
| 演算子 | 内容 |
| :---: | :--- |
| -f ファイル名 | 通常ファイルなら真 |
| -d ファイル名 | ディレクトリなら真 |
| -e ファイル名 | ファイルが存在すれば真 |
| -L ファイル名 | シンボリックリンクなら真 |
| -r ファイル名 | 読み取り可能ファイルなら真 |
| -w ファイル名 | 書き込み可能ファイルなら真 |
| -x ファイル名 | ファイルが存在して、実行権限があれば真 |
| -s ファイル名 | サイズが 0 より大きければ真 |

- testコマンドは[ ]を使って記述することもできる。
- 書式
  - `if [ 条件節 ]; then …`
  - `if test 条件節 ; then …`
- ファイルに関する比較演算子は属性以外にもある。詳細はmanコマンドでtestコマンドの項目を確認すること。

#### 複数の条件を重ねる
- 条件分岐の場合、複数の条件を重ねることができる。
- 条件Aと条件Bが同時に成立している必要がある時は、「条件A”かつ“条件Bが成立」で、論理積（=AND）が用いられる。
- 「条件A”もしくは“条件Bが成立」の場合は、論理和（=OR）が用いられる。
- シェルスクリプトにおいて、論理積・論理和の書き方は2通り存在する。
- 論理積
  - 論理積は-aを用いる場合と、&&を用いる場合がある。
- 書式
  - `[条件 A -a 条件 B -a 条件 C ] ....`
  - `[条件 A] && [条件 B] && [条件 C] ....`
**※-aと&&は、それぞれ [ ] の内側か外側かで、使われ方が変わることに気を付けること。**
- 論理和
  - 論理和を表す記号は、-o と||の2通り。
- 書式
  - `[条件 A -o 条件 B -o 条件 C ] ....`
  - `[条件 A] || [条件 B] || [条件 C] ....`
 
#### 一対多の条件分岐
- if文を用いた場合、一対多の分岐は以下のようになる。
```
if 条件式 then
:
elif 条件式 then
:
elif 条件式 then
:
:
fi
```

- シェルスクリプトでは、case文が用意されていて、一対多の分岐が記述できるようになている。
```
case 変数 in
        値 A)
                   処理 1;;
        値 B)
                   処理 2;;
esac
```
- 変数の値が値 A のとき、処理 1 が実行される。
- 最後は`case文の逆からの記述であるesac`で終わっていることが重要。
- 値はパイプ記号（|）で区切って複数指定することができる。
```
YSWs-MBP:~ yoshiwo$ cat case.sh
#!/bin/bash

case $1 in
	a|A)
           echo "引数に a または A が入力されました";;
	b|B)
           echo "引数に b または B が入力されました";;
esac
YSWs-MBP:~ yoshiwo$ ./case.sh a
引数に a または A が入力されました
YSWs-MBP:~ yoshiwo$ ./case.sh B
引数に b または B が入力されました
```
- どの値にもマッチしなかった場合の処理を記述するには、値にアスタリスク（*）を用いる。
```
YSWs-MBP:~ yoshiwo$ cat defaultcase.sh 
#!/bin/bash

case $1 in
        1)
           echo "引数に 1 が入力されました";;
        2)
           echo "引数に 2 が入力されました";;
        *)
           echo "1,2 以外が入力されました";;
esac

YSWs-MBP:~ yoshiwo$ ./defaultcase.sh 1
引数に 1 が入力されました
YSWs-MBP:~ yoshiwo$ ./defaultcase.sh 2
引数に 2 が入力されました
YSWs-MBP:~ yoshiwo$ ./defaultcase.sh 0
1,2 以外が入力されました
# どの条件にもマッチしない場合、値*の処理が実行される
```

## 次の目標
- 『Linux標準教科書』 第12章まで修了


## 感じたこと
- このテキストの山場を迎えているような気がします。最後まで気を抜かずにハンズオンで一つ一つ確かめながらインプット学習を行います。


## 学習時間
- Today:&nbsp;&nbsp; 7 hours 21 min
- Total: 346 hours 39 min
