# 2024/07/31(水)
## 🧩 タスクばらし
### プラクティス『FizzBuzz問題(Ruby)』の修了
- [x] 各参考ページを確認
- [ ] FizzBuzz問題に取り組む
- [ ] 課題提出
- [ ] 完了したら他の方の提出物と自分の提出物を見比べる


## 📋 段取り
<details><summary>各参考ページを確認</summary>

- [x] [rubyでコマンドを作る | FJORD BOOT CAMP（フィヨルドブートキャンプ）](https://bootcamp.fjord.jp/articles/40)
- [x] [Gitで課題提出するまでの手順をまとめた（Sakiさんのブログ）](https://saki-htr.hatenablog.com/entry/2021/02/25/115930)
- [x] [Pull Requestのやり方](https://www.youtube.com/watch?v=XMgLL4qIyEA)
- [x] [GitHubでコードを提出するときに気をつけること](https://bootcamp.fjord.jp/pages/info-for-github)
- [x] [プルリクエスト形式で提出物を出す際の「これはやっちゃダメ」リスト](https://bootcamp.fjord.jp/reports/98547/edit)
</details>

<details><summary>FizzBuzz問題に取り組む</summary>

- [ ] FizzBuzzプログラムを書く
</details>

<details><summary>課題提出</summary>

- [ ] Pull Request としてアップする
- [ ] URL と Terminal での実行結果を提出
</details>

<details><summary>完了したら他の方の提出物と自分の提出物を見比べる
</summary>

- [ ] 他の方の提出物と自分の提出物を見比べる
</details>


## ✍🏻 本日の取り組み
### プラクティス『FizzBuzz問題(Ruby)』
- [GitHubでコードを提出するときに気をつけること](https://bootcamp.fjord.jp/pages/info-for-github)
- [プルリクエスト形式で提出物を出す際の「これはやっちゃダメ」リスト](https://bootcamp.fjord.jp/reports/98547/edit)
- FizzBuzz問題に取り組む


## 💡 本日の学び・気付き
### GitHubでコードを提出するときに気をつけること
- GitHub でコードを提出する前に下記を間違えていないかどうかチェックすること。これは FBC がということではなく、一般的に仕事でレビュー依頼をした時（まともな会社ならば必ずレビューがある）に必ず指摘を受ける部分である。慣れてしまえば無意識にこれらに引っかからない Pull Request が出せるようになる。

#### File changed を確認したか
- これは、真っ先に注意したい点。ローカルの自分のエディタ上で確認していたとしても、PR を作ったら必ず Files changed を確認する癖をつけること。
- Files changed を一回も見ていないなという PR はレビュワーもそれと分かる。
- Files changed は GitHub の Pull Request ページの一部で、Pull Request によって変更されるファイルを表示する。

#### Lint を通しているか
- Ruby だったら rubocop、JavaScript だったら eslint。まずは lint を通しているか否か確認。
- lint（リント）はプログラムのソースコードを解析してエラー、バグ、などを検出するツールのこと。
- 「lintを通す」とは、ソースコードを lint で解析し、その結果エラーや警告が出ない状態にすること。

#### ファイルの末尾に改行があるか
- 改行がないと赤いマークが表示される。どのエディターでも設定で改行が自動的に入るようにできるので、エディターで**最終行に改行が入る**ように設定を行うこと。
- 最終行に改行が必要な理由については、komagataさんのブログに載っています。
   - [なぜ最終行に改行が必要なのか - komagataのブログ](https://docs.komagata.org/5460)

#### Github での自分のユーザーアイコンが未設定になっていないか
- ユーザーアイコンが未設定（デフォルトの状態）だと、「普段コードを書かない人かな？」と思われる可能性がある。

#### コミットしたユーザーアイコンが Octcat になっていないか
- Gitクライアントに設定した emailアドレスが GitHub のユーザーのメールアドレスと違う場合にユーザーアイコンが Octcat になってしまう。

#### 不要なファイルをコミットしてないか
- `.DS_Store`、`xxx~`、`.idea`などその人にしか必要ないファイルを含めていないか確認すること。開発に参加するみんなに必要なものだけを含めるようにすること。
- Mac のみなどマシン固有のファイルはマシン固有のファイル（**~/.gitconfig**など）に書くこと。

#### .gitignore は適切か
- `.DS_Store`は Mac だけのファイル。`.idea`は JetBrains のエディター独自のファイル。そういった特定の環境の人向けのファイルは`.gitignore`に含めるべきではない。プロジェクト毎の設定ではなく、自分のマシン固有の設定に書くべき。

#### 大量の依存 gem がコミットされていないか
- gem のインストール場所を vendro/bundle にあり、その中にある大量の gem のファイルがコミットされてしまっていないか確認すること。

#### マジックナンバーが無いか
- 数字が直接書かれていると、何の数字なのか後から見た人には分からない。定数など名前の付いたものとして書かれていれば意味が分かる。

#### メソッドが長すぎないか
- 「1メソッドは5行以内に収めるべし」という Sandi Metzルールがある。
- Sandi Metzルールは Rubyプログラマのためのルールで以下の内容がある。
   - クラス内のコードが100行を超えてはならない
   - メソッド内のコードが5行を超えてはならない
   - 4つより多い引数をメソッドに渡すようにしてはならない（ハッシュによるオプションもパラメーターとみなす）
   - コントローラーではただ1つのオブジェクトだけをインスタンス変数化できる
      - ビューは1つのインスタンス変数を参照し、そのオブジェクトに対するメッセージ送信のみを行うことができる（@object.collaborator.valueは許可されない）

#### 無意味なファイルがないか
- generator が作成した無意味なファイルは削除すること。例えば、実装のないmodule 、中身のない test、fixtures など。

#### 何でもリファクタリングと言っていないか
- リファクタリングは**プログラムの振る舞いを変えずに内部構造を変えること**なので、ちょっとした修正という意味で使ってはいけない。

#### 秘密の情報がコミットされていないか
- oauth の secret など、コード中では環境変数にしておくこと。これをやると、Git で過去を修正したとしても GitHub のキャッシュに残ってしまい、完全に消すには GitHub のサポートに連絡するといった面倒なことになる。

#### コミットメッセージを適切に書いているか
- コミットログはちゃんと見られるものである。
   - 「いつ (When) 」コードに対していつ変更を加えたのかはタイムスタンプを見れば分かる。
   - 「どこで (Where) 」コードに対して何を変更を加えたのかはリソース (file/dir) 名で分かる。
   - 「誰が (Who) 」コードに対して誰が変更を加えたのかは author を見れば分かる。
   - 「何を (What) 」コードに対してどうやって変更を加えたのかは diff を読めば分かる。
   - 「なぜ (Why) 」コードに対してなぜ変更を加えたのかはコミットメッセージを読めば分かる。
   - 「どうやって (How) 」コードに対してどうやって変更を加えたのかは実装を読めば分かる。
- 「modify」だけ「追加」だけでは後から見た人が困るので駄目。困る人には1ヶ月後の自分も含まれる。「レビュー指摘を反映」だけも、同様。その瞬間には適切な変更理由かもしれないが、後から見た人はどういう指摘がそのコミットになったのかがわからない(コミットのログはリポジトリの歴史の記録)。
- コミットメッセージを日本語または英語で書くのかはプロジェクトのルールに合わせること。FBC では統一されていればどちらでもよい。

#### 理解せずコピペしていないか
- ググった内容を自分のコードに取り入れることは問題ないが、その内容を理解せずにそのまま使用するのはよくない。理解していないコードでは何が起きるか分からないから。
- そのままコピペするとレビュアーには結構な確率で分かってしまう。
- 意味を理解した上で自分のコードの文脈に合わせた内容に変えて使うこと。

### プルリクエスト形式で提出物を出す際の「これはやっちゃダメ」リスト

#### 提出直後にマージしない
- PR を作成したら、メンターが Approve（承認）するまで PR をマージしないこと。提出直後にいきなりマージすると、その後のレビューやコメントのやりとりがしづらくなるため。

#### コメントをもらうたびにプルリクエストを作り直さない
- メンターがレビューしたあと、その PR をクローズして新たに PR を作ると前回のレビューからの変更点が追いにくくなる。そのため、PR はクローズせず、そのままローカルでコミットした変更点を GitHub に push すること。

#### force push を使わない
- メンターのレビュー後に force push を使いローカルの作業内容を GitHub に反映すると、前回のレビューからの変更点が追いにくくなる。
- 試行錯誤途中のコミットが残っていても別に構わないので、無理にコミット履歴をキレイにしようとせず、ありのままの姿で GitHub に push すること。

#### コメントの resolve を使わない
- コメントを resolve すると、以前の内容をメンターがすぐに確認できなくなってしまう。以前の内容に基づいてメンターがフィードバックを行う場合があるので、コメントの resolve は使わないこと。

### FizzBuzz問題に取り組む
- FizzBuzz問題のプログラムをコマンドラインのプログラムとして書くこと。
- 1 から 20 までの数を表示するプログラムを書く。
- 条件
   - 3 の倍数の場合は数の代わりに「Fizz」、5 の倍数の場合は「Buzz」、3 と 5 の両方の倍数（15 の倍数）の場合は「FizzBuzz」、それ以外の場合は数値を出力する。
      - 3 の倍数 → 3 で割り切れる場合 → `number % 3 == 0`
      - 5 の倍数 → 5 で割り切れる場合 → `number % 5 == 0`
      - 3 と 5 の両方の倍数 → 15 で割り切れる場合 → `number % 15 == 0`
```ruby
# 1から20までの数値を出力する
(1..20).each do |number|
  puts number
end
```
```ruby
# if文にelsif節を追加させてif文に複数の条件を持たせる
if 条件①
  条件を満たした時の処理
elsif 条件②
  条件を満たした時の処理
elsif 条件③
  条件を満たした時の処理
else
  条件を満たさなかった時の処理
end
```


## 📍 次回
### プラクティス『FizzBuzz問題(Ruby)』
- FizzBuzz問題に取り組む


## ❤️‍🔥 感想
### 🧱🛠️ FizzBuzzプログラムの素材を用意
FizzBuzz問題のプログラムを書くための素材を用意。用意するために先ずは言語化し、次に言語化したものを`each メソッド`、`if節`、if節に複数の条件を持たせる`elsif節`を用いてプログラムの骨組みを作ってみたり、「Fizz」「Buzz」「FizzBuzz」になる各条件を`演算子を用いた式`にして書いてみました。

あとは組み立てるだけなのですが「そんなにすんなりとうまくはいかないだろうなぁ」と思いつつ、挙動を確かめながらFizzBuzzプログラムの完成を目指します。


## ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 4 hours 23 min
- Total: 444 hours 31 min
