# 2025/07/23(水)
## 📚 プラクティス『プログラムの修正（リバーシ編）』


### 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] ソースコードの言語化
- [ ] ソースコードを修正
- [ ] 課題提出


### 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>ソースコードの言語化</summary>

- [x] ソースコードの言語化 **※①から順に行う**
  - [x] ① reversi_methods_test.rb
  - [x] ② reversi.rb
  - [x] ③ reversi_methods.rb
  - [x] ④ position.rb


</details>

<details><summary>ソースコードを修正</summary>

- [ ] ソースコードを修正
  - test_cannot_put_stone
    - [ ] 修正
  - test_finished_of_quickest_win_board
    - [ ] 修正
  - test_put_stone
    - [x] 修正
  - test_turn
    - [x] 修正
  - test_finished_of_full_board
    - [ ] 修正

</details>

<details><summary>課題提出</summary>

- [ ] 修正したソースコードを Pull Request としてアップ
- [ ] Pull Request としてアップした URL とテストコードの実行結果を提出
</details>


---
### 🧑🏻‍💻 本日の取り組み
#### プラクティス『プログラムの修正（リバーシ編）』
- `binding.break`を使ってコードを理解
#### グループコーチング
- 作成した内容を皆さんの前で発表


---


### 🎯 次回
#### プラクティス『プログラムの修正（リバーシ編）』
- `binding.break`を使ってコードを理解
- バグの原因を突き止め、修正へ
    

---


### 💡 本日の学び・気付き
#### test_cannot_put_stone
- `turn_succeed`：石を置いた後にひっくり返しが一度でも成功したかどうかを覚えておく。
  - `turn(...)`が`true`を返したら、ひっくり返しが成功！
  - テストとの関係
    - `put_stone`は最終的にこの`turn_succeed`を返すので、
      - `turn_succeed == true`のときは置ける
      - `turn_succeed == false`のときは置けない
- テスト`refute put_stone(board, 'b1', BLACK_STONE)`が失敗するのは、この`turn_succeed`が本来`false`のはずの場所で`true`になっているから。

##### dry_runの仕組みのおさらい
  - `dry_run: true`→ 盤面は変更せず、「ここに石を置けるかどうか」だけを調べる。
  - `dry_run: false`→ 実際に石を置いて、盤面を更新し、石をひっくり返す。
```ruby
put_stone(board, cell_ref, stone_color, dry_run: false)
```
このとき、
- `cell_ref == "b1"`→ B1 のマスに
- `stone_color == "B"`→ B（黒石）で
- `dry_run == false`→ 実際に石を置く処理をする

この処理の中で`turn_succeed`が`true`になると、実際の盤面にも黒石が置かれてしまい、石もひっくり返される。

まとめると、
- `dry_run: false`→「本番モード」（実際に石を置く）。
- これから調べたいこと→どの方向で`turn(copied_board, ...)`が`true`を返し、`turn_succeed`が`true`となってしまっているのかを`step`を使って一つずつ追って調べる。

##### turn_succeed = false を実行させる
`next`を入力して進み、`turn_succeed = false`の次の行（56行目）の`Position::DIRECTIONS.each do |direction|`まで移動する。

今の状況は、
- `put_stone`メソッドの中で
- `turn_succeed = false`と初期化され、
- 8方向に石がひっくり返せるか？を順に調べようとしているところ。

##### 何故 b1 に黒石が置けたのかを調べる
- 知りたいのは「本来は`b1`に黒石が置けないはずなのに、何故置けてしまったのか？」

つまり、`turn_succeed = true`になってしまった原因を突き止めたい。

##### 1ステップずつ追って調べる
1. `step`コマンドでループの中へ入る
```shell
(rdbg) step
```
で、`next_pos = pos.next_position(direction)`に入る

2. 変数の中身を確認する
```shell
(rdbg) p direction
(rdbg) p next_pos.to_cell_ref
```

3. さらに`step`で`turn(...)`の中に入る
```shell
(rdbg) step
```
| 手順  |内容   |
|---|---|
|step   |directionに入る   |
|p direction と p next_pos.to_cell_ref   |どの方向を調べているか確認   |
|step   |turn(...)の中に入る   |
|stepを繰り返す   |どこでtrueを返っているか確認する   |

- `direction`（ディレクション）：リバーシでの8方向を数字で表したもの。
- `next_pos`
  - `Position`クラスが使われている。
  - `pos = Position.new("b1")`
  - この Positionクラスは、「マスの位置」をオブジェクトとして扱う。
- `next_pos = pos.next_position(direction)`
  - これは「今の場所（`pos`）から、指定した方向（`direction`）に1マス進んだ場所（`Position`）」を返す。
  - たとえば以下の内容だと`next_pos`は`"b2"`になる。
```shell
pos = Position.new("b1")       # b1 というマス
direction = [1, 0]             # 下方向へ1マス
next_pos = pos.next_position(direction)
```
|言葉   |意味   |
|---|---|
|direction   |8方向のうちの1つ（上、下、右、左など）を[行, 列]で表す   |
|next_pos   |「ある方向に1マス進んだ場所」のPositionクラスのオブジェクト   |
|to_cell_ref   |Positionオブジェクトを"b1"のような文字列に変換するメソッド   |


---


### ✍🏻 感想
#### 💡 少しずつ理解
`binding.break`を使いながら、少しずつコードの理解を深めています。まだ情報量の多さに圧倒されそうになりますが、あともう少しでバグの原因に辿り着けそうな手応えも感じています。焦らず、着実に進めていきたいです。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 hours 29 min
- Total: 1175 hours 47 min
