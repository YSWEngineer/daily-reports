# 2025/07/24(木)
## 📚 プラクティス『プログラムの修正（リバーシ編）』


### 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] ソースコードの言語化
- [ ] ソースコードを修正
- [ ] 課題提出


### 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>ソースコードの言語化</summary>

- [x] ソースコードの言語化 **※①から順に行う**
  - [x] ① reversi_methods_test.rb
  - [x] ② reversi.rb
  - [x] ③ reversi_methods.rb
  - [x] ④ position.rb


</details>

<details><summary>ソースコードを修正</summary>

- [ ] ソースコードを修正
  - test_cannot_put_stone
    - [ ] 修正
  - test_finished_of_quickest_win_board
    - [ ] 修正
  - test_put_stone
    - [x] 修正
  - test_turn
    - [x] 修正
  - test_finished_of_full_board
    - [ ] 修正

</details>

<details><summary>課題提出</summary>

- [ ] 修正したソースコードを Pull Request としてアップ
- [ ] Pull Request としてアップした URL とテストコードの実行結果を提出
</details>


---
### 🧑🏻‍💻 本日の取り組み
#### プラクティス『プログラムの修正（リバーシ編）』
- `binding.break`を使ってコードを理解


---


### 🎯 次回
#### プラクティス『プログラムの修正（リバーシ編）』
- `binding.break`を使ってコードを理解
- バグの原因を突き止め、修正へ
    

---


### 💡 本日の学び・気付き
#### test_cannot_put_stoneのデバッグ
##### eval error について
`p`コマンドで変数の中身を確認しようとしたところ、以下のエラーが発生。
```shell
(rdbg) p direction    # command
=> :top_left
(rdbg) p next_pos.to_cell_ref    # command
eval error: undefined method `to_cell_ref' for nil
  (rdbg)//Users/yoshiwo/bug_reversi/lib/reversi_methods.rb:1:in `block in put_stone'
=> nil
```
###### エラーの意味
```shell
eval error: undefined method `to_cell_ref' for nil
```
これは 「`next_pos`が`nil`（何もない状態）だったのに、`to_cell_ref`をしようとしたためエラーになった」という意味。
###### 何故next_posがnilになるのか？
以下のコードで、
```ruby
next_pos = pos.next_position(direction)
```
`next_position(direction)`の中で、**指定した方向に進んだ結果、盤面の外にでてしまった場合**、その`Position`オブジェクトは`nil`になる。
例えば、現在のマスが`"a1"`のとき、左上（`:top_left`）に進むと盤面の外になるため、`next_pos`が`nil`になる可能性がある。
###### 対処法：next_posの中身を確認する
先ず`next_pos`の中身を確認する。
```shell
(rdbg) p next_pos    # command
=> nil
```
このように、`next_pos`が`nil`（何もない状態）だと分かれば、`.to_cell_ref`などのメソッドは使えないということが分かる。
###### まとめると
|エラー   |原因   |
|---|---|
|undefined method 'to_cell_ref' for nil   |next_posがnil（盤面の外）だから   |
###### nil?メソッドを使う （**※ チェリー本 p.63参考**）
>「対象データが未存在である」ということを明示するために`nil?`メソッドが使われる。`nil?`メソッドはオブジェクトが`nil`だった場合に`true`を返すメソッド。

なので、↓こういう調べ方もできる。
```shell
# next_posの中には何もない（nil）なのでtrueを返す
(rdbg) p next_pos.nil?    # command
=> true
```
このように`nil?`を使えば、`next_pos`が未定義（`nil`）かどうかを確かめられる。

---

##### 58行目：turn_succeed = true if turn(copied_board, next_pos, stone_color, direction)の確認
ここで調べたいことは以下の3点。
```shell
(rdbg) p direction        # どの方向なのか？
(rdbg) p next_pos.to_cell_ref  # どのマスなのか？
(rdbg) p copied_board[next_pos.row][next_pos.col]  # そしてそこには何があるのか？
```
###### copied_board[next_pos.row][next_pos.col]について
**1. 盤面**
リバーシの盤面は 8×8 のマス目。リバーシのプログラムではこれを、「**配列の中に配列が入っている**」形で表示される。
```ruby
# 例えばこのようなイメージ
board = [
  ["-", "-", "-", "-", "-", "-", "-", "-"],  
  ["-", "-", "-", "-", "-", "-", "-", "-"],  
   ⋮
]
```
- `board[0]`：1行目全体。
- `board[0][3]`：1行目4列目のマス。

**2. copied_board**
オリジナルの盤面`board`をコピーしたもの。`put_stone`ではこれを使い、仮に石を置いてみて成功するかどうかをチェックする。

**3. next_pos.row, next_pos.col**
- `next_pos`：「今見ようとしているマス」の位置を示すオブジェクト。
- `next_pos.row`：「何行目か」を教えてくれる。ドット（`.`）を使いメソッドを呼び出している。
- `next_pos.col`：「何列目か」を教えてくれる。ドット（`.`）を使いメソッドを呼び出している。

例えば、`row = 2`、`col = 3`なら、3行目と4列目が重なったマスを指す。

**4. copied_board[next_pos.row][next_pos.col]**
リバーシの盤面の該当するマスの状態（`"-"`空のマス、`"B"`黒石、`"W"`白石）のどれかを返す。


---


### ✍🏻 感想
#### 🤔 エラーの背景を丁寧に追う
デバッガで`p next_pos.to_cell_ref`を実行した時、`eval error`が出たことをきっかけに、何故`nil`が帰ってくるのかを一つ一つ丁寧に追いかけていきました。自分なりに「何が起きているのか？」を（なんとなくですが）考えて整理することができ、ちょっとだけですがプログラムの流れやリバーシの盤面の仕組みについての理解が深まりました。

まだまだ読み解くことができない箇所や理解があやふやなところもありますが、デバッグ作業を通して乗り越えたいです。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 hours 26 min
- Total: 1181 hours 13 min
