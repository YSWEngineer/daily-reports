# 2025/07/27(日)
## 📚 プラクティス『プログラムの修正（リバーシ編）』


### 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] ソースコードの言語化
- [ ] ソースコードを修正
- [ ] 課題提出


### 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>ソースコードの言語化</summary>

- [x] ソースコードの言語化 **※①から順に行う**
  - [x] ① reversi_methods_test.rb
  - [x] ② reversi.rb
  - [x] ③ reversi_methods.rb
  - [x] ④ position.rb


</details>

<details><summary>ソースコードを修正</summary>

- [ ] ソースコードを修正
  - test_cannot_put_stone
    - [ ] 修正
  - test_finished_of_quickest_win_board
    - [ ] 修正
  - test_put_stone
    - [x] 修正
  - test_turn
    - [x] 修正
  - test_finished_of_full_board
    - [ ] 修正

</details>

<details><summary>課題提出</summary>

- [ ] 修正したソースコードを Pull Request としてアップ
- [ ] Pull Request としてアップした URL とテストコードの実行結果を提出
</details>


---
### 🧑🏻‍💻 本日の取り組み
#### プラクティス『プログラムの修正（リバーシ編）』
- 8方向の確認


---


### 🎯 次回
#### プラクティス『プログラムの修正（リバーシ編）』
- `true`を返す原因を突き止める
    

---


### 💡 本日の学び・気付き
#### test_cannot_put_stone：8方向の確認

<details open><summary>⚠️ネタバレに触れているような気がするので折り畳みます</summary>

### next_pos = pos.next_position(direction) の行の上に binding.break を書き込み、8方向それぞれを確認する
#### 1. binding.breakを書き込む
```ruby
Position::DIRECTIONS.each do |direction|
      binding.break      # ←ここで止まる
      next_pos = pos.next_position(direction)
      turn_succeed = true if turn(copied_board, next_pos, stone_color, direction)
    end
```
これで、8方向のループが回るたびに必ず止まり、そこで状態を確認できる。

#### 2. rdbg で実行と確認
```shell
(rdbg) continue   # 最初のbinding.breakまで進む
```
ループの最初に止まったら以下のコマンドを一つずつ実行し、確かめる。
```shell
(rdbg) p direction   # 今見ている方向(:top_left, :bottom など)
(rdbg) p pos.to_cell_ref   # 石を置いたマス（場所）
(rdbg) p next_pos.to_cell_ref   # 隣接するマス（場所）
(rdbg) p copied_board[next_pos.row][next_pos.col]   # マスに置かれている石の色
(rdbg) continue   # 次の方向へ
```
↑これを繰り返せば、どの方向で`turn`が何をしているかが分かる。

#### turn(copied_board, next_pos, stone_color, direction)についておさらい
- つまり、`turn`の引数を全て動かして「`turn`メソッドの呼び出しでひっくり返し（裏返し）処理に成功したかどうか」を確認するコマンド。

#### 8方向が示した結果
|   |p direciton   |p pos.to_cell_ref   |p next_pos.to_cell_ref   |p copied_board[next_pos.row][next_pos.col]   |turn(copied_board, next_pos, stone_color, direction)   |
|---|---|---|---|---|---|
|:top_left（左上）   |:top_left   |"a1"   |"盤面外"   |"-"   |false   |
|:top（上）   |:top   |"a1"   |"盤面外"   |"-"   |false   |
|:top_right（右上）   |:top-right   |"a1"   |"盤面外"   |"-"   |false   |
|:left（左）   |:left   |"a1"   |"盤面外"   |"-"   |false   |
|:right（右）   |:right   |"a1"   |"b1"   |"-"   |false   |
|:bottom_left（左下）   |:bottom_left   |"a1"   |"盤面外"   |"-"   |false   |
|:bottom（下）   |:bottom   |"a1"   |"a2"   |"-"   |false   |
|:bottom_right（右下）   |:bottom_right   |"a1"   |"b2"   |"-"   |true   |

`:bottom_right`が`(rdbg) p turn(...)`で`true`を返した。
##### 1. turn(...) が true を返す意味
- `turn`メソッドは「この方向でひっくり返せる相手の石があって、且つ最後に自分の石にある」場合に`true`を返すようになっている。
- 逆に、途中で空のマスに出るか、盤面外に出るか、あるいは相手の石が全く続かない場合は`false`を返す。

##### 2. :bottom_right だけ true だった
- つまり、デバッグしている時の盤面（局面）では、右下の方向にだけ「相手の石が（連続して）あって、その先に自分の石がある」と判断され、**ひっくり返す（裏返しする）処理を行った**、ということ。

##### 3. 「マスに石が置かれていないのにひっくり返し（裏返し）が起きた理由
- 本来は、もし隣接するマスが空（`"-"`）なら、最初のチェックで`false`となり、何もひっくり返さない。にもかかわらず`true`が帰っているということは......
  - 実際にはその方向に「相手の石 → 相手の石...→ 自分の石」という並びが存在していた。
  - あるいは、まだコードに「空のマス（`"-"`）の場合に`false`を返す」といった内容のコードがプログラムにはなく、空のマスでもそのまま処理されてしまっている。

のいずれかではないか？と推量🤔🤔🤔

#### :bottom_right時のマスと石について
`:bottom_right`の時のマスの場所とマスに状況について確認。
```shell
(rdbg) p next_pos.to_cell_ref    # command
=> "b2"
(rdbg) p next_pos.next_position(direction)&.to_cell_ref    # command
=> "c3"
(rdbg) p copied_board[next_pos.next_position(direction)&.row][next_pos.next_position(direction)
&.col]    # command
=> "W"
```
- `p next_pos.to_cell_ref `：`"a1"`を起点にして右下へ1つ進んだマスの位置（`"b2"`）。
- `p next_pos.next_position(direction)&.to_cell_ref`：`"b2"`からさらに右下へ1つ進んだマスの位置（`"c3"`）。
  - `&.`：`nil`かもしれないオブジェクトに対して安全にメソッドを呼び出したい場合に使用する**ぼっち演算子。　（※ チェリー本 p. 201参照）**
- `p copied_board[next_pos.next_position(direction)&.row][next_pos.next_position(direction)`：`"c3"`で、そこに何が置かれているかを確認する。置かれていたのは`"W"`。

##### 状況の整理
1. `pos`（ここでは`"a1"`）の右下が`next_pos = "b2"`で白石`"W"`。
2. さらに（そのまま方向は右下に進んだ）その先が`"c3"`で、そこも白石`"W"`。
3. やはり、黒石ないにもかかわらず`turn(...)`が`true`を返してしまっている。


</details>


---


### ✍🏻 感想
#### 🤔 修正まであと少し......かも
`trun`メソッドの動きを確認しました。8方向それぞれで
- `direction`
- `next_pos`
- さらにその先のマスの位置と置かれている石

などを`p`コマンドを順に追っていって、どのケースで`true`が返しているのかを把握できました。

日報には読みやすさを心掛けてまとめていますが、実際には何度もレポート用紙に手書きでコードを書いては試し、書き直し......を繰り返しています。机の上はレポート用紙でいっぱいです。

書籍『ゼロからわかる Ruby 超入門』と『プロを目指す人のためのRuby入門』の知識が課題に取り組む上で大きな支えになっています。地道な積み重ねですが、少しずつ手応えを感じています。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 hours 47 min
- Total: 1187 hours 00 min
