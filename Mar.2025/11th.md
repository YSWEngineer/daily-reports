# 2025/03/11(火)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [ ] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [ ] 8.9 モジュールに関する高度な話題
   - [ ] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する
    - 8.8 状態を保持するモジュールの作成
    - 8.9 モジュールに関する高度な話題
      - メソッド探索のルールを理解する


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する
    - 8.9 モジュールに関する高度な話題
      - モジュールに他のモジュールを include する


---


## 💡 本日の学び・気付き
### 8.8 状態を保持するモジュールの作成
クラスインスタンス変数を使い、クラス自身にデータを保持する方法はモジュールでも使うことができる。外部ライブラリ（gem）では、そのライブラリを実行するための設定値（config 値）をモジュール自身に保持させたりすることがよくある。
```ruby
# AwesomeApiは何らかのWeb APIを利用するライブラリ、という想定
irb(main):001* module AwesomeApi
# 設定値を保持するクラスインスタンス変数を用意する
irb(main):002*   @base_url = ''
irb(main):003*   @debug_mode = false

# クラスインスタンス変数を読み書きするための特異メソッドを定義する
irb(main):004*   class << self
irb(main):005*     def base_url=(value)
irb(main):006*       @base_url = value
irb(main):007*     end

irb(main):008*     def base_url
irb(main):009*       @base_url
irb(main):010*     end

irb(main):011*     def debug_mode=(value)
irb(main):012*       @debug_mode = value
irb(main):013*     end

irb(main):014*     def debug_mode
irb(main):015*       @debug_mode
irb(main):016*     end

# 上ではわかりやすくするために明示的にメソッドを定義したが、本来は以下の一行で済む
# attr_accessor :base_url, :debug_mode
irb(main):017*   end
=> :debug_mode

# 設定値を保存する
irb(main):019> AwesomeApi.base_url = 'https://example.com'
irb(main):020> AwesomeApi.debug_mode = true
=> true

# 設定値を参照する
irb(main):021> AwesomeApi.base_url
=> "https://example.com"
irb(main):022> AwesomeApi.debug_mode
=> true
```
この方法もモジュールではなくクラスを使って実現することができる（module を class に置き換えても同じ動きになる）。

ライブラリの実行に必要な設定値などはアプリケーション全体で共通の値になることが多い。そのため、アプリケーション内ではいつでもどこでも同じ設定値を設定したり、取得したりする必要がある。そのためには設定値の情報はアプリケーション内で「**唯一、1つだけ**」の状態になっていることが望ましい。「唯一、1つだけ」のオブジェクトを作る手法のことを、**シングルトンパターン**と呼ぶ。これは、オブジェクト指向プログラミングの設計手法である。

#### モジュールの用途は1つとは限らない
- **モジュールを利用したメソッド定義（include と extend）**
- **モジュールを利用した名前空間の作成**
- **関数や定数を提供するモジュールの作成**
- **状態を保持するモジュールの作成**

モジュールの用途として以上を1つずつ学んだが、実際は1つのモジュールが複数の用途で使われる場合もある。たとえば、外部ライブラリでは、あるモジュールが設定値情報を保持しつつ、一方で名前空間を提供するために使われることがよくある。
```ruby
# AwesomeApiモジュールは設定値を保持する（用途その1）
module AwesomeApi
  @base_url = ''
  @debug_mode = false

  class << self
    attr_accessor :base_url, :debug_mode
  end
end

# こちらではAwesomeApiモジュールが名前空間として使われる（用途その2）
module AwesomeApi
  class Engine
    # クラスの定義
  end
end
```

### 8.9 モジュールに関する高度な話題
#### メソッド探索のルールを理解する
Ruby ではさまざまな方法でメソッドを定義することができる。そのため、「Fooクラスの barメソッドが定義されているのはここ！」と言い切ることは困難。たとえば、`to_s`メソッドを1つ呼び出すにしても、
- **そのクラス自身に to_sメソッドが定義されている場合**
- **そのスーパークラスに to_sメソッドが定義されている場合**
- **ミックスインとして to_sメソッドが定義（include）されている場合**

と、さまざま。しかも上記の方法は混在させることが可能。

Ruby におけるメソッド探索のルールについて、Objectクラスに元から実装されている to_sメソッドを題材として取り上げる。たとえば、極端な構成のモジュールやクラスがあったとする。
```ruby
module A
  def to_s
    "<A> #{super}"
  end
end

module B
  def to_s
    "<B> #{super}"
  end
end

class Product
  def to_s
    "<Product> #{super}"
  end
end

class DVD < Product
  include A
  include B
  def to_s
    "<DVD> #{super}"
  end
end
```
DVDクラスは Productクラスを継承している。それだけでなく、モジュールAとモジュールBを`include`している。それぞれのクラスやモジュールには to_sメソッドが実装されていて、親の to_sメソッド（super）と自分の名前を出力するようになっている。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBMjdaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--dc45140c9f2ef007c8b7de5b5a6e80bc98614cc7/IMG_1279.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBMjdaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--dc45140c9f2ef007c8b7de5b5a6e80bc98614cc7/IMG_1279.jpeg" width="4032" height="2268" alt="IMG_1279.jpeg"></a>

DVDクラスのインスタンスを作って to_sメソッドを呼び出すと、次のような結果になる。
```ruby
irb(main):026> dvd = DVD.new
irb(main):027> dvd.to_s
=> "<DVD> <B> <A> <Product> #<DVD:0x000000011b951cf0>"
```
出力結果から、次のような順序で to_sメソッドが呼び出されたことが分かる。
- **DVDクラス自身の to_sメソッド（\<DVD>）**
- **2番目に include したモジュールBの to_sメソッド（\<B>）**
- **最初に include したモジュールAの to_sメソッド（\<A>）**
- **スーパークラスである Productクラスの to_sメソッド（\<Product>）**
- **Productクラスのスーパークラスである Objectクラスの to_sメソッド（\#\<DVD:0x000000011b951cf0>）**

irb などで Classオブジェクトに対して ancestorsメソッドを呼び出すと、クラスやモジュールがどの順番でメソッド探索されるか確認することができる。
```ruby
irb(main):028> DVD.ancestors
=> [DVD, B, A, Product, Object, PP::ObjectMixin, Kernel, BasicObject]
```

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBM0RaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--19189d8bc2e2415eaf1015805a11b33fbbdc0d11/IMG_1280.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBM0RaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--19189d8bc2e2415eaf1015805a11b33fbbdc0d11/IMG_1280.jpeg" width="4032" height="2268" alt="IMG_1280.jpeg"></a>

あるメソッドが呼び出された場合、Ruby はまず DVDクラスを探索し、最後は BasicObjectクラスを探索することが ancestorsメソッドの戻り値から分かる。もし最後の BasicObjectクラスでもメソッドが見つからなければ`NoMethodError`が発生する。以下のコードはわざと`NoMethodError`を発生させる例。
```ruby
irb(main):029> dvd.foo
(irb):29:in `<main>': undefined method `foo' for an instance of DVD (NoMethodError)
```


---


## ✍🏻 感想
### 🍒 モジュールができること
モジュールにはさまざまな用途があることを学びました。
- `include`や`extend`を使ってメソッドを定義できる。
- 名前空間を作成し、クラスやメソッドの衝突を防ぐ。
- 関数や定数を提供する役割を持つ。
- 状態を保持することも可能。

さらに、1つのモジュールが複数の役割を担うことができるという柔軟性にも気付きました。ただ、読み書きになるとまだ難しく感じる部分が多いです。これから経験を積みながら身に付けていきたいと思います。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 2 hours 46 min
- Total: 999 hours 06 min
