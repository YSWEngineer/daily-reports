# 2025/03/13(木)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [ ] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第8章  モジュールを理解する
    - 8.9 モジュールに関する高度な話題
      - モジュールに他のモジュールを include する
      - prepend でモジュールをミックスインする
      - prepend で既存メソッドを置き換える
      - 有効範囲を限定できる refinements
    - 二重コロン（::）とドット（.）の違い
    - 8.10 この章のまとめ


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.1 イントロダクション 〜
    

---


## 💡 本日の学び・気付き
### 8.8 状態を保持するモジュールの作成
#### モジュールにほかのモジュールを incude する
`include`はクラスだけでなく、モジュールに対しても呼び出すことができる。そして、ほかのモジュールを`include`しているモジュールをクラスやモジュールに`include`すれば、「include したモジュールが include しているほかのモジュール」も`include`したことになる。

たとえば、2つのモジュールと、1つのクラスがあったとする。
```ruby
module Greetable
  def Hello
    'hello.'
  end
end

module Aisatsu
  # 別のモジュールをincludeする
  include Greetable

  def konnnichiwa
    'こんにちは。'
  end
end

class User
  # Aisatsuモジュールだけをincludeする
  include Aisatsu
end
```

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBK2JaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--d1d6593ec07307fc51c38950514309df79817f10/IMG_1284.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBK2JaQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--d1d6593ec07307fc51c38950514309df79817f10/IMG_1284.jpeg" width="4032" height="2268" alt="IMG_1284.jpeg"></a>

この場合、Userクラスのインスタンスは Aisatsuモジュールのメソッドだけでなく、Aisatsuモジュールが`include`している Greetableモジュールのメソッドも呼び出すことができる。
```ruby
irb(main):015> user = User.new
irb(main):016> user.konnichiwa
=> "こんにちは。"
irb(main):017> user.hello
=> "hello."
```
Userクラスに対して ancestorsメソッド呼び出してみると、Aisatsuモジュールだけでなく、Greetalbeモジュールもメソッド探索の対象になっていることが分かる。
```ruby
irb(main):018> User.ancestors
=> [User, Aisatsu, Greetable, Object, PP::ObjectMixin, Kernel, BasicObject]
```

#### prepend でモジュールをミックスインする
モジュールで定義されたメソッドをインスタンスメソッドとしてミックスインする場合は`include`を使うのが一般的だが、もう一つの方法として`prepend`という方法でモジュールをミックスインすることもできる。

`prepend`の特徴は、同名のメソッドがあったときに、ミックスインしたクラスよりも先にモジュールのメソッドがよばれるところ。
```ruby
irb(main):001* module A
irb(main):002*   def to_s
irb(main):003*     "<A> #{super}"
irb(main):004*   end
irb(main):005> end
=> :to_s

irb(main):006* class Product
# includeではなくprependを使う
irb(main):007*   prepend A

irb(main):008*   def to_s
irb(main):009*     "<Product> #{super}"
irb(main):010*   end
irb(main):011> end
=> :to_s

irb(main):012> product = Product.new
irb(main):013> product.to_s
=> "<A> <Product> #<Product:0x00000001246a9d50>"
```
`prepend`ではなく、`include`した場合の結果。
```ruby
# prependではなくincludeでモジュールAをミックスインした場合
irb(main):013> product.to_s
=> "<Product> <A> #<Product:0x00000001240657f0>"
```
- `include`した場合：「Productクラス、モジュールA、Objectクラス」の順番で呼び出されている。
- `prepend`した場合：「モジュールA、Productクラス、Objectクラス」の順番で呼ばれている。

Productクラスの ancestorsメソッドの結果。
```ruby
# prependを使った場合
irb(main):029> Product.ancestors
=> [A, Product, A, Object, PP::ObjectMixin, Kernel, BasicObject]

# includeを使った場合
irb(main):015> Product.ancestors
=> [Product, A, Object, PP::ObjectMixin, Kernel, BasicObject]
```
以上の結果からも`prepend`を使うとミックスインしたクラスよりも先にモジュールからメソッドが検索されることが分かる。

#### prepend で既存メソッドを置き換える
`prepend`を活用できる場面の1つが、オリジナルの実装を生かした既存メソッドの置き換えである。たとえば、単純な Productクラスがあったとする。ただし、このクラスは外部ライブラリで定義されているため、直接コードを書き換えることはできないものとする。
```ruby
# このクラスは外部ライブラリで定義されている想定
irb(main):001* class Product
irb(main):002*   def name
irb(main):003*     'A great film'
irb(main):004*   end
irb(main):005> end
=> :name

irb(main):006> product = Product.new
irb(main):007> product.name
=> "A great film"
```
↑このクラスの nameメソッドを拡張して、"<< A great film>>"のような装飾が入るようにしてみる。
```ruby
# nameメソッドを拡張して装飾付きの文字列が返るようにしたい
product.name
#=> "<<A great file>>"
```
直接 Productクラスの nameメソッドは書き換えることができないため、次のような NameDecoratorモジュールを定義する。このモジュールは`include`ではなく、`prepend`で使う想定。
```ruby
# prependするためのモジュールを定義する
module NameDecorator
  def name
    # prependするとsuperはミックスインした先のクラスのnameメソッドが呼び出される
    "<<#{super}>>"
  end
end
```
このモジュールを Productクラスに`prepend`する。
```ruby
# 既存の実装を変更するためにProductクラスを再オープンする
class Product
  # includeではなくprependでミックスインする
  prepend NameDecorator
end
```
このように書けば Productクラスの nameメソッドを直接書き換えることなく、なおかつ元の実装を活かしながら振る舞いを変更することができる。
```ruby
# NameDecoratorをprependしたので、nameメソッドは実装された文字列が返る
product = Product.new
product.name #=> "<<A great film>>"
```
この方法であれば、他のクラスに対しても簡単に同じ変更を適用することができる。
```ruby
# Productクラスと同じようにnameメソッドを持つクラスがあったとする
class User
  def name
    'Alice'
  end
end

class User
  # prependを使えばUserクラスのnameメソッドも置き換えることができる
  prepend NameDecorator
end

# Userクラスのnameメソッドを上書きすることができる
user = User.new
user.name #=> "<<Alice>>"
```

#### 有効範囲を限定できる refinements
Ruby は標準ライブラリや外部ライブラリ（gem）であってもあとからオーバーライドしたり、独自のメソッドを追加したりできる。だが、広範囲に使われるクラスを独自に変更すると、予期せぬ不具合に遭遇するリスクも高まってしまう。

そんなリスクを軽減してくれるのが、refinements とよばれる機能。refinements を使うと独自の変更の有効範囲（スコープ）を限定することができる。

例として、refinements を使い Stringクラスに文字列の中身をランダムに入れ替える shuffleメソッドを追加してみる。先ず、refinements を使う準備としてモジュールを作成する。モジュール内では refineメソッドを使い refinements を適用するクラスを指定し、そのブロックの中に使いする shuffleメソッドの定義を書く。
```ruby
module StringShuffle
  # refinementsが目的なので、refineメソッドを使う
  refine String do
    def shuffle
      chars.shuffle.join
    end
  end
end
```
refinements を有効にするためには using というメソッドを使う。以下のようにすると、Userクラスの内部においてのみ、shuffleメソッドが有効になる。
```ruby
# 通常はStringクラスにshuffleメソッドはない
irb(main):008> 'Alice'.shuffle
(irb):8:in `<main>': undefined method `shuffle' for an instance of String (NoMethodError)

irb(main):009* class User
# refinementsを有効化する
irb(main):010*   using StringShuffle

irb(main):011*   def initialize(name)
irb(main):012*     @name = name
irb(main):013*   end

irb(main):014*   def shuffled_name
# Userクラスの内部であればStringクラスのshuffleメソッドが有効になる
irb(main):015*     @name.shuffle
irb(main):016*   end

# Userクラスを抜けるとrefinementsは無効になる
irb(main):017> end
=> :shuffled_name

irb(main):018> user = User.new('Alice')
# Userクラス内ではshuffleメソッドが有効になっている
irb(main):019> user.shuffled_name
=> "cliAe"

# Userクラスを経由しない場合はshuffleメソッドは使えない
irb(main):020> 'Alice'.shuffle
(irb):20:in `<main>': undefined method `shuffle' for an instance of String (NoMethodError)
```
Userクラスの内部だけ shuffleメソッドが使えるようになった。refinements を使うと既存クラスに対する変更の有効範囲が限定できるため、**予期せぬバグやエラーに遭遇するリスクを低減する**ことができる。

usingメソッドはクラス構文とモジュール構文の内部で使うことができる。また、トップレベル（クラス構文やモジュール構文の外部）でも使用できるが、その場合は有効範囲が「using で呼び出された場所からファイルの最後まで」になる。

#### 二重コロン（::）とドット（.）の違い
たとえば、Sampleモジュールに次のような定数とクラスメソッドを持った Userクラスがあったとする。
```ruby
module Sample
  class User
    NAME = 'Alice'

    def self.hello(name = NAME)
      "Hello, I am #{name}."
    end
  end
end
```
**名前空間を区切ったり定数を参照したりするときは二重コロン**を使い、**メソッドを呼び出す場合はドット**を使うのが典型的な使い分けになる。
```ruby
irb(main):009> Sample::User::NAME
=> "Alice"

irb(main):010> Sample::User.hello
=> "Hello, I am Alice."
```
しかし、メソッド呼び出しに関しては二重コロンを使うこともできる。
```ruby
irb(main):011> Sample::User::hello
=> "Hello, I am Alice."
```
二重コロン`::`は、メソッド呼び出しにも使える。また、左辺はクラスやモジュールである必要はない。どんなオブジェクトでも`::`でメソッドを呼び出すことができる。
```ruby
irb(main):012> s = 'abc'
irb(main):013> s::upcase
=> "ABC"
```
では、二重コロンとドットの違いはというと、ドットは二重コロンとは異なり、名前空間を区切ったり、定数を参照したりする用途には使えない。なぜなら、**ドットの右辺は常にメソッドあることが期待される**から。
```ruby
# Sample.UserだとUserがメソッドと見なされる
irb(main):014> Sample.User::NAME
(irb):14:in `<main>': undefined method `User' for module Sample (NoMethodError)

# User.NAMEだとNAMEがメソッドと見なされる
irb(main):015> Sample::User.NAME
(irb):15:in `<main>': undefined method `NAME' for class Sample::User (NoMethodError)
```

##### 二重コロンとドットの違い

|   |右辺がメソッド   |右辺が定数またはクラスやモジュール   |
|---|:---:|:---:|
|二重コロン（::）   |OK   |OK   |
|ドット（.）   |OK   |NG   |

とはいえ、慣習的に二重コロンは名前空間を区切ったり、定数を参照したりする用途で使われることが多い。


---


## ✍🏻 感想
### 🍒 モジュールを振り返る
小規模なプログラムでは、モジュールを使わずにシンプルなクラスやメソッドで十分な場合があります。しかし、プログラムが大きくなったり、再利用性やコードの整理が重要になってくると、モジュールの利用が非常に便利です。

モジュールを使う主な理由は以下の通りです。
- コードの再利用性：特定の機能をモジュールにまとめることで、複数のクラスで同じ機能を共有できる。
- 名前空間の整理：モジュールを使うことで、クラスやメソッドの名前が他の部分と衝突するのを避けられる。
- ミックスイン：特定の機能をクラスに追加できるため、コードの一貫性が保たれる。

まだ、開発の経験はありませんが、クラスと同様にモジュールも Rubyプログラムを書いていく上で大切な要素です。何度も読み直して理解を深めたいと思います。

---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp; 3 hours 13 min
- Total: 1002 hours 19 min
