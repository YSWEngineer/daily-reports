# 2025/03/14(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [ ] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.1 イントロダクション 
      - この章の例題：正規表現チェッカープログラム
      - 正規表現チェッカーの実行例
      - この章で学ぶこと
    - 9.2 例外の捕捉
      - 発生した例外を捕捉しない場合
      - 例外を捕捉して処理を続行する場合
      - 例外処理の流れ
      - 例外オブジェクトから情報を取得する
      - クラスを指定して捕捉する例外を限定する
      - 例外クラスの継承関係を理解する


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.2 例外の捕捉
      - 継承関係と rescue節の順番に注意する 〜
    

---


## 💡 本日の学び・気付き
### 9.1 イントロダクション
例外（Exception）とは、プログラムの実行中（場合によっては実行前）に発生した「例外的な問題」のこと。つまり、「エラーが起きてプログラムの実行を続けることができなくなった状態」と言える。プログラマが特に手を打たなければ、例外が発生した時点でプログラムの実行は終了する。しかし、意図的にそのエラーを捕捉し、プログラムを続行させることもできる。また、例外は補足するだけでなく「これはプログラムが続行できない異常事態」として例外を意図的に発生させることもできる。

本格的なプログラムでは例外の扱いが非常に重要になってくる。例外を適切に扱えば堅牢で読みやすいコードができあがるし、万一エラーが起きた場合でも原因の調査がしやすくなる。例外を適切に扱わなかったら、意図しない構造のデータが保存されたり、コードが過度に複雑になったり、発生したエラーの調査に時間がかかったりする。

### 9.2 例外の捕捉
#### 発生した例外を捕捉しない場合
`1 + '10'`を irb で実行すると次のようになる。
```ruby
irb(main):001> 1 + '10'
(irb):1:in `+': String can't be coerced into Integer (TypeError)
	from (irb):1:in `<main>'
	from <internal:kernel>:187:in `loop'
	from /Users/yoshiwo/.rbenv/versions/3.3.1/lib/ruby/gems/3.3.0/gems/irb-1.11.0/exe/irb:9:in `<top (required)>'
	from /Users/yoshiwo/.rbenv/versions/3.3.1/bin/irb:25:in `load'
	from /Users/yoshiwo/.rbenv/versions/3.3.1/bin/irb:25:in `<main>'
```
実行結果の2行目以降に載っているのが例外に関する情報。`String can't be coerced into Integer`は発生した例外に関するメッセージで、日本語に訳すと「String を Integer に変換することはできない」という意味になる。行の最後で丸括弧に囲まれている`TypeError`は**発生した例外のクラス名**。Ruby では例外も例外クラスのインスタンス（例外オブジェクト）になっている。TypeError は発生した例外オブジェクトのクラス名で、「データ型（type）のエラー」を表す。これらの情報を合わせると、データ型がおかしい（文字列を整数に変換できなかった）ために例外が発生した、ということがわかる。

2行目の冒頭にある`(irb):1:in `+'`は**例外が発生した場所**を示す。3行目以降の情報は**例外が発生するまでのメソッドの呼び出し履歴**。この情報を**バックトレース**や**スタックトレース**と呼ぶ。バックトレースはデバッグする際の重要な情報源になる。

Ruby や irb のバージョンによっては出力形式が異なる場合がある。特に、Ruby 2.5 から 2.7、もしくは Ruby 3.0.0 と irb 1.3.0 の組み合わせで実行した場合は、エラーメッセージが一番下に表示され、バックトレースの表示順も逆になる。

発生した例外は、irb であれば続けて他のコードを動かすことができるが、rubyコマンドで実行した場合は例外が発生した時点でプログラムが終了する。たとえば以下のコードをファイルに保存して rubyコマンドで実行した場合、最後の行にある`puts 'End.'`は実行されない。
```ruby
puts 'Start.'
1 + '10'
# 上の行で例外が発生するため、ここから下は実行されない
puts 'End.'
```
上記のコードを sample.rb という名前で保存し、rubyコマンドで実行すると、`puts 'Start.'`は出力されているが、最後の`puts 'End.'`は出力されていないのがわかる。
```shell
~ % ruby sample.rb
Start.
sample.rb:2:in `+': String can't be coerced into Integer (TypeError)

1 + '10'
    ^^^^
	from sample.rb:2:in `<main>'
```

#### 例外を捕捉して処理を続行する場合
もし、なんらかの理由で例外が発生してもプログラムを続行したい場合は、例外処理を明示的に書くことでプログラムを続行させることが可能。例外処理の最も単純な構文は次のようになる。
```ruby
begin
  # 例外が起きうる処理
rescue
  # 例外が発生した場合の処理
end
```
先ほどのプログラムに例外処理を組み込んでみる。
```ruby
puts 'Start.'

# 例外処理を組み込んで例外に対処する
begin
  1 + '10'
rescue
  puts '例外が発生したが、このまま続行する'
end

# 例外処理を組み込んだので、最後まで実行可能
puts 'End.'
```
これを実行すると次のようになる。
```shell
~ % ruby sample.rb
Start.
例外が発生したが、このまま続行する
End.
```
`End.`の文字が出力されていることから、例外処理がうまく機能して最後までプログラムが実行できていることがわかる。

#### 例外処理の流れ
実際のプログラムでは予期できない箇所で例外が発生することもある。例外が発生した箇所が`begin ~ rescue`で囲まれていない場合、例外が発生すると、そこで処理を中断してメソッドの呼び出しを1つずつ戻っていく。メソッド呼び出しを戻る途中にその例外を捕捉するコードがあれば、そこから処理を続行できる。たとえば以下は例外が発生した箇所から少し離れた箇所で例外を捕捉するコード例。
```ruby
# method_1にだけ例外処理を記述する
irb(main):001* def method_1
irb(main):002*   puts 'method_1 start.'
irb(main):003*   begin
irb(main):004*     method_2
irb(main):005*   rescue
irb(main):006*     puts '例外が発生しました'
irb(main):007*   end
irb(main):008*   puts 'method_1 end.'
irb(main):009> end
=> :method_1

irb(main):010* def method_2
irb(main):011*   puts 'method_2 start.'
irb(main):012*   method_3
irb(main):013*   puts 'method_2 end.'
irb(main):014> end
=> :method_2

irb(main):015* def method_3
irb(main):016*   puts 'method_3 start.'
# ZeroDivisionError（整数を0で助産しようとした場合に発生する例外）を発生させる
irb(main):017*   1 / 0
irb(main):018*   puts 'method_3 end.'
irb(main):019> end

# 処理を開始する
irb(main):020> method_1
method_1 start.
method_2 start.
method_3 start.
例外が発生しました
method_1 end.
```
上記のコードは method_1メソッドから処理が始まっている。method_1メソッドは method_2メソッドを呼び、method_2メソッドは method_3メソッドを呼ぶ。method_3メソッドを呼ぶと、`ZeroDivisionError`が発生する。method_3メソッドには例外を捕捉するコードがないので、method_2メソッドに処理が戻る。しかし、method_2メソッドにも例外を捕捉するコードがないので、さらに method_1メソッドに戻る。method_1メソッドでは method_2メソッドの呼び出しを`begin ~ rescue`で囲んでいたため、ここで例外が捕捉され、`例外が発生しました`の文字列を出力している。

また、実行結果の出力内容を見ると method_1だけが`method_1 end.`を出力しているが、method_2 と method_3 は`end`を出力していない。このことから、例外を捕捉した method_1 だけが処理を続行でき、method_2 と method_3 は例外が発生した時点で処理が中断されたままになっていることがわかる。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeXZhQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--8c79b7482bb01d6cecb6bcb7f6230bd900ee6377/IMG_1290.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeXZhQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--8c79b7482bb01d6cecb6bcb7f6230bd900ee6377/IMG_1290.jpeg" width="4032" height="2268" alt="IMG_1290.jpeg"></a>

もし、method_1 でも例外が捕捉されなければ、発生した例外はメソッド呼び出しを全部遡っても完全に無視されたことになる。こうなるとプログラム全体がそこで異常終了する。
```ruby
# method_1から例外処理を削除する
irb(main):021* def method_1
irb(main):022*   puts 'method_1 start.'
irb(main):023*   method_2
irb(main):024*   puts 'method_1 end.'
irb(main):025> end
=> :method_1

irb(main):026* def method_2
irb(main):027*   puts 'method_2 start.'
irb(main):028*   method_3
irb(main):029*   puts 'method_2 end.'
irb(main):030> end
=> :method_2

irb(main):031* def method_3
irb(main):032*   puts 'method_3 start.'
irb(main):033*   1 / 0
irb(main):034*   puts 'method_3 end.'
irb(main):035> end

irb(main):036> method_1
method_1 start.
method_2 start.
method_3 start.
(irb):33:in `/': divided by 0 (ZeroDivisionError)
```

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeXphQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--6d8e347f933bb5e90005f5139ccab2d309562c7b/IMG_1291.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeXphQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--6d8e347f933bb5e90005f5139ccab2d309562c7b/IMG_1291.jpeg" width="4032" height="2268" alt="IMG_1291.jpeg"></a>

#### 例外オブジェクトから情報を取得する
Ruby では発生した例外自身もオブジェクトになっているため、例外オブジェクトのメソッドを呼び出すことで、発生した例外に関する情報を取得することができる。代表的なメソッドとして messageメソッドと backtraceメソッドを使ってみる。
- **messageメソッド**：例外発生時のエラーメッセージを返す。
- **backtraceメソッド**：バックトレース情報（メソッドの呼び出し履歴）を配列にして返す。

例外オブジェクトから情報を取得したい場合は次のような構文を使う。
```ruby
begin
  # 例外が起きうる処理
rescue => 例外オブジェクトを格納する変数
  # 例外が発生した場合の処理
end
```
以下は具体的なコード例。
```ruby
begin
  1 / 0
rescue => e
  puts "エラークラス: #{e.class}"
  puts "エラーメッセージ: #{e.message}"
  puts "バックトレース -----"
  puts e.backtrace
  puts "-----"
end
```
例外オブジェクトを格納する変数の名前は自由に付けることができるが、`exception`の省略形として`e`や`ex`のような名前をよく見かける。上記のコードでは messageメソッドと backtraceメソッドの取得内容を、putsメソッドを使って出力している。これを irb で動かすと次のような結果が出力される。
```ruby
エラークラス: ZeroDivisionError
エラーメッセージ: divided by 0
バックトレース -----
(irb):2:in `/'
```

#### クラスを指定して補足する例外を限定する
例外には多くの種類があり、その種類ごとにクラスが異なる。存在しないメソッドを呼び出した場合は`NoMethodError`クラスの例外が発生し、0 で除算した場合は`ZeroDivisionError`が発生する。次のような構文を使い例外のクラスを指定すると、例外オブジェクトのクラスが一致した場合のみ、例外を捕捉することができる。
```ruby
begin
  # 例外が起きうる処理
rescue 捕捉したい例外クラス
  # 例外が発生した場合の処理
end
```
具体的なコード例。
```ruby
irb(main):001* begin
irb(main):002*   1 / 0
irb(main):003* rescue ZeroDivisionError
irb(main):004*   puts '0で除算しました'
irb(main):005> end
0で除算しました
```
上記のコードは`ZeroDivisionError`が発生した場合のみ rescue節のコードが実行され、プログラムを続行することができる。次のように`ZeroDivisionError`以外のエラーが発生した場合は、例外は捕捉されない（プログラムが異常終了する）。
```ruby
irb(main):001* begin
# NoMethodErrorを発生させる
irb(main):002*   'abc'.foo
irb(main):003* rescue ZeroDivisionError
irb(main):004*   puts '0で除算しました'
irb(main):005> end
(irb):2:in `<main>': undefined method `foo' for an instance of String (NoMethodError)
```
rescue節を複数書くことで、異なる例外クラスに対応することもできる。
```ruby
irb(main):006* begin
irb(main):007*   'abc'.foo
irb(main):008* rescue ZeroDivisionError
irb(main):009*   puts '0で除算しました'
irb(main):010* rescue NoMethodError
irb(main):011*   puts '存在しないメソッドが呼び出されました'
irb(main):012> end
存在しないメソッドが呼び出されました
```
1つの rescue節に複数の例外クラスを指定することもできる。
```ruby
irb(main):013* begin
irb(main):014*   'abc'.foo
irb(main):015* rescue ZeroDivisionError, NoMethodError
irb(main):016*   puts '0で除算したか、存在しないメソッドが呼び出されました'
irb(main):017> end
0で除算したか、存在しないメソッドが呼び出されました
```
例外オブジェクトを変数に格納することも可能。
```ruby
irb(main):001* begin
irb(main):002*   'abc'.foo
irb(main):003* rescue ZeroDivisionError, NoMethodError => e
irb(main):004*   puts '0で除算したか、存在しないメソッドが呼び出されました'
irb(main):005*   puts "エラー: #{e.class} #{e.message}"
irb(main):006> end
0で除算したか、存在しないメソッドが呼び出されました
エラー: NoMethodError undefined method `foo' for an instance of String
```

#### 例外クラスの継承関係を理解する
rescue節で例外クラスを指定する場合は、Ruby における例外クラスの継承関係を理解しておく必要がある。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeS9hQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--595899da32eaef148ac8699ae5d63696fa0a2ed7/IMG_1292.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeS9hQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--595899da32eaef148ac8699ae5d63696fa0a2ed7/IMG_1292.jpeg" width="4032" height="2268" alt="IMG_1292.jpeg"></a>

全ての例外クラスは Exceptionクラスを継承している。大事なポイントは `StandardError`のサブクラスとそれ以外の例外クラスの違いを理解すること。

StandardErrorクラスは通常のプログラムで発生する可能性の高い例外を表すクラス。`NoMethodError`や`ZeroDivisionError`も StandardErrorクラスのサブクラスになっている。

rescue節に何もクラスを指定しなかった場合に捕捉されるのは`StandardError`とそのサブクラス。`NoMemoryError`や`SystemExit`など、StandardError を継承していない例外クラスは捕捉されない。
```ruby
begin
  # 例外が起きそうな処理
rescue
  # StandardErrorとそのサブクラスのみ捕捉される
end
```
rescue節に例外クラスを指定した場合、捕捉されるのはそのクラス自身とそのサブクラスになる。たとえば Exceptionクラスを指定すると、StandardError と無関係のエラーまで捕捉することになる。
```ruby
# 例外処理の悪い例
begin
  # 例外が起きそうな処理
rescue Exception
  # Exceptionとそのサブクラスが捕捉される。つまりNoMemoryErrorやSystemExitまで捕捉される
end
```
通常のプログラムで捕捉するのは StandardErrorクラスか、そのサブクラスに限定すべき。


---


## ✍🏻 感想
### 🍒 例外もオブジェクト
Ruby では例外もオブジェクトとして生成される、ということを学びました。そもそも Ruby の「すべてがオブジェクト」という仕組み（概念）が、例外処理にも反映されていると言えますよね。次回も例外処理について引き続きインプットしていきます。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 hours 52 min
- Total: 1006 hours 11 min
