# 2025/03/17(月)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [ ] 9.3 意図的に例外を発生させる
   - [ ] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.2 例外の捕捉
      - 継承関係と rescue節の順番に注意する
      - 例外発生時にもう一度処理をやりなおす retry


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.3 意図的に例外を発生させる
    

---


## 💡 本日の学び・気付き
### 9.1 イントロダクション
例外（Exception）とは、プログラムの実行中（場合によっては実行前）に発生した「例外的な問題」のこと。つまり、「エラーが起きてプログラムの実行を続けることができなくなった状態」と言える。プログラマが特に手を打たなければ、例外が発生した時点でプログラムの実行は終了する。しかし、意図的にそのエラーを捕捉し、プログラムを続行させることもできる。また、例外は補足するだけでなく「これはプログラムが続行できない異常事態」として例外を意図的に発生させることもできる。

本格的なプログラムでは例外の扱いが非常に重要になってくる。例外を適切に扱えば堅牢で読みやすいコードができあがるし、万一エラーが起きた場合でも原因の調査がしやすくなる。例外を適切に扱わなかったら、意図しない構造のデータが保存されたり、コードが過度に複雑になったり、発生したエラーの調査に時間がかかったりする。

### 9.2 例外の捕捉
#### 継承関係と rescue節の順番に注意する
rescue節が複数ある場合は、上から順番に発生した例外クラスが rescue節のクラスにマッチするかどうかチェックされる。rescue節に例外クラスを指定すると、そのクラス自身とそのサブクラスが捕捉の対象になる。そのため、例外クラスの継承関係と rescue節を書く順番に注意しないと、永遠に実行されない rescue節を作ることになってしまう。

以下の図では、メソッドが存在しない場合に発生する NoMethodError は NameErrorクラスを継承している。つまり、NameErrorクラスがスーパークラスで、NoMethodError がそのサブクラスとなる。

<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBN3ZhQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--3c66f95f0849d8e4bd7d497858472aadbe88cb4d/IMG_1303.jpeg" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBN3ZhQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--3c66f95f0849d8e4bd7d497858472aadbe88cb4d/IMG_1303.jpeg" width="4032" height="2268" alt="IMG_1303.jpeg"></a>

NoMethodError と NameError の両者を区別して処理したいと思った場合、以下のように書くと2つ目の rescue節は永遠に実行されない。
```ruby
# 間違った例外処理の例
irb(main):001* begin
# NoMethodErrorを発生させる
irb(main):002*   'abc'.foo
irb(main):003* rescue NameError
# NoMethodErrorはここで捕捉される
irb(main):004*   puts 'NameErrorです'
irb(main):005* rescue NoMethodError
# このrescue節は永遠に実行されない
irb(main):006*   puts 'NoMethodErrorです'
irb(main):007> end
NameErrorです
```

##### 2つ目の rescue節が実行されない理由
NameError は NoMethodError のスーパークラスなので、NameErrorクラスを指定した最初の rescue節で捕捉される。そのため、どんなことがあっても2つ目の rescue節に到達することはない。

この問題を解決する方法は、スーパークラスよりもサブクラスを手前に持ってくるようにすればよい。
```ruby
irb(main):001* begin
irb(main):002*   'abc'.foo
irb(main):003* rescue NoMethodError
# NoMethodErrorはここで捕捉される
irb(main):004*   puts 'NoMethodErrorです'
irb(main):005* rescue NameError
irb(main):006*   puts 'NameErrorです'
irb(main):007> end
NoMethodErrorです
```
こうすることで NameError の rescue節よりも先に NoMethodError の rescue節が評価されるため、NoMethodError用の例外処理を実行することができる。NameError が発生した場合は NameError 用の例外処理を実行することができる。
```ruby
irb(main):001* begin
# NameErrorを発生させる
irb(main):002*   Foo.new
irb(main):003* rescue NoMethodError
irb(main):004*   puts 'NoMethodErrorです'
irb(main):005* rescue NameError
irb(main):006*   puts 'NameErrorです'
irb(main):007> end
NameErrorです
```
例外処理を書く場合は例外クラスの継承関係を意識しておかないと、不適切な例外処理を作ってしまう恐れがあるため注意すること。

次のように最後に StandardErrorクラスを指定すれば、通常のプログラミングで発生するその他のエラーをまとめて捕捉することができる（最後に指定するのは、StandardError が NoMethodError や NameError のスーパークラスだから）。
```ruby
irb(main):001* begin
irb(main):002*   1 / 0
irb(main):003* rescue NoMethodError
irb(main):004*   puts 'NoMethodErrorです'
irb(main):005* rescue NameError
irb(main):006*   puts 'NameErrorです'
irb(main):007* rescue StandardError
irb(main):008*   puts 'その他のエラーです'
irb(main):009> end
その他のエラーです
```
しかし、StandardError とそのサブクラスを捕捉するのなら、**クラスを指定する必要がない**ので、次のように書くほうがシンプルである。
```ruby
irb(main):001* begin
# ZeroDivisionErrorを発生させる
irb(main):002*   1 / 0
irb(main):003* rescue NoMethodError
irb(main):004*   puts 'NoMethodErrorです'
irb(main):005* rescue NameError
irb(main):006*   puts 'NameErrorです'
irb(main):007* rescue # 例外クラスを指定しない
irb(main):008*   puts 'その他のエラーです'
irb(main):009> end
その他のエラーです
```

#### 例外発生時にもう一度処理をやりなおす retry
ネットワークエラーのように一時的に発生している問題が例外の原因であれば、何度かやりなおすことで正常に実行できる可能性がある。そんな場合は rescue節で retry文を実行すると、begin節の最初からやり直すことができる。
```ruby
begin
  # 例外が発生するかもしれない処理
rescue
  retry # 処理をやりなおす
end
```
ただし、無条件に retry し続けると、例外が解決しない場合に無限ループを作ってしまう恐れがある。そういう場合は**カウンタ変数**を用意し、retry の回数を制限するのがよい。
```ruby
irb(main):001> retry_count = 0
=> 0
irb(main):002* begin
irb(main):003*   puts '処理を開始します。'
irb(main):004*   1 / 0
irb(main):005* rescue
irb(main):006*   retry_count += 1
irb(main):007*   if retry_count <= 3
irb(main):008*     puts "retryします。 (#{retry_count}回目)"
irb(main):009*     retry
irb(main):010*   else
irb(main):011*     puts 'retryに失敗しました。'
irb(main):012*   end
irb(main):013> end
処理を開始します。
retryします。 (1回目)
処理を開始します。
retryします。 (2回目)
処理を開始します。
retryします。 (3回目)
処理を開始します。
retryに失敗しました。
```

---


## ✍🏻 感想
### 🍒 1時間だけインプット
例外を捕捉して処理する方法を学びました。やはり、Ruby の「すべてがオブジェクト」という設計思想、例外処理にも反映されているのが印象的で、「クラス間の関係が非常に重要な役割を果たしているな」と感じました。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 hours 17 min
- Total: 1007 hours 28 min
