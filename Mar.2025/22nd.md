# 2025/03/22(土)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [ ] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.3 意図的に例外を発生させる
    - 9.4 例外処理のベストプラクティス
      - rescue したら情報を残す
      - 例外処理の対象範囲と対象クラスを極力絞り込む
      - 例外処理よりも条件分岐を使う
      - 予期しない条件は異常終了させる
      - 例外処理も手を抜かずにテストする


---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.5 例題：正規表現チェッカープログラムの作成 〜
    

---


## 💡 本日の学び・気付き
### 9.3 意図的に例外を発生させる
#### rescue したら情報を残す
**例外が発生しても rescue しないこと**が、例外処理の原則。しかし、状況によっては rescue すべきケースも存在する。もし rescue するときは、そのあとで原因調査ができるように、例外時の状況を確実に記録に残すこと。最低でも発生した、
- **例外のクラス名**
- **エラーメッセージ**
- **バックトレース**

以上の3つはログやターミナルに出力すべき。
```ruby
# 大量のユーザにメールを送信する（例外が起きても最後まで続行する）
users.each do |user|
  begin
    # メール送信を実行する
    send_mail_to(user)
  rescue => e
    # full_messageメソッドを使って例外のクラス名、エラーメッセージ、バックトレースをターミナルに出力
    # （ログファイルがあればそこに出力するほうがベター）
    puts e.full_message
  end
end
```
出力する理由は、例外を rescue したら**その場で情報を残さないと詳細な情報が失われてしまう**から。手がかりが多ければ原因調査は楽になり、少なければ難しくなる。

#### 例外処理の対象範囲と対象クラスを極力絞り込む
実際に例外処理を書く場合は、**例外が発生しそうな箇所** と **発生しそうな例外クラス**を予め予想し、その予想を例外処理のコードに反映させること。たとえば、「令和3年12月31日」のような日付文字列を Dateクラスのオブジェクトに変換するメソッドを実装したとする。
```ruby
require 'date'

# 令和の日付文字列をDateオブジェクトに変換する
def convert_reiwa_to_date(reiwa_text)
  begin
    m = reiwa_text.match(/令和(?<jp_year>\d+)年(?<month>\d+)月(?<day>\d+)日/)
    year = m[:jp_year].to_i + 2018
    month = m[:month].to_i
    day = m[:day].to_i
    Date.new(year, month, day)
  rescue
    # 例外が起きたら（=無効な日付が渡されたら）nilを返したい
    nil
  end
end
```
上記のコードでは、無効な日付を渡されると nil を返したいので以外処理を書いているが、このままだとメソッド実行中に発生した例外を全て飲み込んで nil を返してしまう。たとえ自分の書いたコードにタイプミスがあったとしてもそれは nil で返ってくる。

実際は不正な日付を渡されて例外が発生するのは`Date.new(year, month, day)`の部分だけ。また、そのときに発生する例外クラスは ArgumentErrorクラス。そのため、以下のような例外処理を書くのが望ましい。
```ruby
irb(main):001> require 'date'
=> true
irb(main):002* def convert_reiwa_to_date(reiwa_text)
irb(main):003*   m = reiwa_text.match(/令和(?<jp_year>\d+)年(?<month>\d+)月(?<day>\d+)日/)
irb(main):004*   year = m[:jp_year].to_i + 2018
irb(main):005*   month = m[:month].to_i
irb(main):006*   day = m[:day].to_i
irb(main):007*   begin
irb(main):008*     Date.new(year, month, day)
irb(main):009*   rescue ArgumentError
# 無効な日付であればnilを返す
irb(main):010*     nil
irb(main):011*   end
irb(main):012> end

irb(main):013> convert_reiwa_to_date('令和3年12月31日')
=> #<Date: 2021-12-31 ((2459580j,0s,0n),+0s,2299161j)>
irb(main):014> convert_reiwa_to_date('令和3年99月99日')
=> nil
```
↑このコードであれば、**Dateオブジェクトの作成に失敗したときだけ**例外が捕捉される。また、捕捉する例外を ArgumentErrorクラスに限定したため、それ以外の例外は異常終了扱いになる。こうすることで**無効な入力値** と **それ以外の例外**を分離できるようになる。

#### 例外処理よりも条件分岐を使う
例外の発生がある程度予想できる処理であれば、実際に実行する前に問題の有無を確認できる場合がある。たとえば、Dateオブジェクトの作成でも、`Date.valid_date?`メソッドで正しい日付かどうかを確認することができる。
```ruby
irb(main):001> require 'date'
=> true
irb(main):002* def convert_reiwa_to_date(reiwa_text)
irb(main):003*   m = reiwa_text.match(/令和(?<jp_year>\d+)年(?<month>\d+)月(?<day>\d+)日/)
irb(main):004*   year = m[:jp_year].to_i + 2018
irb(main):005*   month = m[:month].to_i
irb(main):006*   day = m[:day].to_i
# 正しい日付の場合のみ、Dateオブジェクトを作成する
irb(main):007*   if Date.valid_date?(year, month, day)
irb(main):008*     Date.new(year, month, day)
irb(main):009*   end
irb(main):010> end
irb(main):011> convert_reiwa_to_date('令和3年12月31日')
=> #<Date: 2021-12-31 ((2459580j,0s,0n),+0s,2299161j)>
irb(main):012> convert_reiwa_to_date('令和3年99月99日')
=> nil
```
`begin〜rescue`を使うよりも**条件分岐を使ったほうが可読性やパフォーマンスの面で有利**である。

#### 予期しない条件は異常終了させる
case文で条件分岐を作る場合は、when節で想定可能なパターンをすべて網羅し、else節では「想定外のパターン」として例外を発生させることを検討すること。

たとえば、引数で渡された国名に応じてその通貨名を返すメソッドを定義する。もし、想定している国以外が渡されたときはどうすればよいのか？このような「通常ありえないケース」にどのように対処するかによって状況がいろいろと変わっていく。

以下は、else節を用意しないパターン。
```ruby
# elseを用意しないパターン（良くない例）
irb(main):001* def currency_of(country)
irb(main):002*   case country
irb(main):003*   when :japan
irb(main):004*     'yen'
irb(main):005*   when :us
irb(main):006*     'dollar'
irb(main):007*   when :india
irb(main):008*     'rupee'
irb(main):009*   end
irb(main):010> end
# 想定外の国名を渡すとnilが返る
irb(main):011> currency_of(:italy)
=> nil
```
↑この場合は想定外の国名を渡したときに nil が返る。もしメソッドを呼び出した側が戻り値として文字列（Stringオブジェクト）しか想定していなかったとすると、NoMethodError が発生するかもしれない。
```ruby
irb(main):011> currency = currency_of(:italy)
# 戻り値が常にStringオブジェクトだと思い込んでしまい、upcaseメソッドを呼び出してしまった
irb(main):012> currency.upcase
(irb):12:in `<main>': undefined method `upcase' for nil (NoMethodError)
```
次は else を`:india`として扱うパターン。
```ruby
# elseを:indiaとして扱うパターン（良くない例）
irb(main):001* def currency_of(country)
irb(main):002*   case country
irb(main):003*   when :japan
irb(main):004*     'yen'
irb(main):005*   when :us
irb(main):006*     'dollar'
irb(main):007*   else
irb(main):008*     'rupee'
irb(main):009*   end
irb(main):010> end
# 矛盾した値が返ってきてしまう
irb(main):011> currency_of(:italy)
=> "rupee"
```
良くない例を見てわかるように、想定外のパターンがやってきたときは例外を発生させ、速やかにプログラムの実行を中止するのがよい。
```ruby
# elseに入ったら例外を発生させるパターン（良い例）
irb(main):001* def currency_of(country)
irb(main):002*   case country
irb(main):003*   when :japan
irb(main):004*     'yen'
irb(main):005*   when :us
irb(main):006*     'dollar'
irb(main):007*   when :india
irb(main):008*     'rupee'
irb(main):009*   else
irb(main):010*     raise ArgumentError, "無効な国名です。#{country}"
irb(main):011*   end
irb(main):012> end
# 例外が発生する
irb(main):013> currency_of(:italy)
(irb):10:in `currency_of': 無効な国名です。italy (ArgumentError)
```
↑例外が発生するためプログラムの実行はそこでストップしてしまうが、**エラーメッセージやバックトレースが残るため、原因の調査と対策がしやすく**なる。

良くない例の2パターンは「微妙におかしい状態」を保ったままプログラムが実行され続けるので、いつ爆発するかわからない時限爆弾のような不具合を抱えることになる。それに比べて、**できるだけ早い段階で例外を発生させてプログラムを緊急停止させた**ほうが、同じ不具合でも「**良い不具合**」だと言える。

#### 例外処理も手を抜かずにテストする
例外処理は「例外的な状況」に対する処理。そして例外処理は「例外的な状況」でしか呼び出されないため、テストしづらいケースも多い。かといって、テストをなおざりにしてはいけない。

たとえば、以下は rescue節の中で message 綴りを間違えてしまった場合のコード例。
```ruby
irb(main):001* def some_method
irb(main):002*   1 / 0
irb(main):003* rescue => e
# full_messageと書くつもりがfull_mesageと書いてしまった
irb(main):004*   puts "ERROR! #{e.full_mesage}"
irb(main):005> end

# rescue節で別の例外が起きたために、本来出力されるべき"ERROR!"の文字が出力されない
irb(main):006> some_method
(irb):4:in `rescue in some_method': undefined method `full_mesage' for an instance of ZeroDivisionError (NoMethodError)
```
rescue節で別の予期せぬ例外が発生すると、肝心な場面で例外処理が「例外的な状況」に対処できなくなる。なので、rescue節のコードもきっちりテストを行い、正常に実行できることを検証しよう。

例外処理をテストしたいが例外を発生させるのが難しい場合は、一時的にコードを書き換えて、わざと例外を発生させる方法もある。その場合はテストが終わったら忘れずにコードをもとに戻しておくこと。

---


## ✍🏻 感想
### 🍒 例外処理の扱い
例外処理においては、微妙な不具合状態をそのままにしてプログラムが動き続けるより、できるだけ早い段階で例外を発生させ、プログラムを緊急停止させるほうが、同じ不具合でも「良い不具合」として扱えるということを学びました。このアプローチによって、エラーの原因が明確になり、対策もしやすくなります......例外処理も奥が深いですね🤔


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 10 min
- Total: 1010 hours 51 min
