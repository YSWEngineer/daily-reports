# 2025/03/28(金)
## 📚 プラクティス『Ruby中級』


## 🧩 タスクばらし
- [x] プラクティスの内容を咀嚼
- [x] タスクばらし、スモールステップの作成
- [x] 各参考ページを確認
- [ ] 参考書籍：[プロを目指す人のためのRuby入門 <改訂2版>](https://www.amazon.co.jp/dp/4297124378/)を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる


## 🐾 スモールステップ
<details><summary>プラクティスの内容を咀嚼</summary>

- [x] プラクティスの内容を咀嚼
</details>

<details><summary>タスクばらし、スモールステップの作成</summary>

- [x] タスクばらし、スモールステップの作成
</details>

<details><summary>各参考ページを確認</summary>

- [x] [学習を加速させるインデックス読書術](https://qiita.com/dkatsura/items/3364b293ed1451a66a8a)を再読
- [x] 動画：[著者自身が語る「プロを目指す人のためのRuby入門」の効果的な読み方](https://www.youtube.com/watch?v=qqqbHXarPO8)
</details>

<details><summary>参考書籍：プロを目指す人のためのRuby入門 <改訂2版>を読んで、実際に手を動かしてツールを使ってみてコードを書いてみる</summary>

- [x] 第1章  本書を読み進める前に
   - [x] 1.1 イントロダクション
   - [x] 1.2 本書の概要
   - [x] 1.3 Ruby について
   - [x] 1.4 Ruby のインストール
   - [x] 1.5 エディタ/IDE について
   - [x] 1.6 Ruby を動かしてみる
   - [x] 1.7 本書のサンプルコードについて
   - [x] 1.8 Ruby の公式リファレンスについて
   - [x] 1.9 この章のまとめ
- [x] 第2章  Ruby の基礎を理解する
   - [x] 2.1 イントロダクション
   - [x] 2.2 Ruby に関する基礎知識
   - [x] 2.3 文字列
   - [x] 2.4 数値
   - [x] 2.5 真偽値と条件分岐
   - [x] 2.6 メソッドの定義
   - [x] 2.7 例題：FizzBuzzプログラムを作成する
   - [x] 2.8 文字列についてもっと詳しく
   - [x] 2.9 数値についてもっと詳しく
   - [x] 2.10 真偽値と条件分岐についてもっと詳しく
   - [x] 2.11 メソッド定義についてもっと詳しく
   - [x] 2.12 そのほかの基礎知識
   - [x] 2.13 この章のまとめ
- [x] 第3章  テストを自動化する
   - [x] 3.1 イントロダクション
   - [x] 3.2 Minitest の基本
   - [x] 3.3 FizzBuzzプログラムのテスト自動化
   - [x] 3.4 この章のまとめ
- [x] 第4章  配列や繰り返し処理を理解する
   - [x] 4.1 イントロダクション
   - [x] 4.2 配列
   - [x] 4.3 ブロック
   - [x] 4.4 ブロックを使う配列のメソッド
   - [x] 4.5 範囲（Range）
   - [x] 4.6 例題：RGB変換プログラムを作成する
   - [x] 4.7 配列についてもっと詳しく
   - [x] 4.8 ブロックについてもっと詳しく
   - [x] 4.9 範囲（Range）についてもっと詳しく
   - [x] 4.10 さまざまな繰り返し処理
   - [x] 4.11 繰り返し処理用の制御構造
   - [x] 4.12 この章のまとめ
- [x] 第5章  ハッシュやシンボルを理解する
   - [x] 5.1 イントロダクション
   - [x] 5.2 ハッシュ
   - [x] 5.3 シンボル
   - [x] 5.4 続・ハッシュについて
   - [x] 5.5 例題：長さの単位交換プログラムを作成する
   - [x] 5.6 ハッシュとキーワード引数についてもっと詳しく
   - [x] 5.7 シンボルについてもっと詳しく
   - [x] 5.8 この章のまとめ
- [x] 第6章  正規表現を理解する
   - [x] 6.1 イントロダクション
   - [x] 6.2 正規表現って何？
   - [x] 6.3 Ruby における正規表現オブジェクト
   - [x] 6.4 例題：Ruby のハッシュ記法を変換する
   - [x] 6.5 正規表現オブジェクトについてもっと詳しく
   - [x] 6.6 この章のまとめ
- [x] 第7章  クラスの作成を理解する
   - [x] 7.1 イントロダクション
   - [x] 7.2 オブジェクト指向プログラミングの基礎知識
   - [x] 7.3 クラスの定義
   - [x] 7.4 例題：改札機プログラムの作成
   - [x] 7.5 selfキーワード
   - [x] 7.6 クラスの継承
   - [x] 7.7 メソッドの可視性
   - [x] 7.8 定数についてもっと詳しく
   - [x] 7.9 さまざまな種類の変数
   - [x] 7.10 クラス定義や Ruby の言語使用に関する高度な話題
   - [x] 7.11 この章のまとめ
- [x] 第8章  モジュールを理解する
   - [x] 8.1 イントロダクション
   - [x] 8.2 モジュールの概要
   - [x] 8.3 モジュールを利用したメソッド定義（include と extend）
   - [x] 8.4 例題：rainbowメソッドの作成
   - [x] 8.5 モジュールを利用したメソッド定義についてもっと詳しく
   - [x] 8.6 モジュールを利用した名前空間の作成
   - [x] 8.7 関数や定数を提供するモジュールの作成
   - [x] 8.8 状態を保持するモジュールの作成
   - [x] 8.9 モジュールに関する高度な話題
   - [x] 8.10 この章のまとめ
- [ ] 第9章  例外処理を理解する
   - [x] 9.1 イントロダクション
   - [x] 9.2 例外の捕捉
   - [x] 9.3 意図的に例外を発生させる
   - [x] 9.4 例外処理のベストプラクティス
   - [x] 9.5 例題：正規表現チェッカープログラムの作成
   - [ ] 9.6 例外処理についてもっと詳しく
   - [ ] 9.7 この章のまとめ
- [ ] 第10章  yield と Proc を理解する
   - [ ] 10.1 イントロダクション
   - [ ] 10.2 ブロックを利用するメソッドの定義と yield
   - [ ] 10.3 Procオブジェクト
   - [ ] 10.4 例題：ワードシンセサイザーの作成
   - [ ] 10.5 Procオブジェクトについてもっと詳しく
   - [ ] 10.6 この章のまとめ
- [ ] 第11章  パターンマッチを理解する
   - [ ] 11.1 イントロダクション
   - [ ] 11.2 パターンマッチの基本
   - [ ] 11.3 パターンマッチの利用パターン
   - [ ] 11.4 例題：ログフォーマッターの作成
   - [ ] 11.5 パターンマッチについてもっと詳しく
   - [ ] 11.6 この章のまとめ
- [ ] 第12章  Ruby のデバッグ技法を身につける
   - [ ] 12.1 イントロダクション
   - [ ] 12.2 バックトレースの読み方
   - [ ] 12.3 よく発生する例外クラスとその原因
   - [ ] 12.4 プログラムの途中経過を確認する
   - [ ] 12.5 汎用的なトラブルシューティング方法
   - [ ] 12.6 この章のまとめ
- [ ] 第13章  Ruby に関するその他のトピック
   - [ ] 13.1 イントロダクション
   - [ ] 13.2 日付や時刻の扱い
   - [ ] 13.3 ファイルやディレクトリの扱い
   - [ ] 13.4 特定の形式のファイルを読み書きする
   - [ ] 13.5 環境変数や起動時引数の取得
   - [ ] 13.6 非推奨機能を使ったときに警告を出力する
   - [ ] 13.7 eval、バッククオートリテラル、sendメソッド
   - [ ] 13.8 Rake
   - [ ] 13.9 gem と Bundler
   - [ ] 13.10 Ruby における型情報の定義と型検査（RBS、TypeProf、Steep）
   - [ ] 13.11 「Rails の中の Ruby」と「素の Ruby」の違い
   - [ ] 13.12 この章のまとめ

</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第9章  例外処理を理解する
    - 9.6 例外処理についてもっと詳しく
      - 例外処理の begin / end を省略できるケース
      - rescue した例外を再度発生させる
      - 独自の例外クラスを定義する   

---


## 🎯 次回
### プラクティス『Ruby中級』
- 参考書籍：『プロを目指す人のためのRuby入門 <改訂2版>』を読み進める
  - 第10章  yield と Proc を理解する
    - 10.1 イントロダクション
      - この章の例題：ワードシンセサイザー 〜
    

---


## 💡 本日の学び・気付き
### 9.6 例外処理についてもっと詳しく
#### 例外処理の begin / end を省略できるケース
メソッドの中身全体が例外処理で囲まれている場合は beginキーワードと endキーワードを省略することができる。たとえば、メソッドの最初から最後までが例外処理の対象になっているメソッドがあったとする。
```ruby
irb(main):001* def fizz_buzz(n)'
irb(main):002*   begin
irb(main):003*     if n % 15 == 0
irb(main):004*       'Fizz Buzz'
irb(main):005*     elsif n % 3 == 0
irb(main):006*       'Fizz'
irb(main):007*     elsif n % 5 == 0
irb(main):008*       'Buzz'
irb(main):009*     else
irb(main):010*       n.to_s
irb(main):011*     end
irb(main):012*   rescue => e
irb(main):013*     puts "#{e.class} #{e.message}"
irb(main):014*   end
irb(main):015> end

irb(main):016> fizz_buzz(nil)
NoMethodError undefined method `%' for nil
```
こういうケースでは例外処理の begin と end を省略して次のように書くことができる。
```ruby
irb(main):017* def fizz_buzz(n)
irb(main):018*   if n % 15 == 0
irb(main):019*     'Fizz Buzz'
irb(main):020*   elsif n % 3 == 0
irb(main):021*     'Fizz'
irb(main):022*   elsif n % 5 == 0
irb(main):023*     'Buzz'
irb(main):024*   else
irb(main):025*     n.to_s
irb(main):026*   end
irb(main):027* rescue => e
irb(main):028*   puts "#{e.class} #{e.message}"
irb(main):029> end

irb(main):030> fizz_buzz(nil)
NoMethodError undefined method `%' for nil
```
また、begin と end の省略は do/endブロックの内部でも有効。つまり、do/endブロックの全体が例外処理で囲まれている場合は例外処理の begin と end を省略できる。「rescueしたら情報を残す」の項のサンプルコードは次のように書き直せる。
```ruby
# 元のコード（begin/endを省略しない）
users.each do |user|
  begin
    send_mail_to(user)
  rescue => e
    puts e.full_message
  end
end

# begin/endを省略したコード
users.each do |user|
  send_mail_to(user)
rescue => e
  puts e.full_message
end
```
ただし、同じブロックでも`{ }`を使った場合は begin と end を省略できないので注意すること。
```ruby
# ブロックを{}で書いた場合は例外処理のbeginとendを省略できない（構文エラーになる）
irb(main):001* users.each { |user|
irb(main):002*   send_mail_to(user)
irb(main):003* rescue => e
irb(main):004*   puts e.full_message
irb(main):005> }
syntax error, unexpected `rescue', expecting '}' (SyntaxError)

# この場合は begin と end を省略せずに書く必要がある
users.each { |user|
  begin
    send_mail_to(user)
  rescue => e
    puts e.full_message
  end
}
```

#### rescue した例外を再度発生させる
rescue節の中で raiseメソッドを使うこともできる。このとき、raiseメソッドの引数を省略すると、rescue節で捕捉した例外をもう一度発生させることができる。たとえば、例外が発生したらプログラム自体は異常終了させるものの、その情報はログに残したりメールで送信したりしたい、というときにこのテクニックが使える。
```ruby
irb(main):001* def fizz_buzz(n)
irb(main):002*   if n % 15 == 0
irb(main):003*     'Fizz Buzz'
irb(main):004*   elsif n % 3 == 0
irb(main):005*     'Fizz'
irb(main):006*   elsif n % 5 == 0
irb(main):007*     'Buzz'
irb(main):008*   else
irb(main):009*     n.to_s
irb(main):010*   end
irb(main):011* rescue => e
# 発生した例外をログやメールに残す（ここはputsで代用）
irb(main):012*   puts "[LOG] エラーが発生しました: #{e.class} #{e.message}"
# 捕捉した例外を再度発生させ、プログラム自体は異常終了させる
irb(main):013*   raise
irb(main):014> end

irb(main):015> fizz_buzz(nil)
[LOG] エラーが発生しました: NoMethodError undefined method `%' for nil
(irb):2:in `fizz_buzz': undefined method `%' for nil (NoMethodError)
```

#### 独自の例外クラスを定義する
例外クラスは独自に定義することも可能。例外クラスを定義する場合は特別な理由がない限り、StandardErrorクラスか、そのサブクラスを継承する。以下は独自の例外クラスを定義し、実際にそれを発生させるコード例。
```ruby
irb(main):001* class NoCountryError < StandardError
# 独自のクラス名を与えるのが目的なので、実装コードは特に書かない（継承だけで済ませる）
irb(main):002> end
=> nil

irb(main):003* def currency_of(country)
irb(main):004*   case country
irb(main):005*   when :japan
irb(main):006*     'yen'
irb(main):007*   when :us
irb(main):008*     'dollar'
irb(main):009*   when :india
irb(main):010*     'rupee'
irb(main):011*   else
# 独自に定義したNoCountryErrorを発生させる
irb(main):012*     raise NoCountryError, "無効な国名です。#{country}"
irb(main):013*   end
irb(main):014> end

irb(main):015> currency_of(:italy)
(irb):12:in `currency_of': 無効な国名です。italy (NoCountryError)
```
必要であれば独自のメソッドや独自の属性を追加することも可能。
```ruby
irb(main):001* class NoCountryError < StandardError
# 国名を属性として取得できるようにする
irb(main):002*   attr_reader :country

irb(main):003*   def initialize(message, country)
irb(main):004*     @country = country
irb(main):005*     super("#{message} #{country}")
irb(main):006*   end
irb(main):007> end
=> :initialize

irb(main):008* def currency_of(country)
irb(main):009*   case country
irb(main):010*   when :japan
irb(main):011*     'yen'
irb(main):012*   when :us
irb(main):013*     'dollar'
irb(main):014*   when :india
irb(main):015*     'rupee'
irb(main):016*   else
# NoCountryErrorを発生させる
irb(main):017*     raise NoCountryError.new('無効な国名です。', country)
irb(main):018*   end
irb(main):019> end
=> :currency_of

irb(main):020* begin
irb(main):021*   currency_of(:italy)
irb(main):022* rescue NoCountryError => e
# エラーメッセージと国名を出力する
irb(main):023*   puts e.message
irb(main):024*   puts e.country
irb(main):025> end
無効な国名です。 italy
italy
```



---


## ✍🏻 感想
### 🍒 例外処理の重要性と注意点
そもそも例外処理は、予期しないエラー発生時にプログラムの動作を制御するための機能です。しかし、`rescue`をむやみに使用してしまうと、潜在的な問題を見逃し、後々大きなトラブルに発展する可能性があります。例外処理は、**適切な使い方と注意**が必要であることを学びました。

次回から`yield`と`Proc`についてインプットします。今はまだ何のことだか全体像は掴めていませんが、楽しみです😊✨


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 hours 01 min
- Total: 1022 hours 09 min
