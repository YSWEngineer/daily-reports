# 2025/11/13(木)
## 📚 プラクティス『lsコマンドを作る1』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>

<details><summary>📌 要件（Docs：lsコマンドを作る 参照）</summary>

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと
</details>

<details><summary>📑 全体の設計 （⚠️ ネタバレに注意）</summary>

### 1. ファイルの取得（ソート含む）
- 入力：検索パターン
- 処理：`Dir.glob`で指定パターンに合うファイルやディレクトリを取得し、並び替え
- 出力：ファイル・ディレクトリ一覧（配列でまとめたもの）

### 2. 行数の計算
- 入力：ファイル（要素）を配列でまとめたものと列数
- 処理：`行数 = (要素の数 ÷ 列数).ceil`で余りを切り上げる
- 出力：行数（Integer = 整数）

### 3. 要素一つ一つを縦に配置
- 入力：ファイル（要素）を配列でまとめたもの、行数・列数
- 処理：①行ごとの配列を作る　②各列に要素を縦に配置　③インデックス計算：`index = row + column * rows`
- 出力：縦詰めに並んだ配列

### 4. 配置を整える
- 入力：縦詰めに並んだ要素
- 処理：タブ文字（`join("\t")`）を使用して見やすく整える
- 出力：整えられた文字列
</details>

<details><summary> 🧩 タスクばらし ※ 随時、追加・変更あり</summary>

- [x] タスク1：開発の準備（テストフォルダ）
  - [x] ToDo：作業用フォルダを用意し、その中にダミーファイルをいくつか置く
  - [x] 作業時間： 30分
  - [x] 終了条件：テストフォルダにファイルがある

- [x] タスク2：全体設計
  - [x] ToDo：「主要な処理」を列挙する
  - [x] 作業時間：60分
  - [x] 終了条件：主要な処理（要件）を一つずつ列挙すること

- [x] タスク3：ファイルの取得とソート（並び替え）
  - [x] ToDo：`.`や`..`から始まるファイルや隠しファイルは出力させないようにする
  - [x] 作業時間：60分
  - [x] 終了条件：期待している並び順になっていること

- [x] タスク4：行数・列数のロジックを考える（余りの切り上げを用いる）
  - [x] ToDo：先ずは列数を3列に決め、行数が切り上げになること
  - [x] 作業時間：60分
  - [x] 終了条件：列数や要素の数を変更しても期待どおりになっていること

- [x] タスク5：縦詰めにロジックをメソッド化
  - [x] ToDo：縦詰めに変換するメソッドを実装し、期待どおりなっていること
  - [x] 作業時間：90分
  - [x] 終了条件：縦詰めの出力が期待どおりであること

- [x] タスク6：列幅を揃える
  - [x] ToDo：タブ文字を用いて文字列同志の幅を整える
  - [x] 作業時間：90分
  - [x] 終了条件：実際に見て読みやすくなっていること

- [ ] タスク7：2つ以上のメソッドを自分で定義する
  - [ ] ToDo：「何をやるか」に名前を付けて、後で呼び出せるようにする
  - [ ] 作業時間：240分
  - [ ] 終了条件：メソッドを2つ定義すること

- [ ] タスク8：rubocop-fjord に通す
  - [ ] ToDo：rubocop-fjord 通して出力されたエラーを一つずつ直していく
  - [ ] 作業時間：数時間？エラーの内容によりけり
  - [ ] 終了条件：rubocop-fjord の警告・エラーが発生していないこと

- [ ] タスク9：提出
  - [ ] ToDo：作成した lsコマンドを Pull Request として提出
  - [ ] ToDo：提出物にlsコマンドの実行結果とOS標準（macなど自分の使ってるOS）のlsコマンドをのスクリーンショットを併記して貼る
  - [ ] ToDo：rubocop-fjord のチェックが全てパスした画面をスクショして添付
  - [ ] 作業時間：60分
  - [ ] 終了条件：メンターさんに課題を提出すること
</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『lsコマンドを作る1』🛠️💻
- 動作を変えずにコードを綺麗にする


---


## ⏭️ 次回
### プラクティス『lsコマンドを作る1』🛠️💻
- 引き続き、自分のコードを読みながら、メソッド化できそうな部分を探す


---


## 💡 本日の学び・気付き
自分の書いたコードが少し読みづらいと感じていたため、**動作を変えずに整える作業**を行いました。出力結果にも問題はなく、コード全体の見通しがかなり良くなりました（私感）。
以下は、書き換えたコードとその言語化です（思いのほか時間がかかりました......🫠）。
<details><summary> ⚠️ ネタバレに注意</summary>

### 読みやすさを意識して書き直したコード

```ruby
files = Dir.glob('*').sort         # カレントディレクトリのファイルを名前順に取得
columns = 3                        # 列の数を指定
rows = (files.size.to_f / columns).ceil  # 行数を求める（端数が出たら切り上げ）

max_length = files.map(&:length).max + 1 # ファイル名の最大文字数＋スペース分

rows.times do |row|
  line = ""  # この行に出力する文字列を入れる

  columns.times do |column|
    index = row + column * rows   # ファイル名の位置を計算
    name = files[index] || ""     # 該当ファイルがない場合は空文字
    line += name.ljust(max_length) # 左寄せで整形して追加
  end

  puts line  # 1行分を出力
end
```

`files = Dir.glob('*').sort`
- カレントディレクトリの中にある全てのファイルとディレクトリの名前を配列で取り出し、それをアルファベット順に並び替えて変数`files`に代入。

`columns = 3`
- 「何列で並べるか」を決める数を変数`columns`に入れる。ここでは 3列表示にするという指定。

`rows = (files.size.to_f / columns).ceil`
- ファイルの総数を列数で割り、何行に分ける必要があるかを計算。割り算の結果を小数点で扱い、切り上げ（`ceil`）している。

`max_length = files.map(&:length).max + 1`
- ファイル名の最大の長さ（文字数）を求め、その値に`1`を足したものを変数`max_length`に代入。`+ 1`にしたのは、最長のファイル名ギリギリだと隣の列にくっつき見にくくなるので1文字分の余白を確保する目的。
- `files.map(&:length)`：各ファイル名の文字数の配列を作成（例：`[6, 3, 10, 2]`）。
- `.max`：その中の最大値（例：`10`）
- `+ 1`：見やすさのために余白を追加（例：`11`）

`rows.times do |row|`
- 行（`rows`）ごとに表示を作っていく外側のループ。

`line = ""`
- この行では、「その行に表示する文字列」を入れるための空の文字列（箱）を用意。ここに列ごとのテキストを順に足していく。
- 初めは`line = []`で配列に集めてから`join`することを考えたが、`line += ...`（文字列の連結）のほうが誰でも直感的に読みやすいと考えた（`join`のほうがスマートに見えるかもしれないが）。

`columns.times do |column|`
- 一行の中の列（ここでは3回）を順に処理。パイプの中の`column`は列番号（0, 1, 2）。

`index = row + column * rows`
- 「今、この行・この列で表示するファイルは`files`の何番目なのか」を計算。
- `column * rows`：その列の「先頭の位置（配列の何番目から始まるのか）」。
- `row`：その列の中で何番目の行なのか。
  - 仮に`rows = 3`, `columns = 3`のとき、`row`と`column`による`index`は、
    - `row = 0`, `column = 0` → `index = 0 + 0 * 3 = 0`
    - `row = 0`, `column = 1` → `index = 0 + 1 * 3 = 3`
    - `row = 0`, `column = 2` → `index = 0 + 2 * 3 = 6`
    - つまり、一行目は`files[0]`, `files[3]`, `files[6]`を表示する、という意味（縦に詰めて並べる配置）になる。

`name = files[index] || ""`
- `files[index]`が存在すればその値（ファイル名）を変数`name`に代入し、存在しなければ空文字`""`を代入。

`line += name.ljust(max_length)`
- 変数`name`（ファイル名、または空文字）を左寄せ（`ljust`）で`max_length`文字分に整形し、その文字列を`line`に追加（連結）。
- `ljust`は、たとえば`"abc".ljust(10)`なら`"abc    "`となり、右側をスペースで埋めて長さを 10 にする。ここでは列幅を揃えるために使用。
- 列ごとに幅を揃えないと、隣の列とくっついて見にくくなる。ローカル変数`max_length`（ファイル名の最長文字数を入れた変数）を使用することで、どの行でも列幅は一定になる。

`puts line`
- `line`（文字列）を画面に表示。

### 全体を通した「流れのイメージ」まとめ
1. ファイル一覧を取り / 何列で表示するかを決め / 何行必要かを計算する。
2. 各ファイル名の最長文字数を見つけて列幅（余白含む）を決める。
3. 行ごとに / ループして、列ごとにどのファイルを表示するかを計算し / 存在しなければ空文字で埋め / 左寄せで幅を揃えて連結。
4. その行を出力。これを全ての行で繰り返す。

### 出力結果
```shell
~/test_file % ruby ls.rb
1.txt             4.txt             README.md         
10.txt            5.txt             babel.config.js   
11.txt            6.txt             bin               
12.txt            7.txt             config            
13.txt            8.txt             config.ru         
14.txt            9.txt             log               
15.txt            Gemfile           ls.rb             
2.txt             Gemfile.lock      package.json      
3.txt             Procfile          postcss.config.js
```
</details>


---


## ✍🏻 感想
以前から「このコード、もっとシュッとできないかな」と思いつつも、メソッド化に集中していたため気に留めていませんでした。しかし、一行ずつ言語化していくうちに「あれ、やっぱりこのコード読みにくい」と感じ、読みにくさがメソッド化を難しくしている要因の１つでは？と気付きました。

そこで、書籍『ゼロからわかる超入門』『たのしいRuby』『プロを目指す人のためのRuby入門』を参考に、コードを綺麗に整える作業（**※リファクタリングではありません**）を行いました。エラーはなく出力も問題はなさそう。行数は少なくなり、全体的に読みやすくなったと思います。

これで多分、メソッド化の作業もサクサク進むはず......だよね、ハム太郎🐹


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 hours 09 min
- Total: 1402 hours 53 min
