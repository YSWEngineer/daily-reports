# 2025/11/15(土)
## 📚 プラクティス『lsコマンドを作る1』

<details><summary>🎯 学習の狙い</summary>

- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
</details>

<details><summary>📌 要件（Docs：lsコマンドを作る 参照）</summary>

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと
</details>

<details><summary>📑 全体の設計 （⚠️ ネタバレに注意）</summary>

### 1. ファイルの取得（ソート含む）
- 入力：検索パターン
- 処理：`Dir.glob`で指定パターンに合うファイルやディレクトリを取得し、並び替え
- 出力：ファイル・ディレクトリ一覧（配列でまとめたもの）

### 2. 行数の計算
- 入力：ファイル（要素）を配列でまとめたものと列数
- 処理：`行数 = (要素の数 ÷ 列数).ceil`で余りを切り上げる
- 出力：行数（Integer = 整数）

### 3. 要素一つ一つを縦に配置
- 入力：ファイル（要素）を配列でまとめたもの、行数・列数
- 処理：①行ごとの配列を作る　②各列に要素を縦に配置　③インデックス計算：`index = row + column * rows`
- 出力：縦詰めに並んだ配列

### 4. 配置を整える
- 入力：縦詰めに並んだ要素
- 処理：タブ文字（`join("\t")`）を使用して見やすく整える
- 出力：整えられた文字列
</details>

<details><summary> 🧩 タスクばらし ※ 随時、追加・変更あり</summary>

- [x] タスク1：開発の準備（テストフォルダ）
  - [x] ToDo：作業用フォルダを用意し、その中にダミーファイルをいくつか置く
  - [x] 作業時間： 30分
  - [x] 終了条件：テストフォルダにファイルがある

- [x] タスク2：全体設計
  - [x] ToDo：「主要な処理」を列挙する
  - [x] 作業時間：60分
  - [x] 終了条件：主要な処理（要件）を一つずつ列挙すること

- [x] タスク3：ファイルの取得とソート（並び替え）
  - [x] ToDo：`.`や`..`から始まるファイルや隠しファイルは出力させないようにする
  - [x] 作業時間：60分
  - [x] 終了条件：期待している並び順になっていること

- [x] タスク4：行数・列数のロジックを考える（余りの切り上げを用いる）
  - [x] ToDo：先ずは列数を3列に決め、行数が切り上げになること
  - [x] 作業時間：60分
  - [x] 終了条件：列数や要素の数を変更しても期待どおりになっていること

- [x] タスク5：縦詰めにロジックをメソッド化
  - [x] ToDo：縦詰めに変換するメソッドを実装し、期待どおりなっていること
  - [x] 作業時間：90分
  - [x] 終了条件：縦詰めの出力が期待どおりであること

- [x] タスク6：列幅を揃える
  - [x] ToDo：タブ文字を用いて文字列同志の幅を整える
  - [x] 作業時間：90分
  - [x] 終了条件：実際に見て読みやすくなっていること

- [ ] タスク7：2つ以上のメソッドを自分で定義する
  - [ ] ToDo：「何をやるか」に名前を付けて、後で呼び出せるようにする
  - [ ] 作業時間：240分
  - [ ] 終了条件：メソッドを2つ定義すること

- [ ] タスク8：rubocop-fjord に通す
  - [ ] ToDo：rubocop-fjord 通して出力されたエラーを一つずつ直していく
  - [ ] 作業時間：数時間？エラーの内容によりけり
  - [ ] 終了条件：rubocop-fjord の警告・エラーが発生していないこと

- [ ] タスク9：提出
  - [ ] ToDo：作成した lsコマンドを Pull Request として提出
  - [ ] ToDo：提出物にlsコマンドの実行結果とOS標準（macなど自分の使ってるOS）のlsコマンドをのスクリーンショットを併記して貼る
  - [ ] ToDo：rubocop-fjord のチェックが全てパスした画面をスクショして添付
  - [ ] 作業時間：60分
  - [ ] 終了条件：メンターさんに課題を提出すること
</details>


---


## 🧑🏻‍💻 本日の取り組み
### プラクティス『lsコマンドを作る1』🛠️💻
- 引き続き、自分のコードを読みながら、メソッド化できそうな部分を探す


---


## ⏭️ 次回
### プラクティス『lsコマンドを作る1』🛠️💻
- メソッド化の作業に入る


---


## 💡 本日の学び・気付き
### メソッド候補
今回の lsコマンドプログラムでは、**役割ごとのまとまり**に注視して、メソッド化できそうな箇所を 4つ挙げて、その中から 2つをメソッド化しようと判断。

<details><summary> ⚠️ ネタバレに注意</summary>

```ruby
files = Dir.glob('*').sort         
columns = 3                        
rows = (files.size.to_f / columns).ceil  

max_length = files.map(&:length).max + 1 

rows.times do |row|
  line = ""  

  columns.times do |column|
    index = row + column * rows   
    name = files[index] || ""     
    line += name.ljust(max_length) 
  end

  puts line  
end
```
#### 候補①
`files = Dir.glob('*').sort`（ファイル一覧の取得）
#### 候補②
`rows = (files.size.to_f / columns).ceil`（行数の計算）
#### 候補③
`max_length = files.map(&:length).max + 1`（表示幅の計算）
#### 候補④
`rows.times do |row| 〜 end`（行を組み立てて出力するループ）

### 候補①と②はメソッド化しないと判断
#### 候補① ファイル一覧の取得
`files = Dir.glob('*').sort`
- 一行で完結していて、処理が単純。
- ここでしか使用しない。
- 命名してメソッド化してもメリットがない。

たとえば、
```ruby
def get_files
  Dir.glob('*').sort
end
```
と書いたところで、コードの分かりやすさはあまり変わらないように感じる。
1回しか使用しないため、**DRY** にも貢献しない。
→ 上記にも書いたが、メソッド化するメリットが小さい。

#### 候補② 行数の計算
`rows = (files.size.to_f / columns).ceil`
- これも一箇所でしか使用しない。
- 一行で意味が明確になっている（行数を決めている）。
- メソッド化すると却って読みにくくなる可能性が......。
- メソッド化してもメリットを感じられない。

#### 補足：DRY原則とは？
> **D**on't **R**epeat **Y**ourself（繰り返すな）

というプログラミングの大事な考え方。
簡単に言うと、
- 同じ意味のコードを何度も書かないようにしよう。
- 繰り返しがあると、修正点が増えたりバグが起きやすくなる。

たとえば、
```ruby
puts user.name
puts user.name
puts user.name
```
↑こういうのをまとめて
```ruby
def print_name
  puts user.name
end
```
このような書き方にしておくと、後で修正したくなったときに**一箇所直すだけでOK**になる。

#### 今回のメソッド化判断で DRY が関係した部分
- **① ファイル取得**
→ 1回しか呼ばれない。
→ 繰り返しがないので、メソッド化しても DRY に貢献しない。
- **② 行数の計算**
→ これも 1回しか呼ばれない。
→ DRY のメリットがない（繰り返しなし）。
- **結論**
→ **DRYの観点でも①、②はメソッド化の必要はないと結論づけた。**

### 候補③と④はメソッド化する方向で検討
#### 候補③ 表示幅の計算
`max_length = files.map(&:length).max + 1`
- 「ファイル名の最大文字数の取得 + 余白の追加」という一つのまとまりになっている。
- 処理の役割が説明しやすい。

#### 候補④ 行を組み立てて出力するループ
`rows.times do |row| 〜 end`
- このコードは他の箇所に比べて長く、その分役割のまとまりが大きいため、このまとまりをメソッド化することでより読みやすくなるのでは？と考えた。
</details>


---


## ✍🏻 感想
メソッド化の候補を絞り込むことができました。
コードを読みやすく整えたことで、「どこが一つの役割としてまとまっているか」が以前よりも把握しやすくなり、その結果、メソッド化の優先度も判断しやすくなりました。

次回からはいよいよメソッド化の作業に入ります（判断が合っているか少し不安ですが🤔）。一つずつ整理して進めていきます。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 hours 40 min
- Total: 1404 hours 33 min
