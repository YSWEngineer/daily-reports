# 2025/10/12(日)
## 📚 プラクティス『lsコマンドを作る1』

:::details 🎯 学習の狙い
- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
:::

:::details 📌 要件（Docs：lsコマンドを作る 参照）
- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと
:::

:::details 📑 全体の設計 （⚠️ ネタバレに注意）
#### 1. ファイルの取得（ソート含む）
- 入力：検索パターン
- 処理：`Dir.glob`で指定パターンに合うファイルやディレクトリを取得し、並び替え
- 出力：ファイル・ディレクトリ一覧（配列でまとめたもの）

#### 2. 行数の計算
- 入力：ファイル（要素）を配列でまとめたものと列数
- 処理：`行数 = (要素の数 ÷ 列数).ceil`で余りを切り上げる
- 出力：行数（Integer = 整数）

#### 3. 要素一つ一つを縦に配置
- 入力：ファイル（要素）を配列でまとめたもの、行数・列数
- 処理：①行ごとの配列を作る　②各列に要素を縦に配置　③インデックス計算：`index = row + column * rows`
- 出力：縦詰めに並んだ配列

#### 4. 配置を整える
- 入力：縦詰めに並んだ要素
- 処理：タブ文字（`join("\t")`）を使用して見やすく整える
- 出力：整えられた文字列
:::

:::details 🧩 タスクばらし ※ 随時、追加・変更あり
- [x] タスク1：開発の準備（テストフォルダ）
  - [x] ToDo：作業用フォルダを用意し、その中にダミーファイルをいくつか置く
  - [x] 作業時間： 30分
  - [x] 終了条件：テストフォルダにファイルがある

- [x] タスク2：全体設計
  - [x] ToDo：「主要な処理」を列挙する
  - [x] 作業時間：60分
  - [x] 終了条件：主要な処理（要件）を一つずつ列挙すること

- [x] タスク3：ファイルの取得とソート（並び替え）
  - [x] ToDo：`.`や`..`から始まるファイルや隠しファイルは出力させないようにする
  - [x] 作業時間：60分
  - [x] 終了条件：期待している並び順になっていること

- [x] タスク4：行数・列数のロジックを考える（余りの切り上げを用いる）
  - [x] ToDo：先ずは列数を3列に決め、行数が切り上げになること
  - [x] 作業時間：60分
  - [x] 終了条件：列数や要素の数を変更しても期待どおりになっていること

- [x] タスク5：縦詰めにロジックをメソッド化
  - [x] ToDo：縦詰めに変換するメソッドを実装し、期待どおりなっていること
  - [x] 作業時間：90分
  - [x] 終了条件：縦詰めの出力が期待どおりであること

- [x] タスク6：列幅を揃える
  - [x] ToDo：タブ文字を用いて文字列同志の幅を整える
  - [x] 作業時間：90分
  - [x] 終了条件：実際に見て読みやすくなっていること

- [ ] ✨New タスク7：2つ以上のメソッドを自分で定義する
  - [ ] ToDo：「何をやるか」に名前を付けて、後で呼び出せるようにする
  - [ ] 作業時間：240分
  - [ ] 終了条件：mainメソッドともう一つのメソッド2つを定義すること

- [ ] タスク8：rubocop-fjord に通す
  - [ ] ToDo：rubocop-fjord 通して出力されたエラーを一つずつ直していく
  - [ ] 作業時間：数時間？エラーの内容によりけり
  - [ ] 終了条件：rubocop-fjord の警告・エラーが発生していないこと

- [ ] タスク9：提出
  - [ ] ToDo：作成した lsコマンドを Pull Request として提出
  - [ ] ToDo：提出物にlsコマンドの実行結果とOS標準（macなど自分の使ってるOS）のlsコマンドをのスクリーンショットを併記して貼る
  - [ ] ToDo：rubocop-fjord のチェックが全てパスした画面をスクショして添付
  - [ ] 作業時間：60分
  - [ ] 終了条件：メンターさんに課題を提出すること
:::

:::details 🔰 基礎をおさらい
- [ ] 書籍『ゼロからわかる Ruby超入門』
  - [x] 7 - 1 メソッドを作って呼び出す
  - [x] 7 - 2 メソッドへオブジェクトを渡す
  - [x] 7 - 3 引数の便利な機能を使う
  - [x] 7 - 4 変数には見える範囲がある
  - [x] 練習問題 CHAPTER 2
  - [x] 練習問題 CHAPTER 3
  - [x] 練習問題 CHAPTER 4
  - [x] 練習問題 CHAPTER 5
  - [x] 練習問題 CHAPTER 6
  - [x] 練習問題 CHAPTER 7
  - [ ] 練習問題 CHAPTER 8
  - [ ] 練習問題 CHAPTER 9
  - [ ] 練習問題 CHAPTER 10
:::


---


### 🧑🏻‍💻 本日の取り組み
#### 📕 書籍『ゼロからわかる Ruby超入門』『プロを目指す人のためのRuby入門』
- Rubyの基本構造
- クラス

#### 📕 書籍『ゼロからわかる Ruby超入門』
- CHAPTER 8  - 部品をつくる - クラス
- 練習問題 CHAPTER 8


---


### ⏭️ 次回
#### 📕 書籍『ゼロからわかる Ruby超入門』
- CHAPTER 8  - 部品をつくる - クラス
- 練習問題 CHAPTER 8


---


### 💡 本日の学び・気付き
#### Rubyの基本構造
##### すべてはオブジェクト
Ruby では、「**すべてがオブジェクト**」。
たとえば：
```ruby
1.class
#=> Integer

"hello".class
#=> String

[1, 2, 3].class
#=> Array
```
数字も文字列も配列も、すべて「クラスの実体（インスタンス）」 = **オブジェクト**である。
そして、それぞれのクラス（`Integer`、`String`、`Array`など）には、たくさんの**メソッド**が定義されている。

##### オブジェクトがメソッドを使う
「オブジェクトのクラスがメソッドを定義していて、オブジェクトはそれを使うことができる」という仕組みがある。
たとえば：
```ruby
"ruby".upcase
```
この`"ruby"`は`String`クラスのインスタンス（オブジェクト）。
`String`クラスには`upcase`等メソッドが定義されているので、このオブジェクトはそのメソッドを**使う**（呼び出す）ことができる。

##### オブジェクト・クラス・メソッドの関係
図：
```shell
オブジェクト      →   クラス            →   メソッド定義
"hello"          →   Stringクラス       →   upcase, downcase, length など
123              →   Integerクラス      →   to_s, next, odd? など
[1, 2, 3]        →   Arrayクラス        →   push, pop, each など
```

| 用語           | 意味                                              |
| ------------ | ----------------------------------------------- |
| **オブジェクト**   | 実際に使う「もの」（例: `"hello"`, `123`, `[1, 2, 3]`）      |
| **クラス**      | オブジェクトの「設計図」（例: `String`, `Integer`, `Array`）   |
| **メソッド**     | クラスに定義された「できること」（例: `upcase`, `length`, `next`） |
| **`.`（ドット）** | 「オブジェクトのメソッドを呼び出す」ための記号                         |

#### Rubyのクラスと継承
##### Rubyのクラスの継承構造（簡略図）
```
BasicObject
   ↑
Object
   ↑
String, Numeric, Array, Hash
```
`BasicObject`：継承関係の頂点にいるクラス。
`Object`：`BasicObject`クラスを継承していて、一般的なメソッドが定義されている。そして、継承元を指定せずに作成したクラスはデフォルトでこの`Object`クラスを継承している。
 `String, Numeric, Array, Hash`：`Object`クラスの子クラスであり、「クラスそのものを表すオブジェクト」。たとえば、`String`も`Numeric`も`Array`も`Hash`も**Classのインスタンス**。
```ruby
p Hash.class
#=> Class
```
つまり、「**クラスもまたオブジェクト**」である。

#### Numericとは何のためのクラス？
`Numeric`は「数値を扱うクラスの親クラス（スーパークラス）」。
Ruby では以下のようなクラスの階層がある。
```
Numeric（数値）
 ├── Integer（整数）
 ├── Float（実数、小数）
 ├── Rational（有理数）
 └── Complex（複素数）
```
##### たとえば、「1」はどうなっているか？
```ruby
p 1.class
#=> Integer
```
`1`は`Integer`クラスのインスタンス。そして、`Integer`クラスは`Numeric`クラスを継承している。
```ruby
p Integer.superclass
#=> Numeric
```
さらに、その上には`Object`がある。
```ruby
p Numeric.superclass
#=> Object
```
まとめると階層構造はこうなる：
```
BasicObject
  ↑
Object
  ↑
Numeric
  ↑
Integer
  ↑
1（インスタンス）
```
そして、「クラス」の方も見てみると......
```ruby
p Integer.class
#=> Class
p Numeric.class
#=> Class
p Class.class
#=> Class（自分自身もClassのインスタンス！）
```
`Class`クラス自身も`Class`のインスタンスであることがわかる。
| オブジェクト    | クラス       | クラスのクラス |
| --------- | --------- | ------- |
| `1`       | `Integer` | `Class` |
| `3.14`    | `Float`   | `Class` |
| `Integer` | `Class`   | `Class` |
| `Numeric` | `Class`   | `Class` |

#### 📕 書籍『ゼロからわかる Ruby超入門』
##### クラスに定義したメソッドを呼び出す
- メソッドの呼び出し
```ruby
オブジェクト.メソッド
```
- クラスに定義したメソッドは、そのクラスに属する全てのオブジェクトで呼び出すことができる。
- クラスにメソッドを定義しておけば、そのクラスからオブジェクトを作って、そのオブジェクトたち全員でそのメソッドを呼ぶことができる。


---


### ✍🏻 感想
#### 📚 効率よく学びたい
思っていた以上に理解に時間がかかり、学習時間のわりにはあまり進めていません。
焦らずに、少しずつでも着実に理解を積み重ねていけるよう意識していきたいです。


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 hours 50 min
- Total: 1352 hours 39 min
