# 2025/09/11(木)
## 📚 プラクティス『lsコマンドを作る1』

:::details 🎯 学習の狙い
- 標準出力について学ぶ
- 標準ライブラリの使い方を学ぶ
- Enumeratorには、each以外に便利なメソッドがあることを学ぶ
- RailsじゃないRubyプログラミングを学ぶ
- メソッド分割を学ぶ
- わかりやすい変数名メソッド名を学ぶ
- 大きな問題を分割する力を学ぶ
:::

:::details 参考
  - [x] [lsコマンドを作る](https://bootcamp.fjord.jp/pages/380)
:::

:::details 学習の狙い
  - [x] [【lsコマンド】大きな問題を小さく分解してから取り組む](https://bootcamp.fjord.jp/pages/279)
:::

:::details ヒント

  - [x] [lsコマンドの使い方と覚えたい15のオプション【Linuxコマンド集】](https://eng-entrance.com/linux_command_ls)
  - [x] [library optparse (Ruby 2.6.0)](https://docs.ruby-lang.org/ja/latest/library/optparse.html)
  - [x] [コマンドライン引数によるオプションに対応する (optparse) | まくまくRubyノート](https://maku77.github.io/ruby/io/optparse.html)
  - [x] [コマンドライン引数・オプションの処理](https://bootcamp.fjord.jp/pages/251)
  - [x] [binding.irb](https://docs.ruby-lang.org/ja/latest/method/Kernel/m/binding.html)
  - [x] [Fileクラス](https://docs.ruby-lang.org/ja/latest/class/File.html)
  - [x] [lsコマンドで表示されるファイルのモード(drwxr-xr-x) 〜RubyのFile::Stat#modeとは〜](https://zenn.dev/universato/articles/20201202-z-mode)
:::

:::details 良いプログラムを書くための方法

  - [x] [プログラミング初心者は変数名やメソッド名を略さない方がいいよ、という話 - give IT a try](https://blog.jnito.com/entry/2020/10/20/092724)
  - [x] [\[RubyTips\] ハッシュテーブルによる分岐数削減](https://docs.komagata.org/5691)
  - [x] [プログラムを書くときの考え方](https://bootcamp.fjord.jp/pages/147)
  - [x] [rubyでコマンドを作る](https://bootcamp.fjord.jp/pages/250)
  - [x] [RubyTips - komagataのブログ](https://docs.komagata.org/tags/rubytips/)
  - [x] [Rubyスクリプトにもmainメソッドを定義するといいかも、という話 - Qiita](https://qiita.com/jnchito/items/4b4cae54170cc2f4377e)
  - [x] [初心者がRailsプロジェクトへの初PRする前に見るチェックリスト - komagataのブログ](https://docs.komagata.org/5676)
  - [x] [プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)
  - [x] [代表的なデータ構造](https://bootcamp.fjord.jp/pages/148)
  - [x] [配列の二人三脚を避ける](https://bootcamp.fjord.jp/pages/388)
  - [x] [参考：lsコマンドの列幅が人によって異なるのはなぜ？ | FBC
](https://bootcamp.fjord.jp/questions/707)
:::

:::details 終了条件の確認

- [x] [終了条件 - lsコマンドを作る](https://bootcamp.fjord.jp/pages/ls-command#requirements)
:::

:::details 📌 要件

- [ ] オプション（`-a`や`-r`など）を付けず、且つ引数（フォルダのパス）も指定せずに実行する
- [ ] そのまま実行すると、今いるフォルダ（カレントディレクトリ）の中身を表示する
- [ ] `gem`は使わずに Ruby の標準ライブラリだけで作ること
- [ ] 完成したコードは GitHub の Pull Request として提出すること
- [ ] `rubocop-fjord`でデバッグを実行し、全てパスさせること
- [ ] 2つ以上のメソッドを自分で定義すること
- [ ] 表示は横に最大3列になるようにレイアウトすること
  - 3, 6, 9, 12のように3の倍数の件数だけでなく、最後の列に空欄ができるケースの結果も載せる
  - 「3列から5列に仕様変更してください」または「3列から100列に変えてください」とあとから言われても必要最小限の変更で対応できるようなロジックにしておくこと

:::

:::details 🐾 スモールステップ ※ 随時追加・変更あり

- [x] ディレクトリやファイルの一覧を取得
- [x] ディレクトリやファイルをアルファベット順で出力
- [x] `.`から始まる隠しファイルを表示させない
- [x] 横に最大3列で表示する（ただし、後で列数を変更できるよう柔軟にする）
  - [x] 要素数、列数、行数についての考え方を掴む
  - [x] 余りを切り上げるメソッドを調べる
  - [x] 縦に要素を並べる
- [x] 件数が列数で割り切れない場合も対応（最後の行に空欄が出るケース）
- [ ] 実際のファイルに適用させる
- [ ] コードの書き方をスッキリさせる（リファクタリング）
:::


---


### 🧑🏻‍💻 本日の取り組み
#### プラクティス『lsコマンドを作る1』🛠️💻
- lsコマンド作成
  - 横に最大3列で表示（後で列数を変更できるよう柔軟に実装）
    - 縦に要素を並べる方法を調べて実装を進めた


---


### ⏭️ 次回
#### プラクティス『lsコマンドを作る1』🛠️💻
- lsコマンド作成
  - 実際のファイルに適用させる


---


### 💡 本日の学び・気付き
#### プラクティス『lsコマンドを作る1』🛠️💻
:::details ⚠️ ネタバレに注意
### 横に最大3列で表示する仕組み
例として配列`a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`を使い、次のように表示することを目標とにした。
```shell
 1     5     9
 2     6    10
 3     7
 4     8
```
**実際に書いたコード**
```ruby
a = (1..10).to_a
columns = 3
rows = (a.size.to_f / columns).ceil

rows.times do |row|
  line = []
  columns.times do |column|
    index = row + column * rows
       if index < a.size
      line << a[index]
    end
  end
  puts line.join("\t")
end
```
```ruby
# 配列の例：要素の数は10個に指定
a = (1..10).to_a
```
- 配列`a`を設定。
- もちろん`a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`という書き方でも大丈夫。
```ruby
# 列数の設定
columns = 3
```
- 「横に並べる列の数」を指定。
- 数値を書き換えれば 5列にも 10列にも変更が可能。
```ruby
# 行数 = 要素の数 ÷ 列数 を切り上げる
rows = (a.size.to_f / columns).ceil
```
- `a.size`→ 配列の要素の個数を取得（今回は 10）。
- `to_f`→ 整数から小数に変更（割り切れない場合を考慮）。
- `columns`→ 列数（今回は最大 3列）。
- `a.size.to_f / columns`→ 10 ÷ 3 = 3.333...（小数で計算するため`to_f`を使用）
- `.ceil`→小数点以下を切り上げる（余りの分を含めるため）
- 結果として、縦詰めで並べた際の**行数**は`4`になる。
```ruby
# 行ごとに処理
rows.times do |row|
```
- `rows.times`→ 0 から`rows-1`まで順番に数字を取り出して、その回数だけ処理を繰り返す。例えば`rows = 4`の場合、0, 1, 2, 3 の4回繰り返す。この数字が`row`に入り、今どの行を処理しているのかを示す。
- `rows-1`
  - `times`は`0`からスタートする。
  - `rows = 4`なので、数字（インデックス）は0, 1, 2, 3 まで出る。
  - つまり、最後の数字は`rows-1`となる（`4-1=3`）。
```ruby
# 1行分の要素を入れる配列
line = []
```
- `line = []`→ 空の配列を用意する（配列の宣言）。
- `line`→ 変数`line`にから配列を代入。
- つまり「1行分の要素を入れておくための入れ物を用意している」ということ。
- その後に`line << a[index]`で、配列`a`から取り出した要素を`line`に追加していく。
- 最終的に`line.join("\t")`で、その 1行分をタブ文字で文字列にして表示する。
```ruby
# 列ごとに処理
columns.times do |column|
```
- `columns.times`で`0`から`columns-1`まで繰り返す。
- `column`→ **現在処理している列番号**。
- 「1行の中で各列にどの要素を置くのか」を順番に行う。
```ruby
# 縦詰めのための計算（インデックスを用いた計算）
index = row + column * rows
```
- 縦詰めにするための**配列のインデックスの計算**。
- 仕組み
  - ① `row`→ 現在の行番号
  - ② `column * rows`→ 列が進むごとに「行数分だけインデックスを飛ばす」
    - 例：2列目（`column = 1`）なら、`1 * 4 = 4`を足す → インデックス4から始まる。
  - ③ `row + column * rows`→ 最終的な配列の位置（インデックス）が分かる。
- これにより、配列を縦に詰めて夏に並べることができる。
```ruby
# 配列の範囲を超えない場合のみ追加
if index < a.size
  line << a[index]
end
```
- `index < a.size`
  - `a.size`は配列の要素の個数を取得（ここでは 10）。
  - `index`が`0から9`の範囲にあるときだけ取り出せる。
  - もし`index`が 10以上なら、要素は存在しないので取り出せない。`index = 10`なら、要素は`11`だから。
  - 「`index`が配列の個数より少ないか？」をチェックしている。
- `line << a[index]`
  - `a[index]`を取り出して`line`に追加。
  - 「その行に表示する要素」を並べていく。
  - `a`は配列、`index`はインデックス番号。よって`a[index]`は、「配列`a`の`index`番目の値（要素）」を取り出す、という意味。
- まとめると、① `index`が配列の大きさより小さいかチェックする。②小さいなら、その位置の要素を取り出す（`a[index]`）。③それを`line`に追加する（`<<`）。
```ruby
# 行をタブ文字で出力
puts line.join("\t")
```
- `line`→ 「1行に出力するための配列」。今回の例では途中で`line = [1, 5, 9]`のような配列になることがある。
- `join`→ `join`は**配列の要素を連結して1つの文字列にする**メソッド。
例：
```ruby
line = [1, 5, 9]
line.join("-")  #=> "1-5-9"
line.join(", ") #=> "1, 5, 9"
```
- `"\t"`→ タブ文字。



- 実行結果
```shell
# 要素の数は10、columns = 3 のとき
% ruby ls.rb
1       5       9
2       6       10
3       7
4       8

# 要素の数は25、columns = 5 のとき
% ruby ls.rb
1       6       11      16      21
2       7       12      17      22
3       8       13      18      23
4       9       14      19      24
5       10      15      20      25
```
↑要素数や列数を変更しても対応できていることを確認。
:::


---


### ✍🏻 感想
#### 🏃🏻‍♂️‍➡️ 難しいけれど前進！
質問チャンネルでメンターの多田さん相談したところ、ヒントをいただき、練習で「横に3列・縦詰め」で出力することができました。次回は実際のファイルを対象に進めていきます。


#### 🗣️ 今日のアドバイス振り返り
多田さんからのアドバイスを共有します。

- 規則性を見つけて考えることが大事
- 規則があればそれをプログラミング落とし込める
- 情報系学科では規則性を学ぶ
- 規則性や共通点を見つけたらコード化して実装
- フローチャートは旅のしおり
    - 「どこへ行くのか（何を作るのか）」をイメージすることが大切
    - フローチャートが作れないのは経験不足が原因
    - イメージできないときは、とにかく手を動かすことが大事

自分の進捗が遅い理由がわかりました。経験不足なら、たくさんコードを書いてたくさん知識を身に付ければいいだけ。「何事も経験」をモットーにしているのだからこれからもっともっと頑張ろう！

多田さん、今日もありがとうございました☺️✨


---


### ⏰ 学習時間
- Today:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 hours 23 min
- Total: 1288 hours 47 min
